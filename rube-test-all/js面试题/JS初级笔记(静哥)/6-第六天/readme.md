`[5,2,1,4]`

//比较数，第一个和第二个数比较 第二个和第三个数比较 第三个和第四个比较......

//前面的数字大就交换位置。

1----------------------------------

5和2 交换 2 5 1 4

5和1 交换 2 1 5 4

5和4 交换 2 1 4 5

第一圈完成共计3次，最后一个数是最大的。

2----------------------------------

2和1 交换 1 2 4 5

2和4 不交换 1 2 4 5

第三个数不用和第四个比较因为第四个就是最大的。

第二圈比较共计2次，最后一个数最大，倒数第二个是第二大的。

3-------------------------------

1和2 不交换 1 2 4 5

第二个和第三个不用进行比较，因为第三个肯定比第二个大。

第三圈完成共计一次。



总共4个数比较了3圈，第一圈得到了一个最大的数然后比较了3次，第二圈得到了第二大的数然后比较了2次，第三圈得到了第三大的数然后比较了1次。

```js
var arr = [5, 4, 3, 2, 1];
//第一圈比较----得到了最大的一个数------比较了4次
// //1. 得到比较的值的下标。
for (var i = 0; i < arr.length - 1; i++) {
    //2. 比较对应下标的值，大的放后面，小的放前面。
    if (arr[i] > arr[i + 1]) {
        var tmp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = tmp;
    }
}
//4 3 2 1 5
//第二圈比较-------得到了第二大的数-------比较了3次
/*
i = 0; i < 3 ; 0 < 3 true
    arr[0] > arr[1]    4 > 3 true
        tmp = 4 ; arr[0] = 3 ; arr[1] = 4;
3 4 2 1 5

i = 1; i < 3 ; 1< 3 true
    arr[1] > arr[2]     4 > 2 true
        tmp = 4 ; arr[1] = 2 arr[2] = 4

3 2 4 1 5

i = 2 ; i < 3  2<3 true
    arr[2] > arr[3]    4 > 1 true
        tmp = 4 ; arr[2] = 1 arr[3] = 4;

3 2 1 4 5

i = 3 3<3 false

*/
for (var i = 0; i < arr.length - 1 - 1; i++) {
    if (arr[i] > arr[i + 1]) {
        var tmp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = tmp;
    }
}
//第三圈比较---------------得到的第三大的数 ---------------比较了两次
//3 2 1 4 5
/*
i = 0 ; i < 2   0<2 true
    arr[0] > arr[1]   3 > 2  true
        tmp = 3 ; arr[0] = 2 ; arr[1] = 3;
2 3 1 4 5

i = 1 ; 1 < 2 true
    arr[1] > arr[2] 3 > 1 true
        tmp = 3 ; arr[1] = 1 ;arr[2] = 3;
2 1 3 4 5

i = 2  2 < 2 false
*/
for (var i = 0; i < arr.length - 1 - 1 - 1; i++) {
    if (arr[i] > arr[i + 1]) {
        var tmp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = tmp;
    }
}
//第四圈--------------获得的是第四大的值总共比较了1次。
//2 1 3 4 5
/*
i = 0 ; i < 1  0 < 1 true
    arr[0] > arr[1]    2 > 1 true
        tmp = 2 ; arr[0] = 1 ; arr[1] = 2;
// 1 2 3 4 5
i = 1 ; i < 1 false
*/
for (var i = 0; i < arr.length - 1 - 1 - 1 - 1; i++) {
    if (arr[i] > arr[i + 1]) {
        var tmp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = tmp;
    }
}
console.log(arr)

//第一个数肯定就是最小的了。

/*
5个数进行了4轮比较，每轮比较都会得出本轮最大的值，第i轮排序的次数应该为 length-i   当前的圈数
*/
```

----

- 简便方法

```js
// 简便方法
var arr = [5, 4, 3, 2, 1];

for (var i = 1; i < arr.length; i++) {//这里i表示的是当前进行的第几圈。
    // console.log(i);
    //里头的这层循环就是用来排序的
    for (var j = 0; j < arr.length - i; j++) {
        if (arr[j] > arr[j + 1]) {
            var tmp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = tmp;
        }
    }
}
console.log(arr);
```



#### 函数

函数是数据、函数是对象。

对象：属性（特征、名词）、方法（动词、行为）。

`()`的作用：

1. 分组操作符。是用来对数据进行分组的。`1 + (2 + 3)`
2. 函数调用符。`test()`

```js
Function test () {
    test()
}
console.log(Function)
解析：第一个Function 是“关键字”，第二个Function 表示 “类”。
```





#### 函数的参数

我们自定义函数要确保它能够进行一些微调。 主体功能不变但是可以略微的进行一些调整。

将功能代码中经常变的量提取出来作为参数。

```js
function printTable(rowNum, colNum) {
    /* var rowNum = 10;
    var colNum = 10; */
    document.write('<table border="1" width="800">');
    for (var row = 1; row <= rowNum; row++) {
        document.write('<tr>');
        for (var col = 1; col <= colNum; col++) {
            document.write('<td>&nbsp;</td>');
        }
        document.write('</tr>');
    }
    document.write('</table>');
}
printTable(10,10);
```

我在定义`printTable`时，在定义的括号中的`rowNum`和`colNum`这些我们叫形参。调用`printTable()`时往括号中传递的参数叫实参。

* 形参：形式上的参数，声明函数的时候，提供的参数。
* 实参：调用的时候再`()`中实际使用的参数。

**注意：** 

1. 形参和实参在传值时是一一对应的。
2. 如果有多个形参和实参使用逗号将他们分隔开。
3. 函数的形参就相当于在函数内部定义了一个变量。
4. 函数也是数据，也是对象。其中有一个`length`属性，用来表示具体有多少个形参。
5. ES中函数的形参、实参个数可以不相等。
   1. 如果实参比形参少，那么多出来的形参将会自动被赋值为`undefined`。
   2. 如果实参比形参多，那么多出来的实参将会被`arguments`对象获得（所有的实参都会被它获得）。

#### arguments对象

* arguments是实参对象。

* arguments对象只在函数内部才有。

* arguments对象是类数组对象（array-like，像数组但是不是。）它和数组相似是因为其中包含了索引和length属性。你可以访问到每个传入的实参。

  现在咱们讲的arguments对象是类数组，它和真正的数组的区分等到后面。

* 函数中的形参其实可写可不写，但是使用形参可以更方便一些。

* arguments对象通常用在不知道具体应该传入多少实参的情况下使用。

  ```js
  //我现在要一个函数，这个函数用来计算传入的参数的和。但是具体有多少个数我不知道。
  
  function mySum(){
      var sum = 0;//这个用来存储每次的和
      for (var i = 0 ; i < arguments.length ; i++) {
          sum += arguments[i];
      }
  
      console.log(sum);
  }
  
  mySum(1,2,4,5,6);
  ```

* arguments对象中的length属性指的是实参传入的个数。

> 参数是根据需求用来微调代码的。
>
> 获得实参的个数：console.log(arguments.length)
>
> 获得形参的个数：console.log(test.length) // 这里的test是自定义的，根据你的函数名

#### 返回值

返回要用return，return后面的值是返回值，这个值将会返回到函数的调用处。

**函数从哪里调用返回的结果就返回到哪里去。**

什么时候用return，什么时候不用return完全看你函数的功能。

**注意：**

1. 函数在定义的时候不必指定返回值。但是没有返回值默认的时候返回undefined。
2. return的代码永远不会执行，遇到return将会立即退出函数。
3. return语句后面不一定要带有返回值，函数在停止执行之后将返回undefined值。

函数的返回值有两个作用：

1. 返回函数中要返回的值。
2. 终止函数的执行。



函数有三大件组成： 

* 函数体，功能。
* 参数
* 返回值，获得函数体最终的结果的。



#### 堆和栈

堆和栈就是数据结构，堆（链表结构）、栈（栈结构）

程序在运行时在内存中按照逻辑分为了堆内存和栈内存。

* 栈：栈内存，比较小，速度快，操作系统自动分配回收。

  特点：先进后出

  ![20200606210934](readme_img/20200606210957700_14839.png)

* 堆：堆结构开辟的内存比较大，但是速度稍微慢一些。一般都是由程序员自己向系统中申请分配、如果要想让内存回收，必须手动释放。

  特点：先进先出

![20200606211151](readme_img/20200606211212421_3281.png)

底层语言中是这样，但是在JS中我们回收内存几乎都是自动回收的，因为`JavaScript`中封装了垃圾回收机制。

#### 执行环境

`JavaScript`的运行环境分为两种： 

1. Global，全局执行环境。`JavaScript`代码开始运行的时候的默认的运行环境。
2. Function，函数（也成局部执行环境），调用一个`JavaScript`函数时才会进入到这个环境。

每个执行环境我们也称为执行上下文。

代码在执行的时候开辟出来一段栈空间用来说明代码的执行顺序，这个栈我们叫执行栈。

```js
function test(){
    var a = 1;
    var b = 2;
}
function test1(){
    var c = 3;
    var d = 4;
}

test();
test1();
```

1. 当`JavaScript`代码执行时会先将全局执行环境压入到栈底，当执行到函数的时候会创建函数执行环境，并将函数执行环境压入到栈底（最下面是全局执行环境，全局执行环境的上面压着函数执行环境）
2. 函数执行完成之后将函数执行环境弹出执行栈并且销毁（和执行环境相关的一系列的东西都会被销毁）。
3. 一直到所有的代码都执行完成之后才会将全局执行环境销毁。

#### 执行环境的阶段

* 创建阶段（做准备工作）
  * 全局执行环境，一上来进入到了全局执行环境的创建阶段。
  * 函数执行环境：当前函数被调用，但是真正的开始执行函数内部代码之前。
* 代码执行阶段（真正的解释、执行代码）

