# vue 

1. 属性动态改变内容用冒号`：`，元素动态改变内容用双括号`{{}}`。

2. 指令：带有`v-`前缀的特殊属性。

3. 配置对象：属性名固定的对象。

4. 方法调用、computed、watch的区别：

   1. 方法：页面数据每次重新渲染都会重新执行，性能消耗大，除非不希望有缓存的时候用。 
   2. computed：是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，不可异步。(有返回值)
   3. watch：监听到值的变化会执行回调，在回调中可以进行一些逻辑操作，可以异步操作。(没有返回值)

   **注意：**

   1. 所被 Vue 管理的函数，最好写成**普通函数**，这样 this 的指向才是 vm 或 组件实例对象。
   2. 所有不被 Vue 所管理的函数(定时器的回调函数、Ajax的回调函数、Promise的回到函数等)，最好写成**箭头函数**，这样 this 的指向才是 vm 或 组件实例对象。

   总结：

   - 除非不希望缓存，一般不会用方法。
   - 一般来说需要依赖别的属性来动态获得值的时候可以使用 computed。
   - 对应监听到值的变化需要做异步操作或开销较大的操作时用 watch。
   - 使用时，优先考虑计算属性，计算属性做不了再使用监视属性。

5. **注意：**计算属性只适用于当前组件。

6. 可以简写的三条指令：v-bind(简写为 : )、v-on(简写为 @)、v-slot(简写为 #)。

7. 可以添加修饰符的三条指令：v-bind、v-on、v-model。

8. 样式处理：

   1. class：

      - 字符串形式：适用于类名不确定，要动态显示。

        `:class="xxx"`

      - 对象形式：适用于要绑定多个样式，个数不确定，名字也不确定。

        `:class="{ xxx: true, yyy: false }"`

      - 数组形式：适用于要绑定多个样式，个数确定，名字也确定，但不确定用不用。

        `:class="[xxx, yyy]"`

   2. style：`:style="{ fontSize: '20px', xxx: yyy }"`

   3. 总结：

      1. 固定不变的样式，通过 `class` 写死。
      2. 会发生变化的样式：
         - 如果是有限几种的变化，可以用 `:class`。
         - 如果是无限的变化，可以用 `:style`。

9. 样式单数据只有一种做法：v-model。

10. v-for 遍历，**遍历数组中的内容**，如：`<li v-for="(wang, index) in wangs">{{wang.name}}的年龄是：{{wang.age}},索引值为：{{index}}</li>` 

   括号中的 `(wang, index)`第一个`wang`为值，第二个`index`为索引。

11. v-for 遍历，**遍历对象中的内容**，如：`<li v-for="(value, key, index) in wangs">属性值为：{{value}}，属性名为：{{key}}，索引值为：{{index}}</li>`  

   括号中的 `(value, index)`第一个`value`为属性值，第二个`key`为属性名，第三个 `index`为索引值。因为对象是键值对的形式，所以要有属性名和属性值，而后是索引。

11. 开发中：`asc` 表示"升序"，`desc` 表示"降序"，是 decrement 的缩写。

12. 下拉列表绑定 `v-model`给`select`绑定，`option` 中放`value` 值。

13. vue 实例对象上自身的属性或方法都是`$`符号开头，除了数据代理的属性(data, methods, computed)。

14. Vue 监视数据的原理：(天禹)

    1. Vue 会监视 data 中所有层次的数据。

    2. 如何监测对象中的数据？

       通过 setter 实现监视，且要在 new Vue 时就传入要监测的数据。

       1. 对象中后追加的属性，Vue 默认不做响应式处理。

       2. 如需要后添加的属性做响应式，请使用如下API：

          ```vue
          Vue.set(target, propertyName/index, value) 或者
          vm.$set(target, propertyName/index, value)
          ```

    3. 如何监视数组中的数据？

       通过包裹数组更新元素的方法实现，本质就是做了两件事：

       1. 调用原生对应的方法对数组进行更新。
       2. 重新解析模板，进而更新页面。

    4. 在 Vue 修改数组中的某个元素一定要用如下方法：

       1. 使用这些 API: push()、pop()、shift()、unshift()、splice()、sort()、reverse()。
       2. Vue.set() 或 vm.$set()

    **特别注意：**Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象 添加属性。

15. vue 中的普通函数 this 都是指向实例对象，生命周期函数也是。

16. 如果 vue 函数中的函数需要用箭头函数，不然 this 执行会不对。

17. 在 vue 实例中，定时器需要自己在 beforeDestroy 中清除。

18. `moment.js` 可以设置时间，现在不怎么用了，用`dayjs`。

19. `date-fns`也是一样的可以设置时间，比`dayjs`下载量还多。

20. 第三方的库对引入顺序没有太多要求。

21. 计算属性(`computed:{}`)就是下面三点：

    1. 获取要参与计算的数据。
    2. 开始计算。
    3. 返回计算结果。(计算属性一定要有返回值，否则没有意义)

22. 面试题: 请求在 `created` 发送还是 `mounted` 发送，为什么？

    created 优势：发送请求的时机快一点，最终响应回来的速度就快一点。

     mounted 优势：

    1.  可以操作 DOM。
    2.  让首屏渲染速度更快一点。

23. 图片懒加载可能会用自定义指令去做。

24. 使用自定义插件：`Vue.use(无引号的插件名)`

25. 组件三部曲：1. 定义组件。2. 注册组件。3. 使用组件。

    组件中 data 必须定义成函数形式。

26. 局部组件需要：1. 引入。2. 注册。3. 使用。

27. PWA：`Progressive Web App` 是一种理念，使用多种奇数来增强 web app 的功能，可以让网站的体验变得更好，能够模拟一些原生功能，比如通知推送。

    一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用。

28. 脚手架中，可以用大驼峰，命名引入。但是在页面中不可以，页面中可以如：`<test-component></test-component>`

29. 更新数据：数据源在哪儿，更新数据的方法就在哪儿。不然可能会有更新上的隐患。

30. DOM 事件：

    1. 事件名是固定的。
    2. 触发事件：满足要求(用户界面等)就会自动触发。

31. 自定义事件一般是给组件绑定的。

    1. 事件名可以按照自己的要求来起名。
    2. 手动触发事件。方法：`this.$emit(事件名称,事件回调参数)`
    3. 给组件绑定的事件，都是自定义事件。

32. 绑定自定义事件有两种方式：

    1. `<Child @setCount="setCount" />`

    2. `<Child ref = "child"/>`

       ```js
       mounted() {
           this.$refs.child.$on('setCount', this.setCount)
       }
       ```

33. 触发自定义事件：

    this.$emit(事件名称，事件回调参数)

34. 自定义相关事件

    1. $on 绑定持久性事件
    2. $once 绑定一次性事件
    3. $off 解绑事件
    4. $emit 触发事件

35. 特点：自定义事件只为指定的某一个组件服务，给哪个组件绑定，就只有这个组件可以触发。

36. 组件实例的隐式原型指向 vue 实例上的`Vuecomponent`的原型对象。

37. 父子传递数据用：props。兄弟，祖孙之间传递数据用：全局事件总线。

38. 响应式：更新数据(data 中的数据)，数据会发生变化，同时用户界面也会更新。

39. 库和框架的区别：

    1. 库：
       1. 把一些常用的功能封装成一个个函数或者对象，并放到一个 js 文件里，目的是为了简化原生 js 的操作，它是一个封装好的集合。能够解决部分的功能。
       2. 特征：小而美。
    2. 框架：
       1. 一套架构，提供一套整体解决方案，它能完全搞定整个项目开发，并且很轻松就能解决复杂的问题。
       2. 特征：大而全(比较大，功能比较全)。

40. MVC、MVP 和 MVVM：

    **MVC：**

    1. M Model 		模型(数据)：主要任务就是操作数据。
    2. V View           视图(结构)：主要任务是将数据模型转化成UI视图展示出来。
    3. C Controller  控制：主要任务负责处理业务逻辑。

    View 传送指令到 Controller。

    Controller 完成业务逻辑后，要求 Model 改变状态。

    Model 将新的数据发送到 View，用户得到反馈。

    **MVP：**

    1. 各部分之间的通信，都是双向的。
    2. View 与 Model 不发生联系，都通过 Presenter 传递。
    3. View 非常薄，不部署任何业务逻辑，称为“被动视图(Passive View)”，既没有任何主动性，而 Presenter 非常厚，所有逻辑都部署到那里。

    **MVVM：**

    1. M Model 		模型(数据)：主要任务就是操作数据。
    2. V View           视图(结构)：主要任务是将数据模型转化成UI视图展示出来。
    3. VM ViewModel 视图模型(控制)：监听 Model 数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 对象，连接 Model 和 View。

    ViewModel 通过双向数据绑定把 View 层 和 Model 层 连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

    MVC 和 MVVM 的区别：这两个的原理是一样的，不过，MVVM 中的VM 解决了 MVC 当中大量操作 DOM 的问题。

    > 通过控制层把数据渲染到视图当中。

41. 为什么要使用MVVM？

    **使用 MVC 的时候，前端开发会遇到：**

    1. 开发中大量调用相同的 DOM API，处理繁琐，代码难以维护。
    2. 大量操作 DOM，使页面渲染慢，性能降低。
    3. 当 Model 频繁发生变化，开发者需要主动更新到 View。

    **MVVM 的出现，完美解决这三个问题：**

    1. Model 层代表数据模型，也可以在 Model 中定义数据，操作或修改业务逻辑。
    2. View 代表 UI 组件，它负责将数据模型转化为 UI 展示到页面上。
    3. ViewModel 是一个同步 View 和 Model 的对象。

    在 MVVM 架构下，View 和 Model 之间并没有直接联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的。

    因此，View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。View 和 Model 之间的同步工作完全是自动的，无需人为干涉。

42. 给 input 标签打了一个 ref，input 标签是 HTML 内置的标签，所以通过 `this.$refs.keyWord` 获取到的是真实 DOM 节点。

43. ref 的使用：

    1. 标签中直接编写 `ref="xxxx"`
    2. 通过 `this.$refs.xxxx` 获取
    3. 备注：
       1. 若给 html 内置标签使用 ref，则获取到的是真实 dom 节点。
       2. 若给组件标签使用 ref，则获取到的是组件实例对象。

44. props 的用法：

    1. 传递 props：`<Demo :a="xxx"/>`

    2. Demo 组件中声明接收：

       第一种方式(只声明)：`props:['userName']`

       第二种方式(限制类型)：

       ```js
       props: {
           userName:Number
       }
       ```

       第三种方式(限制类型、属性，指定默认值)：

       ```vue
       props: {
           userName: {
               type: String,
               required: true,
               defaulte: '老王'
           }
       }
       ```

       

45. 设置拦截器：

    发送请求工作流程：

    1. 触发请求拦截器的回调(接收参数：config，返回值：config)

       设置公共的请求参数

    2. 发送请求

        发送请求的配置对象由请求拦截器的回调返回指定触发

    3. 触发响应拦截器的回调

        响应拦截器的回调(接收参数：response，返回值：response.data.data)

        处理响应结果

    4. 触发 then/catch 的回调

        then 接收到的参数由上一步的返回值指定

46. 差值语法和指令语法中不用写 this。因为插值语法和指令语法中的东西都能自动找到`vm`和`vc`上的东西。

47. watch 中的深度监视：(天禹)

    1. Vue 中的 watch 默认不监测对象内部值的改变(一层)。
    2. 配置 `deep:true` 可以监测对象内部值改变(多层)。

    备注：

    1. Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以。
    2. 使用 watch 时，根据数据的具体结构，决定是否采用深度监测。

48. 函数防抖：在规定时间内频繁触发，最后一次触发生效(如果在规定时间内触发了会重新计时)。

    函数节流：在规定时间内，第一次触发生效(触发完开始计时)。

    函数防抖和节流的作用：优化函数的性能，减少规定时间内的函数调用次数。

49. 同等位置，在 vue 中同等位置事件指令优先于其他指令。而`v-for` 优先于`v-if`。

50. 在`<template>`上可以写 v-if，但是不能写 v-show。

51. v-show 与 v-if 的区别：

    实现本质：

    1. v-show：通过 display: none; 和 display: block; 之间切换。
    2. v-if：通过 dom节点的插入、删除来实现切换。

    性能对比：

    ​	v-if：

    1. 切换时需要删除、插入节点，开销大。
    2. 但是在初始化的时候，如果条件是 false 是不会插入节点渲染的(会节约性能)。
    3. 总结：如果不是频繁切换只需要渲染时条件渲染用v-if。

    ​    v-show：

    	1. 有更高的初始渲染开销，就算是 false 也会渲染。
    	2. 但是在切换的时候只是改变样式，消耗少。
    	3. 总结：在频繁切换的时候用 v-show。

52. 三种命名方式：

    1. `camelCase` 小驼峰
    2. `PascalCase` 大驼峰
    3. `kebab-case` 首字母小写，单词间用短横线相连。

    > 注意：Vue 事件中不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 cameCase 或 PascalCase 了。因此，我们推荐你始终使用个kebab-case 的事件名。**以上是Vue文档中的原话。**

53. 什么是生命周期：生命周期是物体从诞生到死亡的过程，Vue 的生命周期就是 vue 从初始化到销毁的过程。

    什么是钩子函数：

    1. 在生命周期的过程中，我们有很多特殊的时间段，我希望在这些特殊的时间段对 vue 做一些事情，所以出现了钩子函数。
    2. 钩子函数就是作者在设计 vue 的时候，在 vue 从初始化到销毁的这段时间内的特殊时段给我们一些定义函数的权利。
    3. 如果咱们定义了，就会执行，不定义就不会执行。

    Vue 都有哪些生命周期：

    1. beforeCreate 创建前
    2. created 创建后
    3. beforeMount 挂载前
    4. mounted 挂载后
    5. beforeUpdate 数据更新前
    6. updated 数据更新后
    7. beforeDestroy 销毁前
    8. destroy 销毁后

    这些有什么区别和意义：

    1. beforeCreate 创建前：beforeCreate 是在数据代理之前触发的，刚执行 new 的操作，其他什么都没做。

       数据代理：将data、methods、computed等数据挂载到 this 上，可以通过 this 直接使用。

    2. created 创建后：属性和方法挂载到了实例上面。

    3. beforeMount 挂载前：找到了 el 或 mount 对应的节点范围，但是数据还没有替换。

    4. mounted 挂载后：vue 范围内的变量都会被替换成 data 里面对应的数据值。

    5. beforeUpdate 数据更新前：

    6. updated 数据更新后

    7. beforeDestroy 销毁前

    8. destroy 销毁后

    我们在项目中什么时候会用：我们在页面初始化时需要获取数据，这个时候就可以在生命周期里面调用。

    常用的生命周期方法

    ` created()/mounted(): `发送 ajax 请求, 启动定时器，创建自定义事件，信息发布与订阅等异步任务。

    ` beforeDestory():` 做收尾工作, 如: 清除定时器、解绑自定义事件等。

54. 面试题: 请求在 created 发送还是 mounted 发送，为什么？

    ​      created优势：发送请求的时机快一点，最终响应回来的速度就快一点。

    ​      mounted 优势：

    ​       1. 可以操作DOM。

    ​       2. 让首屏渲染速度更快一点。

55. 在生命周期中写的钩子函数永远都是`vc(VueComponent)`。

56. 给组件绑定内置事件是触发不了的。如：`<Demo @click="test"/>` 因为这个 Demo 组件会 =》new Demo() 到=》vc(VueComponent)上，VC是在内存中的对象，在页面上不能被点击。需要使用自定义事件来处理。

57. 自定义数据传参三条原则：

    1. A 组件想让 B 组件给自己传数据，那么就要给 B 组件绑定自定义事件。
    2. 自定义事件的回调在哪，哪才能接收到数据。
    3. 适用于 子给父传递数据。

58. 插槽：动态的给组件传递 HTML 结构。

59. Vuex：集中式数据管理。负责各层级组件中数据的传递。

60. cookie 相对于`localStorage`的好处：每次发送请求会自动携带该 token。

61. `component: () => import('@/views/dashboard/index'),`路径中的 @ 符，在 vue 项目中表示 src 文件夹。在`jsconfig.json`中去配置：

    ```js
    {
      "compilerOptions": {
        "baseUrl": "./",
        "paths": {
            "@/*": ["src/*"]
        }
      },
      "exclude": ["node_modules", "dist"]
    }
    ```

    

62. `layout="prev, pager, next, jumper, -> , sizes, total"` element UI 中 这个`箭头符号 ->` 表示让 `sizes` 和 `total` 在页面的最右边显示。

63. 网站实现三步骤：

    1. 静态页面
    2. 请求数据、渲染显示
    3. 交互

64. 注意：响应式做两件事：1. 更新数据 2. 更新视图

     数据更新：同步更新状态数据。

     视图更新：Vue 在更新 DOM 时是异步执行的。

     通过`$nextTick`的回调函数(`$nextTick`的回调函数会在.then中执行)，一定可以得到当前的最新 DOM。

65. Vue 中，响应式更新视图的最小单位是组件，最小的渲染单位是标签。

    但是，并不是说组件拆得越多越好，因为每个组件都会生成一个组件实例对象，很消耗性能。

    组件拆分标准：一般工作中以功能进行拆分，其次考虑性能(尽量避免一个组件状态和结构过多)。

66. 同步请求和异步请求的区别：

    1. 同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。
    2. 异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。

67. async 和 await 的作用非常的小，只能影响到当前函数内部。

68. blob 数据类型以随机存取块的形式存储任何种类的二进制数据；二进制数据通常由已保存的电子表格、程序装入模块和数字化声音模式等等组成。

69. data 和 props 最大的区别是：

    data 是接收自身的状态，props 是接收外部传进来的状态，props 是只读的，不能修改(否则控制台会报错)。

70. keep-alive 组件有什么用：

    如果你需要在**组件切换**的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。

    动态组件(组件之间切换)如果不加 keep-alive 相当于每次都会销毁、诞生。会导致切换后，之前添加的数据无法保存下来。

    对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated。

    **activated：**在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 keep-alive 激活时被调用。

    **deactivated：**在组件被停用时调用。

    **注意：**只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用，是不会被调用，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive 中，这两个钩子依然不会被调用！另外在服务端渲染时此钩子也不会被调用的。

    用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数。

    在vue 2.1.0 版本之后，keep-alive 新加入了两个属性: include(包含的组件缓存生效) 与 exclude(排除的组件不缓存，优先级大于include) 。

    include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示。
    当使用正则或者是数组时，一定要使用 v-bind !

    include：字符串或正则表达式。只有名称匹配的组件会被缓存。

    excluded：字符串或正则表达式。任何名称匹配的组件都不会被缓存。

    max：数字。最多可以缓存多少组件实例。

71. 组件中的 data 为什么不用对象的形式来写？

    组件复用时所有组件实例都会共享 data，如果 data 是对象的话，就会造成一个组件修改 data 以后会影响到其他所有组件，所有需要将 data 写成函数，每次用到就调用一次函数，获得新的数据。

    当我们使用 new Vue() 的方式的时候，无论我们将 data 设置为对象还是函数都是可以的，因为 new Vue() 的方式是生成一个根组件，该组件不会复用，也就不存在共享 data 的情况了。

72. 什么是 Vue Loader？

    如果我们用脚手架开发 vue，或者利用 webpack 配置开发 vue 项目的时候，肯定会接触组件化开发。

    **组件的定义有三种形式：**全局组件、局部组件、文件组件。

    所谓的**文件组件**就是 .vue 的组件形式，一个文件一个组件。

    但是会出现一个问题就是 .vue 的文件无法被浏览器所解析。

    Vue Loader 就是把 .vue 文件解析成浏览器能看懂的 html/css/js 文件。

73. 为什么脚手架中`<style>`标签有 scoped 属性？

    当`<style>`标签有 scoped 属性时，它的 css 只作用于当前组件中的元素。

    ```css
    <style>
     /* 全局样式 */
    </style>
    
    <style scoped>
      /* 本地样式 */
    </style>
     
    /* 两者是可以混用的，使用 scoped 后，父组件的样式将不会渗透到子组件中。*/
    ```

74. 什么是组件？

    组件就是为了拆分 Vue 实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件就可以了。

75. 什么是组件化？有什么好处？

    **组件化：**任何一个页面我们都可以抽象成由一堆组件构成的一个大的组件树。大到一个页面，小到一个按钮都可以是一个组件，一个页面就是由很多的组件嵌套拼接组成，这就是组件化。

    **组件化的好处：**复用性强、分工开发、代码好管理(方便维护)、耦合度低。

    耦合度：是一种软件度量，是指一程序中，模块及模块之间信息或参数依赖的程度。耦合度高就是相互间的信息、参数依赖高。

76. vue 如何创建组件化？

    vue 如何创建组件：

    1. 全局组件。`Vue.component('组件名称', 组件详情的对象)`

    2. 局部组件。 

       ```js
       new Vue ({
       	...
       	components: {
       		组件的名称：组件详情的对象
       	}
       })
       ```

       

    3. 单文件组件。`.vue`文件。单文件一般用于构建整个项目，用到 webpack 的时候，才会去用。

77. 组件化和模块化的区别是什么？

    - 模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个模块功能的职能单一。例如：Node.js
    - 组件化：是从 UI 界面的角度进行划分的，前端的组件化，方便 UI 组件的重用。

78. vue 组件之间如何通信？

    1. 父组件 向 子组件 传递值。

       1. 在父组件中引入子组件。
       2. 注册子组件。
       3. 在页面中使用，子组件标签上 动态绑定传入动态值 / 静态值。
       4. 在子组件中，使用 `props` 来接受 `父组件` 传递过了的值。

       > 由于 `Vue` 是 单向数据流， `子组件` 不能直接 修改 `父组件` 的 值。

    2. 子组件 向 父组件 传递值

       子组件通过绑定事件，通过 `this.$emit('函数名'，传递参数)`

       `let Event = vue Vue ();`

       数据的发送：`Event.$emit('接口'，数据)`

       数据的接收：`Event.$on('接口'，function(v){ // 发过来的数据})`

    3. 父组件 通过 `$refs/$children` 来获取子组件值

       `$refs` :

       - 获取DOM 元素 和 组件实例来获取组件的属性和方法。
       - 通过在 子组件 上绑定 ` ref` ，使用 ` this.$refs.refName.子组件属性 / 子组件方法`

       ` $children`  :

       - 当前实例的子组件，它返回的是一个子组件的集合。如果想获取哪个组件属性和方法，可以通过`this.$children[index].子组件属性/f方法`

    4. 子组件 通过 `$parent`来获取父组件实例的属性和方法

       ```vue
       <script>
           export default {
               name:'test',
               created(){
                console.log( this.$parent.obj ) 
                this.$parent.getQuery()
               },
               
           }
       </script>
       ```

       

    5. `$attrs` 和 `$listener`获取父组件实例属性和方法(组件嵌套情况下使用)

       **`$attrs`**：包含了父作用域中不被认为 (且不预期为) ` props` 的特性绑定 (class 和 style 除外)，并且可以通过 v-bind=”` $attrs`” 传入内部组件。当一个组件没有声明任何 ` props` 时，它包含所有父作用域的绑定 (class 和 style 除外)。

       **`$listeners`**：包含了父作用域中的 (不含 .native 修饰符) v-on 事件监听器。它可以通过 v-on=”`$listeners`” 传入内部组件。它是一个对象，里面包含了作用在这个组件上的所有事件监听器，相当于子组件继承了父组件的事件。

       使用场景： 多层嵌套组件的情况下使用，可以避免使用 Vuex 来做数据处理， 使用`v-bind="$attrs" v-on="$listeners"`很方便达到业务数据传递。
       
    6. 跨组件之间传值

       通过新建一个 `js` 文件，导入` vue` , 导出` vue` 实例； 然后通过 给导出的实例 上绑定事件` $emit` 事件 , 然后再通过 `$on` 监听触发的事件，这样就可以达到全局组件数据共享。

       使用场景：它可以满足任意场景传递数据， `父子组件传值` , `子父传值` , `兄弟组件之间传值` , `跨级组件之间传值` 。

       通信数据比较简单时，可以采用这种 方案，项目比较庞大，可以采用`Vuex`

    7. vueX 作用太大，这里不做介绍。

    8. provide 和 inject 实现父组件向子孙组件传值(层级不限)

       `provide`  和   ` inject`  这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。

       `provide` :

       - 是一个对象或返回一个对象的函数
       - 该对象包含可注入其子孙的属性。

       ` inject` :

       - 是一个字符串数组 或者是一个对象
       - 用来在子组件或者子孙组件中注入 ` provide` 提供的父组件属性。

       使用场景：`provide/inject` 可以轻松实现跨级访问父组件的数据。
       
    9. 插槽：所谓插槽：就是 在 Vue 中， 子组件定义了 `<slot></slot>` ， 它就相当于在父组件占据了位置，你可以往里面插入任何数据，可以定义多个slot。

       slot 又分为： 具名slot 默认slot 作用域slot

    10. 全局事件总线

    11. `$root`: vue状态管理使用 vuex, 如果项目不大，逻辑不多，name 我们没必要用 vuex 给项目增加难度，只需要用 `$root`设置 vue实例的 data就行了。

        ```vue
        created(){
        console.log(this.$root.loading) //获取loading的值
        }
        ```

    [组件化掘金博客](https://juejin.cn/post/6920645929187934216)

79. 前端跨域解决方案

    1、 通过 jsonp 跨域
    2、 document.domain + iframe 跨域
    3、 location.hash + iframe
    4、 window.name + iframe 跨域
    5、 postMessage 跨域

    6、 跨域资源共享（CORS）
    7、 nginx 代理跨域
    8、 nodejs 中间件代理跨域
    9、 WebSocket 协议跨域

    [博客园博客](https://www.cnblogs.com/ly1368489670/p/13924122.html)

80. 路由的原理是什么？如何实现？

    路由：通过点击不同的按钮来展示不同的页面或者组件的功能。

    原理：根据不同的路径地址，展示不同的页面、组件。

    实现：

    ​		hash: #a #b

    ​		history: /c  /d

    如何监视这两者发生的变化：

    hash: hashchange

    history: popstate

81. 路由钩子在实际开发中的应用场景：

    1. 清除当前组件中的定时器。

       当一个组件中有一个定时器时, 在路由进行切换的时候, 可使用`beforeRouteLeave`将定时器进行清除, 以免占用内存:

       ```js
       beforeRouteLeave (to, from, next) {
         window.clearInterval(this.timer) //清楚定时器
         next()
       }
       ```

       

    2. 当页面中有未关闭的窗口，或未保存的内容时，阻止页面跳转。

       如果页面内有重要的信息需要用户保存后才能进行跳转, 或者有弹出框的情况. 应该阻止用户跳转，结合 Vuex 状态管理（dialogVisibility 是否有保存）

       ```js
       beforeRouteLeave (to, from, next) {
         window.clearInterval(this.timer) //清楚定时器
         next()
       }
       ```

       

    3. 保存相关内容的 Vuex 中或 Session中。

       当用户需要关闭页面时, 可以将公用的信息保存到 session 或 Vuex中。

       ```js
       beforeRouteLeave (to, from, next) {
           localStorage.setItem(name, content); //保存到localStorage中
           next()
       }
       ```

       

82. Vue 原理灵魂四连问：

    **响应式原理**

    响应式：当数据发生变化，数据变，页面也变。

    数据代理：将 data 数据代理到实例对象上（方便将来操作data数据）
    遍历所有 data 数据，通过 `Object.defineProperty()` 方法
    将 data 中数据定义在实例对象上
    内部就是通过 get 定义属性读取的方法，实际读取的是原数据`_data`
    内部就是通过 set 定义属性设置的方法，实际设置的是原数据`_data`

    **数据劫持**
    遍历所有 data 数据，进行重新定义，将其定义成响应式。
    也是通过`Object.defineProperty()`方法，重新定义属性 get 和 set。
    此时会通过闭包的方式保存了一个 dep 对象，
    当我们读取数据时，就会触发 get 方法，除了返回值，还调用了`dep.depend()` 方法建立响应式联系。当我们修改属性的时候，就会触发 set 方法，除了会修改值，还会调用 `dep.nodify()` 方法，通知 dep 保存所有的 watcher 去更新用户界面，做到了响应式联系。

    **模板解析**
    它会将根节点里所有的子节点添加到文档碎片节点中，然后遍历所有子节点，判断如果是元素节点，就解析指令语法，如果是文本节点，就解析插值语法。除了事件指令以外的其他模板语法最终会`new Watcher`，watcher 中会保存更新用户界面的方法 cb，`new Watcher` 最终会读取表达式的值(data 数据的值)，这时候就会触发和数据劫持的 `get()` 方法，然后触发 `dep.depend` 方法，开始建立响应式联系，将解析后的文档碎片节点添加到根节点中生效。

    **编译模板**

    Vue 的模板编译在 $mount 之后，通过 compile 方法，经过 parse、optimize、generate 方法，最后生成 render function 来生成虚拟 DOM，虚拟 DOM 通过 diff 算法，来更新 DOM。

    具体功能如下：

    - parse 函数解析 template
    - optimize 函数优化静态内容
    - generate 函数创建 render 函数字符串

    > 什么是 watcher？
    >
    > watcher 原理是先把自己设置到全局唯一的指定位置（windonw.target），然后读取数据。因为读取了数据，所以会触发这个数据的 getter。接着，在 getter 中就会从全局唯一的那个位置读取真正读取数据的 watcher，并把这个 watcher 收集到 Dep（收集数据函数，主要是对数据的收集依赖/删除依赖/向依赖发送消息）中去。通过这样的方式，watcher 可以主动去订阅任意一个数据的变化。
    >
    > 
    >
    > 什么是 dep：
    >
    > 每一个 data 数据都有自己的 dep，目的就是为了在 watcher 中找到更新用户界面的方法 cb。
    >
    > 
    >
    >  dep.depend() 方法：用来创建响应式联系，响应式联系就是 dep 中保存 watcher，watcher 中也会保存 dep。
    >
    > 
    >
    > dep.notify() 方法：就是通知 watcher 去调用 cb() 方法更新用户界面。

83. Vue 更新数据的流程：

    我们更新 data 数据的时候，首先会触发数据代理的 set 方法，再触发数据劫持的 set 方法，这样就会更新数据，然后通过 `dep.notify()` 方法去通知 dep 保存所有 watcher 去更新用户界面，这就是更新数据的流程。

84. (天禹)数据代理：通过一个对象代理对另一个对象中属性的操作(读/写)。

    1. Vue 中的数据代理：
       - 通过 vm 对象来代理 data 对象中属性的操作(读/写)。
    2. Vue 中数据代理的好处：
       - 更加方便的操作 data 中的数据。
    3. 基本原理：
       - 通过 Object.defineProperty() 把 data 对象中所有属性添加到 vm 上。
       - 为每一个添加到 vm 上的属性，都指定一个 getter/setter。
       - 在 getter/setter 内部去操作(读/写) data 中对应的属性。

85. 封装代码的核心思想：

    1. 保留重复出现的部分。
    2. 通过外部传入不断变化的部分。

86. 封装函数：

    1. 保留重复出现的 js 代码。
    2. 通过形参传入动态变化是数据。
    3. 谁调用，谁传入。

87. 封装组件：

    1. 保留重复出现的代码片段(html + css + 部分 js)。
    2. 通过标签属性传入动态变化的数据(props)。
    3. 谁使用，谁传入。

88. 这三个地方的东西会放在差值语法`{{}}`中：

    1. data
    2. props
    3. computed

89. 所有指令相关的 this 指向的是 window，如：自定义指令。

90. vue-CLI 中 CLI指：Command Line Interface 命令行接口工具。

91. 如果修改数据中的一个属性值，页面会重新渲染，说明该属性时响应式属性。

    响应式属性产生的时间点：

    - 数据劫持(数据劫持就是在创建响应式属性)。
    - 属性值更新的时候(由于更新响应式属性会触发set方法，内部会对新的属性值进行深度数据劫持)。

92. 父给子传最好的方式用：props。
    子给父传用：自定义事件。
    全局时间总线：可以实现任意组件间的通信。但需要有一个东西做傀儡，这个傀儡最好是放在 main.js 中的 beforeCreate 钩子函数中。`Vue.prtotype.$bus = this`。这个 this 就是当前的 vm。

93. 消息订阅与发布 pubsub 也能实现任意组件间通信。
    哪个组件需要数据，哪个组件就先订阅。然后接收订阅的组件，返回数据。

94. 消息订阅与发布 js 原生没有，需要借助第三方库，关于 pubsub 相关的库特别多，推荐使用：pubsub-js。这个库很强大，你在 react 和 angular 中都可以用这个库。

95. 具名插槽写法：
    1. 用在普通 html 标签上 slot="插槽名"。
    2. 用在 template 上 v-slot:插槽名。这个插槽名不用引号，这是一种新的写法。

96. 加问号可以设置 params 参数可传可不传。

97. nextTick 使用场景：

    1. 点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。

       ```js
       showsou(){
         this.showit = true //修改 v-show
         document.getElementById("keywords").focus()  //在第一个 tick 里，获取不到输入框，自然也获取不到焦点
       }
       ```

       修改为：

       ```js
       showsou(){
         this.showit = true
         this.$nextTick(function () {
           // DOM 更新了
           document.getElementById("keywords").focus()
         })
       }
       ```

       

98. 

























































































































































































































































































































































































































