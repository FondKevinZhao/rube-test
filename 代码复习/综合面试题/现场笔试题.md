### 沛华给的学生的笔试题

1. css3 新增的伪类元素有哪些？

   - :before
   - :after
   - :first-child
   - :first-of-type
   - :last-child
   - :nth-of-type

2. 伪类选择器有哪些？link、visited、hover、active

3. 单行文本溢出以省略号表示：

   ```js
   width：多少px自己决定;
   white-space: nowrap;
   overflow: hidden;
   text-overflow: ellipsis;
   注：ellipsis : 　当对象内文本溢出时显示省略标记
   助记：WTO
   ```

   

4. 多行文本溢出以省略号表示：

   ```js
   overflow: hidden;
   text-overflow: ellipsis;
   display: -webkit-box;
   -webkit-line-clamp: 2;    // 最大行数
   -webkit-box-orient: vertical;
   ```

   

5. 移动端适配方案 `flexible.js` 的实现原理大概是怎样的？

   作用：它就是一个终端设备适配的解决方案。也就是说它可以让你在不同的终端设备中实现页面适配。

   使用：`flexible.js` 的用法非常的简单，在页面的`<head></head>`中引入 `flexible_css.js,flexible.js`文件。

   [博客链接](https://blog.csdn.net/qq_20757489/article/details/102380866?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162754831916780274199204%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162754831916780274199204&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-102380866.first_rank_v2_pc_rank_v29&utm_term=%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88+%60flexible.js%60+%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%A4%A7%E6%A6%82%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F&spm=1018.2226.3001.4187)

6. 遍历数组的方式有几种？哪种方式能中途停止？

   map、filter、forEach、some(能中途停止)、every、reduce

   [博客链接](https://blog.csdn.net/weixin_44757417/article/details/108895443?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162754855116780261934189%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162754855116780261934189&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-108895443.first_rank_v2_pc_rank_v29&utm_term=%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%83%BD%E4%B8%AD%E9%80%94%E5%81%9C%E6%AD%A2%EF%BC%9F&spm=1018.2226.3001.4187)

   [博客链接](https://blog.csdn.net/qq_40738077/article/details/117332884)

7. js 如何判断一个变量是否为数组？

   1. instanceof
   2. 数组方法：`isArray()`
   3. 原型`prototype + toString + call()`
   4. 原型`prototype + isPrototypeOf()`
   5. 构造函数 constructor

   [博客链接](https://www.cnblogs.com/zhizhic/p/9988947.html)

8. js 把Object的实例化对象A、B、C合并，赋值给对象C。

   let c = Object.assign(A, B, C)
   
9. ```js
   const Greeters = [];
   for (var i = 0; i < 10; i++) {
     Greeters.push(function() {
       return console.log(i)
     })
   }
   Greeters[0]() // 10
   Greeters[1]() // 10
   Greeters[2]() // 10
   // 注意：在for循环中它用的是 var 关键字，所以得到的结果是一样的。
   ```

   ```js
   const Greeters = [];
   for (let i = 0; i < 10; i++) {
     Greeters.push(function() {
       return console.log(i)
     })
   }
   Greeters[0]() // 0
   Greeters[1]() // 1
   Greeters[2]() // 2
   // 这里用的是 let 关键字
   ```

   

10. ```js
    var name = 'world!';
    (function() {
      if(typeof name === 'undefined') {
        var name = 'Jack';
        console.log("Goodbye" + name);
      } else {
        console.log('Hello' + name);
      }
    })() // GoodbyeJack
    
    // 注意：console.log(typeof name === 'undefined'); 为 true。意思就是说有没有 var name = 'world!'; 结果都是 GoodbyeJack。
    ```

11. ```js
    const num = {
      a: 10,
      add() {
        return this.a +2
      },
      reduce: () => this.a - 2
    };
    console.log(num.add()); // 12
    console.log(num.reduce()); // NaN
    ```

12. 谈谈小程序的双向绑定和Vue的异同？(小程序里面的双向绑定和vue中的双向绑定有什么区别？)

    **小程序的数据双向绑定：**

    - 首先通过 bindinput 绑定文本框的输入事件。
    - 在 data 中声明一个变量 content ，将其动态绑定成文本框的 value 值。
    - 在 bindinput 事件中通过事件参数 e.detail.value 可以获取到文本框中最新的 value 值。
    - 通过 this.setData 将文本框最新的 value 值 赋值给 动态绑定的value值 content 即可实现数据的双向绑定。

    **vue 的数据双向绑定：**

    - 首先为文本框绑定 @input 监听文本框的输入事件。
    - 为文本框动态绑定 value 属性，其值是在 data 中定义的变量。
    - 在 @input绑定的事件中 通过事件参数 event.target.value 可以获取到 input 框中最新的value值。
    - 将其重新获取到的 value 赋值给 value 值动态绑定的那个变量。

    **区别：**

    - 大体上区别不大，绑定事件不同，以及获取value值的具体方式不同，以及在小程序中设置data中的数据，需要调用 this.setData方法进行设置。

13. uniApp开发中如何获取上一个页面传递的数据？(uniapp中获取上一页内容)

    ```js
    let pages = getCurrentPages();
    let page = pages[pages.length - 2];
    page.$vm.refreshflag = true;(此参数为上一页中的参数)
    ```

    

14. 写出以下的输出结果：

    ```js
    console.log('1' + 2 + 3); // "123"
    console.log('' == false); // true
    console.log(0 == false); // true
    console.log(undefined == false); // false
    console.log(1 + 2 + '3'); // "33" // 引起注意
    console.log('0' == false); // true
    onsole.log('0' === false); // false
    console.log('123' == false); // false
    console.log(-1 == false); // false
    onsole.log(-1 == true); // false
    console.log(!!undefined == false); // true
    console.log(typeof a); // undefined
    ```

    

15. ```js
    function count() {
      var arr = [];
      for (var i = 1; i <= 3; i++) {
        arr.push(function () {
          return i * i
        })
      }
      return arr;
    }
    
    var results = count();
    var f1 = results[0];
    var f2 = results[1];
    var f3 = results[2];
    
    console.log(f1()); // 16
    console.log(f2()); // 16
    console.log(f3()); // 16
    // 原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。（即，返回函数是在循环函数结束后才开始执行）
    
    // 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
    ```

16. 写出排序结果：

    ```js
    var a = ['Google','Apple','Microsoft'].sort();
    var b = ['Google','apple','Microsoft'].sort();
    var c = ['Google','zpple','Microsoft'].sort();
    var d = [10, 20, 1, 2].sort();
    
    console.log(a); // [ 'Apple', 'Google', 'Microsoft' ]
    console.log(b); // [ 'Google', 'Microsoft', 'apple' ]
    console.log(c); // [ 'Google', 'Microsoft', 'zpple' ]
    console.log(d); // [ 1, 10, 2, 20 ]
    ```

    

17. 请结合你对 vue 生命周期的理解分别写出 this.message 与 this.$el 的打印结果：

    ```js
    let vm = new Vue({
      el: "app",
      data: {
        message: 1
      },
      template:'<div id="app"><p>{{message}}</p></div>',
      created() {
        console.log('调用了created'); // 第二步：'调用了created'
        console.log(this.message);  // 1
        console.log(this.$el); // undefined
      },
      beforeMount() {
        console.log('调用了beforeMount'); // 第三步 '调用了beforeMount'
        console.log(this.message);  // 1
        console.log(this.$el); // <div></div></div>
      },
      beforeCreate() {
        console.log('调用了beforeCreate'); // 第一步： '调用了beforeCreate'
        console.log(this.message);  // undefined
        console.log(this.$el); // undefined
      },
      mounted() {
        console.log('调用了mounted'); // 第四步： '调用了mounted'
        console.log(this.message);  // 1
        console.log(this.$el); // <div id="app"><p>{{message}}</p></div>
      },
    })
    vm.message = 2;
    ```

    

18. 什么时候输出 1：

    ```js
    setTimeout(function() {
      console.log(1);
    },2000)
    
    var time = Date.now();
    while(Date.now() - time < 5000){};
    // 5秒以后输出1。定时器里面的回调是异步的，等同步的while循环执行完之后才会执行。
    ```

    

19. ```js
    let a = {
      n:1
    };
    
    let b = a;
    
    a.x = a = {
      n:2
    };
    
    console.log(a.x); // undefined
    console.log(b.x); // {n: 2}
    ```

    

20. JS 合并两个数组的方法：

    ```js
    var a = [1, 2, 3];
    var b = [4, 5, 6];
    // 1. concat
    var c = a.concat(b); // c = [1, 2, 3, 4, 5, 6];
    
    // 2. for 循环
    for (var i in b) {
        a.push(b[i]);
    }
    // 3. apply
    a.push.apply(a,[4, 5, 6]);
    
    // 4. 扩展运算符
    var c = [...a, ...b]
    console.log(c); // c = [1, 2, 3, 4, 5, 6];
    ```

    

21. ```js
    (function executionSequence() {
      setTimeout(function() {
        console.log(1);
      },0)
      new Promise(function(resolve,reject){
        console.log(2);
        resolve()
        console.log(3)
      }).then(function() {
        console.log(4)
      })
      console.log(5)
    })() // 2 3 5 4 1
    ```

22. js DOM 操作方法：

    - write()：这个方法可以把任意字符串插入到文档中。
    - createElement()：创建一个元素节点。
    - appendChild()：将新节点追加到子节点列表的末尾。
    - createTextNode()：创建一个文本节点。
    - insetBefore()：将新节点插入在前面。
    - replaceChild()：将新节点替换旧节点。
    - cloneNode()：复制节点。
    - removeChild()：移除节点。
    - 查找节点：getElementById()，querySelector()等。

23. 1 rem、1 em、1 vh、1 px 各自代表的含义？

    **rem： **页面所有使用rem单位的长度都是相对于根元素<html>元素的font-size大小。即1rem等于根元素元素的font-size大小。

    **em：** 

    - 子元素字体大小的 em 相对于父元素字体的大小。
    - 元素的 width/height/padding/margin 用 em 的话是相对于该元素的 font-size。

    **vh、vw：**全称是 Viewport Width 和 Viewport Height，视口的宽度和高度，1vh相当于 视口高度的 1%。

    **px：**px像素（Pixel），相对长度单位。像素px是相对于显示器屏幕分辨率而言的。

    一般电脑的分辨率有 {1920*1080} 等不同的分辨率。

    1920*1080 前者是屏幕宽度总共有 1920 个像素,后者则是高度为 1080 个像素。

24. 如何中断Ajax请求？

    有两种方式：

    1. 设置超时时间让Ajax自动断开。
    2. 手动去停止Ajax请求，核心是调用 XMLHttpRequest 对象上的 abort 方法。

    ```ls
    xmlHttp.open("POST","Url",true);
     xmlHttp.onreadystatechange=function(){
     ...//得到响应之后的操作
     }
     xmlHttp.send();
     //设置3秒钟后检查xmlHttp对象所发送的数据是否得到响应.
     setTimeout("CheckRequest()","3000");
     function CheckRequest(){
     //为4时代表请求完成了
     if(xmlHttp.readyState!=4){
     alert('数据响应超时');
     //关闭请求
     xmlHttp.close();
     }
     }<br>//根据响应状态的改变关闭
    ```

    **切记：**不可用 abort 方法来作为终止对服务器的请求操作，只有当做在前端页面立刻停止执行 ajax 成功后的方法，因为你执行 abort 方法后，ajax 很可能已经对服务端发送了请求，只是还未返回回馈信息而已。

25. Vuex 中的 action 和 mutation 的区别：

    - 流程顺序：视图触发 Action，Action再触发 mutation。

    - 角色定位：

      Action：业务代码、异步请求。

      Mutation：专注于修改 State，理论上是修改 State 的唯一途径。

    - 限制：

      Mutation：必须同步执行。(Mutation中采取异步函数仍然是有效的，可以实现对state 状态的更改，但是不推荐)

      Action：可以异步，但不能直接操作 State。

26. 小程序, uni-app 生命周期： 

       1. onLoad：首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。
       2. onShow：加载完成后、后台切到前台或重新进入页面时触发。
       3. onReady：页面首次渲染完成时触发。
       4. onHide：从前台切到后台或进入其他页面触发。
       5. onUnload：页面卸载时触发。
       6. onPullDownRefresh：监听用户下拉动作。
       7. onReachBottom：页面上拉触底事件的处理函数。
       8. onShareAppMessage：用户点击右上角转发。

27. 为什么要用闭包？

       闭包是指有权访问另一个函数作用域中变量的函数,创建闭包的最常见的方式就是在一个函数内创建另一个函数,通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域,将函数内部的变量和方法传递到外部。

28. js 实现数组的随机排序。

       方法一：通过数组中的sort方法实现，return一个Math.random()-0.5

       ```js
       var arr = [1,2,3,4,5,6,7,8,9,10];
       arr.sort(function(){
           return Math.random() - 0.5;
       })
       console.log(arr);
       ```

       

       方法二：遍历当前数组，并创建一个暂存容器，每次遍历时，出现一个随机索引，使用随机索引，获取数组中一个随机的值，取出到暂存容器，然后根据当前循环次数的索引，获取数组中的值，放入原来取出的地方，最后把暂存容器的值，赋值给当前循环次数的索引的值，实现随机排序；（即三个容器间的交互）

       ```js
       var arr = [1,2,3,4,5,6,7,8,9,10];
       function randSort1(arr){
         for(var i = 0,len = arr.length;i < len; i++ ){
               var rand = parseInt(Math.random()*len);
               var temp = arr[rand];
               arr[rand] = arr[i];
               arr[i] = temp; 
          }
          return arr;
       } 
       console.log(randSort1(arr));
       ```

       

29. 介绍一下 Web Storage 的概念和用法。

       Web Storage 包含如下两种机制：

       - sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。
       - localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。

       这两种机制是通过 Window.sessionStorage 和 Window.localStorage 属性使用（更确切的说，在支持的浏览器中 Window 对象实现了 WindowLocalStorage 和 WindowSessionStorage 对象并挂在其 localStorage 和 sessionStorage 属性下）—— 调用其中任一对象会创建 Storage 对象，通过 Storage 对象，可以设置、获取和移除数据项。对于每个源（origin）sessionStorage 和 localStorage 使用不同的 Storage 对象——独立运行和控制。

       

30. 介绍一下HTTP缓存控制

       HTTP 缓存请求响应头：

       - Cache-Control：请求/响应头，缓存控制字段，可以说是控制http缓存的最高指令，要不要缓存也是它说了算。
       - Expires：响应头，代表资源过期时间，由服务器返回提供，GMT格式日期，是http1.0的属性，在与max-age(http1.1)共存的情况下，优先级要低。
       - Last-Modified：响应头，资源最新修改时间，由服务器告诉浏览器。
       - Etag：响应头，资源标识，由服务器告诉浏览器。
       - if-None-Match：请求头，缓存资源标识，由浏览器告诉服务器(其实就是上次服务器给的Etag)，和Etag是一对，它两会进行对比。

       HTTP 缓存方案：

       - hash 缓存：通过**不缓存html**，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。
       - CDN缓存(作为了解)
       - 强缓存：不发起http请求，直接使用本地缓存，比如浏览器地址栏回车，使用浏览器的刷新按钮，在Expires或max-age生效的情况下，触发的都是强缓存。
       - 协商性缓存(弱缓存)：在使用本地缓存前，先与服务器协商，核对缓存文件是否为最新。比如设置了cache-control=no-cache，不管你做任何操作，都会发起请求，这一类就是协商性缓存了。

31. ```js
       setTimeout(function(){
         console.log('定时器开始啦');
       });
       new Promise (function(resolve) {
         console.log('马上执行 for 循环');
         for(var i = 0; i < 10000; i++) {
           i == 99 && resolve();
         }
       }).then(function() {
         console.log('执行 then 函数');
       });
       console.log('代码执行结束');
       // 1. '马上执行 for 循环'
       // 2. '代码执行结束'
       // 3. '执行 then 函数'
       // 4. '定时器开始啦'
    ```

       

32. ```js
       var name = "The Window";
       var object = {
         name: "My Object",
         getNameFunc: function () {
           return function () {
             return this.name
           }
         }
       }
       console.log(object.getNameFunc()()); // undefined
    ```

       

33. ```js
       var name = "The Window";
       var object = {
         name: "My Object",
         getNameFunc: function () {
           var that = this;
           return function () {
             return that.name
           }
         }
       }
       console.log(object.getNameFunc()()); // My Object
    ```

       

34. 前端路由和后端路由的区别？

       - 什么是路由？

       路由是根据不同的 URL 展示不同的内容和页面。

       - 什么是前端路由？

         **特点：**不向后台发送请求，不刷新页面，前后端分离。

         前端路由即响应页面内容的任务是由前端来做的，根据不同的url更新页面的内容，随着SPA（单页面应用）的普遍使用，前后端开发分离，项目中基本都使用前端路由，通过路由实现页面的变化。例如，通过vue开发的SPA中，切换路由，并不刷新页面，而是根据路由在虚拟DOM中加载所需要的数据，实现页面内容的改变。

       - 什么是后端路由？

         **特点：**向服务器发送请求，会刷新页面，前后端分离。

         在浏览器的地址栏中切换不同的url时，每次都向后台服务器发出请求，服务器根据不同的响应不同的数据，浏览器接收到数据后再进行渲染，所以后端路由会刷新页面，如果网速慢的话，就会看到一个空白页面等待服务端返回数据，后台路由最大的问题就是不能前后端分离。 

       - 什么时候使用前端路由？

         在单页面应用中，大部分页面结构不变，只改变部分内容时使用。

       - 前端路由的优缺点：

         **优点：**

         - 用户体验好，页面初始化后，只需要根据路由变换页面内容，不需要再向服务器发送请求，内容变换速度快。
         - 可以在浏览器中输入指定想要访问的url。
         - 实现了前后端分离，方便开发。

         **缺点：**

         - 使用浏览器的前进、后退键的时候会重新发送请求，没有合理的利用缓存。
         - 单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动的位置。

35. node.js 中如何读写文件？

    nodejs 中所有与文件相关的操作都在fs模块中，而读写操作又是我们会经常用到的操作，nodejs的fs模块针对读操作为我们提供了readFile，read, createReadStream 三个方法，针对写操作为我们提供了writeFile，write， createWriteStream 三个方法。

    [博客地址](https://www.cnblogs.com/pp-cat/p/6504655.html)
    
36. Linux 中常用的命令？(沛华博客)

    Linux是一套开源免费的操作系统，与系统的交互通常用命令来实现，常用的命令有：

    - `ls` 查看当前文件夹下的文件（list单词的缩写）， `ls -al ` or `ls -a -l`查看隐藏文件并竖向排列
    - `cd` 进入某一个文件夹（change directory）的缩写，`cd ..`回到上一级。`tab`键代码自动补全
    - `clear` 清屏
    - `mkdir` 创建文件夹
    - `touch test.html` 创建一个文件
    - `rm test.html` 删除一个文件
    - `rm -r dir` 删除文件夹
    - `mv 原文件或文件夹 目标文件或文件夹` 移动文件
    - `cat test.html` 查看文件内容
    - `ctrl+c` 取消命令

37. 使用 CSS 实现一个三角形。

    ```html
    <!DOCTYPE html>
    <html lang="en">
        <head>
            <meta name="keywords" content="zidingyi">
            <meta name="description" content="zidingyi">
            <meta>
            <title>triangle</title>
            <style>
                div {
                    height: 0;
                    width: 0;
                    border: 100px solid transparent;
                    border-bottom: 100px solid red;
                }
            </style>
        </head>
        <body>
            <div></div>
        </body>
    </html>
    ```

    

38. 若干根粗细不均匀的绳子，每根烧完均需要1小时，怎样烧能计时45分钟?

    30 分钟：把一根绳子从两头同时烧,就能得到30分钟了。
    45 分钟：方法类似。其中一根绳子从两头烧得到30分钟，另外一根绳子从中折一下两头一起烧，两段时间加起来就可以了。

39. 假如每3个空啤酒瓶可以换一瓶啤酒，某人买了 10 瓶啤酒，那么他最多可以喝到多少瓶？

    喝完10瓶后用9个空瓶换来3瓶啤酒(喝完后有4个空瓶） 喝完这三瓶又可以换到1瓶啤酒（喝完后有2个空瓶）
    这时他有2个空酒瓶，如果他能向老板先借一个空酒瓶，就凑够了3个空瓶可以换到一瓶啤酒，把这瓶喝完后将空瓶还给老板就可以了。
    所以他最多可以喝 10+3+1+1 = 15 瓶。

40. 小程序组件之间数据传递：[博客地址](https://segmentfault.com/a/1190000014474289)

41. 小程序页面跳转和参数传递。

    跳转的三种方式：

    1. wx.navigateTo()：保留当前页面，跳转到应用内的某个页面，使用 `wx.navigateBack`可以返回到原页面。
    2. wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。
    3. 使用组件`navigator>`.

    wx.navigateTo() 和 wx.redirectTo() 的区别：

    - wx.navigateTo() 是保留当前页面，跳转到某个页面，跳转页面后可以返回上一页。
    - wx.redirectTo() 是关闭当前页面，跳转到某个页面，跳转页面后不能返回上一页。

    [博客地址](https://blog.csdn.net/zmd9999/article/details/79970083)

42. 输出结果：

    ```js
    emp = new Array(5);
    emp[1] = 1;
    emp[2] = 2;
    document.write(emp.length); // 5
    ```

    

43. 能够返回键盘上的按键对应字符的事件是：onkeypress事件。

44. 关于 document 对象的属性错误的是(B)

    A. body 是它的属性

    B. close 是它的属性(这个不属于，可以通过`console.dir(document)`检查)

    C. title 是它的属性

    D. bgColor 是它的属性

45. `<a href="javascript.window.close()">退出</a>` 用于关闭浏览器窗口。

46. 请输出结果：

    ```js
    var a = 1;
    if (true) {
      console.log(a); // 报错，因为let不会变量提升。
      let a = 2;
    }
    ```

    

47. ```js
    var a = {n:1};
    var b = a;
    
    a.x = a = {n:2};
    console.log(a.n,b.n); // 2 1
    console.log(a.x,b.x); // undefine {n:2}
    ```

48. 谈谈你对 HTTP 协议的理解：(来自http课件)

    协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。

    HTTP（hypertext transport protocol）协议也叫超文本传输协议，是一种基于TCP/IP的应用层通信协议，这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。

    客户端与服务端通信时传输的内容我们称之为报文。

    HTTP就是一个通信规则，这个规则规定了客户端发送给服务器的报文格式，也规定了服务器发送给客户端的报文格式。实际我们要学习的就是这两种报文。客户端发送给服务器的称为“请求报文”，服务器发送给客户端的称为“响应报文”。

49. 项目中如何修改 UI 框架的样式？

    1. 行内修改样式：通过在行内设置 style 修改，用于局部组件块。

    2. scoped 问题：可以去掉 scoped。

    3. deep 样式穿透方法：在不去掉 scoped 的情况下，我们可以用 /deep/ 来更改样式。

    4. 使用 >>>：在不使用 less / sass 的情况下，推荐使用 >>>。

       [博客地址](https://blog.csdn.net/weixin_54167313/article/details/117786675)

50. 找出字符串中第一个只出现一次的字母

    ```js
    var str = 'eerratrefffp'
    function fun(str){
        var arr = [],arr1 = []
        arr = str.split('')
        arr.forEach(function(item,index){
            var num  = str.split(item).length - 1
            if(num == 1){
                arr1.push(item)
            }
        })
        if(!arr1.length == 0){
            console.log(arr1[0])
        }else{
            console.log('没有符合条件的值')
        }
    }
    fun(str) // a
    ```

    [博客地址](https://blog.csdn.net/weixin_42203283/article/details/104895133)

51. 输出结果：

    ```js
    // 1
    var strA = "hi there";
    var strB = strA;
    strB = "bye there";
    console.log(strA);
    console.log(strB);
    ```

    <details>   
        <summary>折叠代码块1</summary>  
    	console.log(strA); // hi there
    	console.log(strB); // bye there
    </details>

    ```js
    // 2
    var objA = {prop1: 42};
    var objB = objA;
    objB = {};
    console.log(objA); 
    ```

    <details>   
        <summary>折叠代码块2</summary>  
    	// {prop1: 42}
    </details>

    ```js
    // 3
    var arrA = [0, 1, 2, 3, 4, 5];
    var arrB = arrA;
    arrB[0] = 42; // 同一个地址值
    console.log(arrA); 
    ```

    <details>   
        <summary>折叠代码块3</summary>  
    	// [42, 1, 2, 3, 4, 5]
    </details>

    ```js
    // 4
    var employeeId = 'abc123';
    function foo() {
      employeeId = '123abc';
      return;
    }
    foo();
    console.log(employeeId); 
    ```

    <details>   
        <summary>折叠代码块4</summary>  
    	// '123abc'
    </details>

    ```js
    // 5
    function foo() {
      employeeId();
      var product = 'Car';
      return;
      function employeeId() {
        console.log(product);
      }
    }
    foo(); 
    ```

    <details>   
        <summary>折叠代码块5</summary>  
    	// undefined
    </details>

    ```js
    // 6
    var obj = {
      message: "Hello",
      innerMessage: !(function () {
        console.log(this.message)
      })()
    };
    console.log(obj.innerMessage);
    ```

    <details>   
        <summary>折叠代码块6</summary>  
    	// undefined true
    </details>

    ```js
    // 7
    function myFunc() {
      console.log(this.message);
    }
    myFunc.message = "Hi John";
    console.log(myFunc());
    ```

    <details>   
        <summary>折叠代码块7</summary>  
    	// undefined undefined
    </details>

    ```js
    // 8
    function myFunc(param1,param2) {
      console.log(myFunc.length); 
    }
    console.log(myFunc()); // undefined 函数没有return
    console.log(myFunc("a","b")); // undefined 函数没有return
    console.log(myFunc("a","b","c","d")); // undefined 函数没有return
    ```

    <details>
        <summary>折叠代码块8</summary>
        // 三个答案相同：undefined 函数没有return
    </details>

    ```js
    // 9
    (function() {
      var greet = "Hello World";
      var toGreet = [].filter.call(greet, function(element, index) {
        return index > 5;
      });
      console.log(toGreet);
    })();
    ```

    <details>
        <summary>折叠代码块9</summary>
        // [ 'W', 'o', 'r', 'l', 'd' ]
    </details>

    ```js
    // 10
    function getDataFromServer(apiUrl) {
      var name = "John";
      return {
        then: function (fn) {
          fn(name);
        }
      }
    }
    
    getDataFromServer('www.google.com').then(function(name){
      console.log(name);
    })
    ```

    <details>
        <summary>折叠代码块10</summary>
        // "John"
    </details>

    ```js
    // 11
    function mul (x) {
      return function (y) {
        return [x*y, function (z) {
          return x*y + z;
        }];
      }
    }
    console.log(mul(2)(3)[0]);
    console.log(mul(2)(3)[1](4));
    ```

    <details>
        <summary>折叠代码块11</summary>
        // 6 10
    </details>

    ```js
    // 12
    var a = 10;
    a.pro = 10;
    console.log(a.pro); 
    console.log(a.pro+a);
    ```

    <details>
        <summary>折叠代码块12</summary>
        console.log(a.pro); // undefined
    	console.log(a.pro+a) // NaN(相当有undefined+a=NaN)
    </details>

    ```js
    // 13
    var s = 'hello';
    s.pro = 'world';
    console.log(s.pro+s);
    ```

    <details>
        <summary>折叠代码块13</summary>
        // 'undefinedhello'
    </details>

52. 合并对象：合并 obj1, obj2, obj3，使用新变量obj4保存。

    ```js
    // ES6在Object新加的方法  assign() 
    // 作用：将多个对象{}  合并成一个独立对象。
    // 使用方式: Object.assign(合并的对象，传入合并中的对象....)
    var obj1 = {name: 'xiaoming', age: 8, weight: '60kg'};
    var obj2 = {account: 'admin', password: 'admin'}
    var obj3 = {remember: true};
    
    var obj4 = Object.assign(obj1, obj2, obj3);
    console.log(obj4);
    ```

    

53. 过滤对象中数据。

    ```js
    /**
    * [过滤对象]
    * @param  obj [过滤前数据]
    * @param  arr [过滤条件，要求为数组]
    */
    function filterObj(obj, arr) {
        if (typeof (obj) !== "object" || !Array.isArray(arr)) {
        	throw new Error("参数格式不正确")
        }
    const result = {}
    Object.keys(obj).filter((key) => arr.includes(key)).forEach((key) => {
    	result[key] = obj[key]
    	})
    	return result
    }
    
    /**
    使用
    **/
    
    let obj = {
      a: '1',
      b: '2',
      c: '3'
    }
    
    let newObj = filterObj(obj,["a", "b"]);
    onsole.log(newObj);
    // 返回结果 :
    newObj = {
      a: '1',
      b: '2'
    }
    ```

    

54. 怎么让 Chrome 支持小于 12px 的文字？

    ```js
    <style>
        p span {
          font-size: 10px;
          -webkit-transform: scale(0.8);
          display: block;
        }
    </style>
    <body>
      <p><span>haorooms博客测试10px</span></p>
    </body>
    ```

    

55. ```js
    const promise = new Promise ((resolve,reject) => {
      console.log(1);
      resolve();
      console.log(2)
    })
    promise.then(() => {
      console.log(3)
    })
    console.log(4); 
    // 1 2 4 3
    ```

56. vue 中，子组件里怎么改变父组件传给子组件的变量的值？

    [博客地址](https://www.cnblogs.com/doing-good/p/10862491.html)

57. 彻底搞懂`prototype`、`__proto__`、`constructor`

    [博客地址](https://blog.csdn.net/cc18868876837/article/details/81211729)

58. ```js
    function Foo() {
      var i = 0;
      return function() {
        console.log(i++);
      }
    }
    var f1 = Foo(), f2 = Foo();
    f1();
    f1();
    f2();
    ```

    <details>
        <summary>折叠代码块</summary>
        <pre>
    f1(); // 0
    f1(); // 1
    f2(); // 0
        </pre>
    </details>

59. ```js
    var a = "40";
    var b = 7;
    console.log(a%b);
    ```

    <details>
        <summary>折叠代码块</summary>
        <pre>
    // 5 (数字5)
        </pre>
    </details>

60. 如果同时有两个请求，怎么让他们分开发送(一个请求结束，另一个请求开始)

    [博客地址](https://blog.csdn.net/liushan633/article/details/84303500)

61. 全屏滚动的原理是什么?用到了css的那些属性?

    - 全屏滚动和轮播图类似，都是通过改变元素位置或者显示与隐藏来实现，配合JS的一些交互距离判断，实现类似原生滚动捕获的效果。
    - 关键CSS属性是父容器 overflow: hidden; 。
    - 实现全屏滚动还可以简单的通过插件来实现，比如fullpage，很多大公司的页面都是用这个实现的，比如小米一些产品的官网。

    

    



### 1215笔试题

###  

1. 有哪些方法可以遍历对象中的所有属性？这些方法有何区别？

   - Object.values() 返回属性值。

     **Object.values()**方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用`for...in`循环的顺序相同 ( 区别在于 `for-in` 循环枚举原型链中的属性 )。

   -  Object.keys() 

     **Object.keys()** 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 `for...in` 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。

   -  Object.entries()

     **Object.entries()**方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 `for...in` 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。

     `Object.entries()` 返回键值对数组，如 `[ [key1, value1], [key2, value2], ..., [keyN, valueN] ]`。

     [博客链接](https://www.cnblogs.com/mq0036/p/12108326.html)

2. for of 和 for in 的区别？

   - for of 无法遍历 不可迭代的对象。

     可迭代的对象包括：Array, Map, set, String, TypedArray, arguments等。

   - for of 遍历的是值，for in 遍历的是key。

3. ```js
   let log = console.log;
   let arr = [1, 2, 3, 4, 5];
   
   for (let i of arr) {
     log(i);
   }
   
   
   // 1 2 3 4 5 
   
   
   
   for (let i in arr) {
     log(i);
   }
   
   
   
   // 0 1 2 3 4
   ```

4. 以下布尔转换的结果是什么？

   ```js
   console.log(Boolean(0)); // false
   console.log(Boolean(1)); // true
   console.log(Boolean(NaN)); // false
   console.log(Boolean("  ")); // true
   console.log(Boolean("")); // false
   console.log(Boolean([])); // true
   console.log(Boolean({})); // true
   ```

   

5. 以下哪些情况会导致回流？哪些情况会导致重绘？

   **reflow(回流)**是指浏览器为了重新渲染部分或者全部的文档，重新计算文档中的元素的位置。

   回流可能导致整个DOM树的重新构造，是性能的一大杀手。

   以下操作会引起回流：

   1. 改变窗口大小
   2. font-size大小变化
   3. 增加或者溢出样式表
   4. 内容变化(input中输入文字)
   5. 激活CSS伪类(:hover)
   6. 操作class属性，新增或者减少
   7. js操作dom
   8. offset相关属性计算
   9. 设置style的值

   当`render tree`中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color、opacity等。则就叫称为**重绘(repaint)**。

6. 以下程序的执行结果是什么？

   ```js
   let f = () => {
         console.log(this);
       }
       let o = {
         f,
         g: {
           h: f
         }
       };
       o.f(); // window
       o.g.h(); // window
   ```

   

7. ```js
   let log = console.log;
       let timeId = 0;
       let handleReadyState = () => {
         if (document.readyState === 'complete') {
           window.clearTimeout(timeId);
           log('complete');
         }
       };
       let loop = () => {
         timeId = window.setTimeout(() => {
           handleReadyState();
           loop();// 递归调用loop
         }, 0);
       };
       loop();
   // 一直输出‘complete’死循环
   ```

8. div+css 布局较 table 布局有什么优点？

   1. 改版的时候更方便，只要改 css 文件。
   2. 页面加载速度更快、结构化清晰、页面显示简洁。
   3. 样式与结构相分离。
   4. 易于优化(SEO)搜索引擎更友好，排名更容易靠前。
   5. 实现一些复杂的布局更加容易。

9. js 延迟加载的几种方式？

   1. defer 属性：HTML 4.01 为 `<script>`标签定义了 `defer`属性。在`<script>` 元素中设置 `defer` 属性，等于告诉浏览器立即下载，但**延迟执行**。

      ```js
      <!DOCTYPE html>
      <html>
      <head>
          <script src="test1.js" defer="defer"></script>
          <script src="test2.js" defer="defer"></script>
      </head>
      <body>
      <!-- 这里放内容 -->
      </body>
      </html>  
      ```

      

   2. async 属性：HTML5 为 `<script>`标签定义了 `async`属性。与`defer`属性类似，都用于改变处理脚本的行为。同样，**只适用于外部脚本文件**。
      目的：不让页面等待脚本下载和执行，从而**异步加载页面其他内容**。

      异步脚本一定会在页面 load 事件前执行。不能保证脚本会按顺序执行。

      ```js
      <!DOCTYPE html>
      <html>
      <head>
          <script src="test1.js" async></script>
          <script src="test2.js" async></script>
      </head>
      <body>
      <!-- 这里放内容 -->
      </body>
      </html>
      ```

      

   3. 使用 jQuery 的 `getScript()`方法

      ```js
      $.getScript("outer.js",function(){//回调函数，成功获取文件后执行的函数  
            console.log("脚本加载完成")  
      });
      ```

      

   4. 使用`setTimeout`延迟方法。

   5. 让 JS 最后加载

      把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度。

10. js 哪些操作会造成内存泄露？如何避免？

    **内存泄露：**

    1. 意外的全局变量引起的内存泄露。

       ```js
       function leak(){
         leak="xxx";//leak成为一个全局变量，不会被回收
       }
       ```

       

    2. 闭包引起的内存泄露。

    3. 没有清理的 DOM 元素引用。

       ```js
       var elements={
           button: document.getElementById("button"),
           image: document.getElementById("image"),
           text: document.getElementById("text")
       };
       function doStuff(){
           image.src="http://some.url/image";
           button.click():
           console.log(text.innerHTML)
       }
       function removeButton(){
           document.body.removeChild(document.getElementById('button'))
       }
       ```

       

    4. 被遗忘的定时器或者回调。

       ```js
       var someResouce=getData();
       setInterval(function(){
           var node=document.getElementById('Node');
           if(node){
               node.innerHTML=JSON.stringify(someResouce)
           }
       },1000)
       ```

    

    **内存泄漏解决方法：**

    1. 减少不必要的全局变量，或者声明周期较长的对象，及时对无用的数据进行垃圾回收。
    2. 注意程序逻辑，避免“死循环”之类的。
    3. 避免创建过多的对象，原则：不用了的东西要及时归还。

11. 为什么利用多个域名来存储网站资源会更有效？

    1. CDN 缓存更方便。
    2. 突破浏览器并发限制。
    3. 节约 cookie 带宽。
    4. 节约主域名的连接数，优化页面响应速度。

12. 回调函数有什么缺点。

    1. 回调函数最大的缺点是会造成回调地狱(Callback hell)。

    ​    回调地狱的根本问题是：

    * 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身。

    * 嵌套函数一多，就很难处理错误。

    2. 不能使用 try catch 捕捉错误。
    3. 不能直接 return。

13. 前端如何进行性能优化？

    1. 减少 HTTP 请求。
    2. 减少页面的重绘和重排。
    3. 减少对 DOM 的操作。
    4. 用 JSON 格式来进行数据交换。
    5. 使用 CDN 加速(内容分发网络)：各大云服务提供商都有CDN服务，如：阿里云、腾讯云、百度云，七牛 等。
    6. 精简 CSS 和 JS 的文件。
    7. 压缩图片。
    8. 图片懒加载。

    [博客链接](https://zhuanlan.zhihu.com/p/256991609)

14. 防抖 debounce：防抖的原理是在事件触发一定毫秒之后，再执行。

    节流 Throttle 和防抖实现的效果类似，但是原理有一些些的不同。它保证回调在函数在一个时间段内只执行一次，通过计算时间差，如果已经执行过了，清除定时器，重新开始计时，否则就执行回调函数。

15. ```js
    console.log(2 * "2") // 4 (数字4)
    console.log([1,2] + [2,1]); // “1221”
    ```

16. "i'm a good man" 倒着打印出来(比如："hello world" -> "dlrow olleh")

    ```js
    var str = "i'm a good man";
    str = str + "";
    var arr = str.split("");
    // console.log(arr); //[ '1', '2', '3' ]
    for (var i = arr.length - 1; i >= 0; i--) {
      console.log(arr[i]);
    }
    ```

    

17. js 获取嵌套数组，嵌套对象的值

    ```js
    let obj = {'aa': {'xx':'cc', '0': 0, '1': '1', '-1': -1}}; 
    console.log(getObjChild(obj, 'aa.xx')) // "cc"
    //获取嵌套数组/对象中的值
    function getObjChild(obj, key, gap='.') {
      let tmp = {};
      let arr = key.split(gap); //将key拆成数组
    
      if (obj[arr[0]]) {
          tmp = obj[arr[0]];
          for (let i=1; i<arr.length; i++) { //逐层进入匹配查找
              let is_found = false;
              if (typeof tmp === 'object') {
                  for(let j in tmp) {
                      if (j === arr[i]) {
                          tmp = tmp[j];
                          is_found = true;
                          break;
                      }
                  }
              }
    
              if (!is_found) {
                  tmp = false;
                  console.log('未找到 '+ arr[i]);
                  break;
              }
          }
      } else {
          console.log('未找到 '+ arr[0]);
          tmp = false;
      }
    
      return tmp;
    }
    ```

    

18. 用尽可能简短的代码求得数组 arr = [3, 1, 4, 5, 2] 的最大值。

    ```js
    var arr = [3, 1, 4, 5, 20, 18]
    var max = arr.reduce(function(a , b){
      return b > a ? b : a;
    });
      
    console.log(max); // 20
    ```

    

19. 用原型如何实现下列代码：[1,2, 3, 4, 5].duplicator(); // [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]。要求不改变原数组，并返回新的值。

    ```js
    var arr = [1,2,3,4,5];
    Array.prototype.duplicator = function(){
        var len = this.length;
        for(var i=0;i<len;i++){
            this.push(this[i]);
        }
        console.log(this)
    }
    arr.duplicator(); // [1,2,3,4,5,1,2,3,4,5]
    console.log(arr); // [1,2,3,4,5,1,2,3,4,5]
    // 这个改变原数组了
    ```

    

20. 求两个正整数的最大公约数

    ```js
    lcm=function(m,n){//辗转相除法 求最大公约数
    	var u=+m,v=+n,t=v;
    	while(v!=0){
    		t=u%v;
    		u=v;
    		v=t;
    	}
    	return parseInt(u)
    }
    
    console.log(lcm(3, 10))
    ```

    扩展：欧几里得算法又称[辗转相除法](https://baike.baidu.com/item/辗转相除法/4625352)，是指用于计算两个[非负整数](https://baike.baidu.com/item/非负整数/2951833)a，b的[最大公约数](https://baike.baidu.com/item/最大公约数/869308)。

    假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：

    997 / 615 = 3 (余 152)

    615 / 152 = 4(余7)

    152 / 7 = 21(余5)

    7 / 5 = 1 (余2)

    5 / 2 = 2 (余1)

    2 / 1 = 2 (余0)

    至此，最大公约数为1

    以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。

21. JavaScript 中如何检测变量是一个 String 类型？请写出函数实现。

    ```js
    // 方法一：
    function isString(obj){
      return obj.constructor === String? true: false;
    }
    
    console.log(isString("5")) // true
    ```

    ```js
    // 方法二：
    function isString(obj){
      return typeof(obj) === "string"? true: false;
    }
    console.log(isString("5"))
    ```

    ```js
    // 方法三：
    function isString(obj){
      return Object.prototype.toString.call(obj) === "[object String]" ? true : false;
    }
    var isstring = isString('5');
    console.log(isstring);  // true
    ```

    

22. 请编写简要 js 代码，实现判断一个字符串中出现次数最多的字符，统计这个次数的需求。

    ```js
    // 用对象(推荐用法)
    var str = "zhaochucichuzuiduodezifu";
    var o = {};
    for (var i = 0, length = str.length; i < length; i++) {
    // var char = str[i];
    var char = str.charAt(i);
    if (o[char]) { //char就是对象o的一个属性，o[char]是属性值，o[char]控制出现的次数
    o[char]++; //次数加1
    } else {
    o[char] = 1; //若第一次出现，次数记为1
    }
    }
    console.log(o); //输出的是完整的对象，记录着每一个字符及其出现的次数
    //遍历对象，找到出现次数最多的字符和次数
    var max = 0;
    var maxChar = null;
    for (var key in o) {
    if (max < o[key]) {
    max = o[key]; //max始终储存次数最大的那个
    maxChar = key; //那么对应的字符就是当前的key
    }
    }
    console.log("最多的字符是" + maxChar); // 最多的字符是u
    console.log("出现的次数是" + max); // 出现的次数是5
    ```

    

23. $this 和 this 关键字在 jQuery 中有何不同？

    1. 表示对象不同：this表示的是javascript提供的当前对象，$(this)表示的是用jquery封装候的当前对象。
    2. 过程不同：this对象可以直接用this.style修改样式，$(this)可以使用jquery提供的方法访问样式。

24. $(document).ready() 方法和 window.onload 有什么区别？

    JQuery中 $(document).ready() 的作用类似于传统 JavaScript 中的 window.onload 方法，不过与window.onload 方法还是有区别的：

    1. 执行时间不同：
       - window.onload 必须等到页面内包括图片的所有元素和资源加载完毕后才能执行。
       - $(document).ready() 是 DOM 加载完毕后就执行，不必等到整个网页资源加载完毕。
       - 所以，使用 $(document).ready() 方法的执行速度比 window.onload 的方法要快。
    2. 编写个数不同：
       - $(document).ready()可以同时编写多个，并且都可以得到执行。
       - window.onload不能同时编写多个，如果有多个window.onload方法，只会其中执行一个。
    3. 简化写法：
       - window.onload没有简化写法。
       - $ (document).ready(function(){ })可以简写成`$(function(){方法体 });`又因为JQuery的默认参数是document，则还可以写成`$().ready(function{ })`。

25. 简单描述微信小程序的相关文件类型？

    微信小程序项目结构主要有四个文件类型，如下：

    1. .WXML：是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。(主要借鉴W3C，但是没有完全遵循W3C的规范)
    2. .WXSS：(WeiXin Style Sheets) 是一套样式语言，用于描述`WXML`的组件样式。
    3. .js：逻辑处理，网络请求。
    4. .json：小程序设置，如页面注册，页面标题及`tabBar`。

    app.json：必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的`window`背景色，配置导航条样式，配置默认标题。

    app.js：必须要有这个文件，没有也是会报错！但是这个文件创建一下就行，什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。

26. 你是怎么封装微信小程序的数据请求的？

    1. 将所有的接口放在统一的 JS 文件中并导出。
    2. 在 app.js 中创建封装请求数据的方法。
    3. 在子页面中调用封装的方法请求数据。

27. 小程序有哪些参数传值的方法？

    1. 给HTML元素添加 data-* 属性来传递我们需要的值，然后通过 e.currentTarget.dataset 或 onload 的param 参数获取。但 data- 名称不能有大写字母、不可以存放对象。
    2. 设置id 的方法标识来传值通过 e.currentTarget.id 获取设置的id的值,然后通过设置全局对象的方式来传递数值。
    3. 在 navigator 中添加参数传值。

28. 怎么解决小程序的异步请求问题？

    使用 promise 解决。

    [博客链接](https://www.cnblogs.com/dayin1/p/12179632.html)

29. js scroll 滚动连续多次触发事件只执行一次。

    ```js
    (function() {
        var finished = true;
        function loadData() {
            //xxxx
            finished = true;
        }
        dom.onscroll = function() {
            if(finished && this.scrollHeight - this.clientHeight == this.scrollTop) {
                finished = false;
                loadData();
            }
        }
    })();
    ```

    

30. 重写数组 map 方法：

    ```js
    Array.prototype.newMap = function(fn) {
      var newArr = [];
      for(var i = 0; i<this.length; i++){
        newArr.push(fn(this[i],i,this))
        }
      return newArr;
    }
    ```

    [博客链接](https://www.jb51.net/article/192126.htm)

31. 字符串反转。示例：输入 www.baidu.com 输出 moc.udiab.www

    方法一：reverse()，join()

    ```js
    var name = "www.baidu.com";
    var resultStr = name.split('').reverse().join(''); 
    console.log(resultStr);  // moc.udiab.www
    ```

    方法二：charAt()

    ```js
    var name = "www.baidu.com";
    var nameArr = name.split('');
    var resultStr = '';
    for (var i = nameArr.length-1; i >= 0; i--) {
        resultStr += name.charAt(i);
    }
    console.log(resultStr); // moc.udiab.www
    ```

    [MDN charAt方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charAt)

32. 输出的结果是：

    ```js
    let obj = {
      a: 222,
      fn: function () {
          console.log(this.a);
      }
    }
    obj.fn() 
    
    
    
    
    
    // 222
    ```

    ```js
    let obj = {
      a: 222,
      fn: function () {
        setTimeout(function(){
          console.log(this.a);
        })
      }
    }
    obj.fn() 
    
    
    
    
    // undefined
    // 定时器里面的this指向的是window
    ```

    

33. 简述 HTTPS 加密原理：

    [博客链接](https://blog.csdn.net/u011726005/article/details/87638488)

34. 简述 HTTP 2.0 新增的内容。

    1. 二进制分帧层。
    2. 请求与响应复用。
    3. 服务器推送。
    4. 标头压缩。

    [博客链接](https://www.jianshu.com/p/971f3db1688c)

35. 数组和列表有什么区别？什么时候应该使用Array，而不是ArrayList？

    1. 存储内容比较：

       Array 数组可以包含基本类型和对象类型，ArrayList 却只能包含对象类型。
       Array 数组在存放的时候一定是同种类型的元素。ArrayList 就不一定了 。

    2. 空间大小比较：

       Array 数组的空间大小是固定的,所以需要事前确定合适的空间大小。
       ArrayList 的空间是动态增长的,而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。

    3. 方法上的比较：ArrayList 方法上比 Array 更多样化，比如添加全部 addAll()、删除全部 removeAll()、返回迭代器 iterator() 等。


​       

​    

​    

