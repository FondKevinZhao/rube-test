### 沛华给的学生的笔试题

1. css3 新增的伪类元素有哪些？

   - :before
   - :after
   - :first-child
   - :first-of-type
   - :last-child
   - :nth-of-type

2. 伪类选择器有哪些？link、visited、hover、active

3. 单行文本溢出以省略号表示：

   ```js
   width：多少px自己决定;
   white-space: nowrap;
   overflow: hidden;
   text-overflow: ellipsis;
   注：ellipsis : 　当对象内文本溢出时显示省略标记
   助记：WTO
   ```

   

4. 多行文本溢出以省略号表示：

   ```js
   overflow: hidden;
   text-overflow: ellipsis;
   display: -webkit-box;
   -webkit-line-clamp: 2;    // 最大行数
   -webkit-box-orient: vertical;
   ```

   

5. 移动端适配方案 `flexible.js` 的实现原理大概是怎样的？

   作用：它就是一个终端设备适配的解决方案。也就是说它可以让你在不同的终端设备中实现页面适配。

   使用：`flexible.js` 的用法非常的简单，在页面的`<head></head>`中引入 `flexible_css.js,flexible.js`文件。

   [博客链接](https://blog.csdn.net/qq_20757489/article/details/102380866?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162754831916780274199204%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162754831916780274199204&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-102380866.first_rank_v2_pc_rank_v29&utm_term=%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88+%60flexible.js%60+%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%A4%A7%E6%A6%82%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F&spm=1018.2226.3001.4187)

6. 遍历数组的方式有几种？哪种方式能中途停止？

   map、filter、forEach、some(能中途停止)、every、reduce

   [博客链接](https://blog.csdn.net/weixin_44757417/article/details/108895443?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162754855116780261934189%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162754855116780261934189&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-108895443.first_rank_v2_pc_rank_v29&utm_term=%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%83%BD%E4%B8%AD%E9%80%94%E5%81%9C%E6%AD%A2%EF%BC%9F&spm=1018.2226.3001.4187)

   [博客链接](https://blog.csdn.net/qq_40738077/article/details/117332884)

7. js 如何判断一个变量是否为数组？

   1. instanceof
   2. 数组方法：`isArray()`
   3. 原型`prototype + toString + call()`
   4. 原型`prototype + isPrototypeOf()`
   5. 构造函数 constructor

   [博客链接](https://www.cnblogs.com/zhizhic/p/9988947.html)

8. js 把Object的实例化对象A、B、C合并，赋值给对象C。

   let c = Object.assign(A, B, C)
   
9. ```js
   const Greeters = [];
   for (var i = 0; i < 10; i++) {
     Greeters.push(function() {
       return console.log(i)
     })
   }
   Greeters[0]() // 10
   Greeters[1]() // 10
   Greeters[2]() // 10
   // 注意：在for循环中它用的是 var 关键字，所以得到的结果是一样的。
   ```

   ```js
   const Greeters = [];
   for (let i = 0; i < 10; i++) {
     Greeters.push(function() {
       return console.log(i)
     })
   }
   Greeters[0]() // 0
   Greeters[1]() // 1
   Greeters[2]() // 2
   // 这里用的是 let 关键字
   ```

   

10. ```js
    var name = 'world!';
    (function() {
      if(typeof name === 'undefined') {
        var name = 'Jack';
        console.log("Goodbye" + name);
      } else {
        console.log('Hello' + name);
      }
    })() // GoodbyeJack
    
    // 注意：console.log(typeof name === 'undefined'); 为 true。意思就是说有没有 var name = 'world!'; 结果都是 GoodbyeJack。
    ```

11. ```js
    const num = {
      a: 10,
      add() {
        return this.a +2
      },
      reduce: () => this.a - 2
    };
    console.log(num.add()); // 12
    console.log(num.reduce()); // NaN
    ```

12. 谈谈小程序的双向绑定和Vue的异同？(小程序里面的双向绑定和vue中的双向绑定有什么区别？)

    **小程序的数据双向绑定：**

    - 首先通过 bindinput 绑定文本框的输入事件。
    - 在 data 中声明一个变量 content ，将其动态绑定成文本框的 value 值。
    - 在 bindinput 事件中通过事件参数 e.detail.value 可以获取到文本框中最新的 value 值。
    - 通过 this.setData 将文本框最新的 value 值 赋值给 动态绑定的value值 content 即可实现数据的双向绑定。

    **vue 的数据双向绑定：**

    - 首先为文本框绑定 @input 监听文本框的输入事件。
    - 为文本框动态绑定 value 属性，其值是在 data 中定义的变量。
    - 在 @input绑定的事件中 通过事件参数 event.target.value 可以获取到 input 框中最新的value值。
    - 将其重新获取到的 value 赋值给 value 值动态绑定的那个变量。

    **区别：**

    - 大体上区别不大，绑定事件不同，以及获取value值的具体方式不同，以及在小程序中设置data中的数据，需要调用 this.setData方法进行设置。

13. uniApp开发中如何获取上一个页面传递的数据？(uniapp中获取上一页内容)

    ```js
    let pages = getCurrentPages();
    let page = pages[pages.length - 2];
    page.$vm.refreshflag = true;(此参数为上一页中的参数)
    ```

    

14. 写出以下的输出结果：

    ```js
    console.log('1' + 2 + 3); // "123"
    console.log('' == false); // true
    console.log(0 == false); // true
    console.log(undefined == false); // false
    console.log(1 + 2 + '3'); // "33" // 引起注意
    console.log('0' == false); // true
    onsole.log('0' === false); // false
    console.log('123' == false); // false
    console.log(-1 == false); // false
    onsole.log(-1 == true); // false
    console.log(!!undefined == false); // true
    ```

    

15. ```js
    function count() {
      var arr = [];
      for (var i = 1; i <= 3; i++) {
        arr.push(function () {
          return i * i
        })
      }
      return arr;
    }
    
    var results = count();
    var f1 = results[0];
    var f2 = results[1];
    var f3 = results[2];
    
    console.log(f1()); // 16
    console.log(f2()); // 16
    console.log(f3()); // 16
    // 原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。（即，返回函数是在循环函数结束后才开始执行）
    
    // 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
    ```

16. 写出排序结果：

    ```js
    var a = ['Google','Apple','Microsoft'].sort();
    var b = ['Google','apple','Microsoft'].sort();
    var c = ['Google','zpple','Microsoft'].sort();
    var d = [10, 20, 1, 2].sort();
    
    console.log(a); // [ 'Apple', 'Google', 'Microsoft' ]
    console.log(b); // [ 'Google', 'Microsoft', 'apple' ]
    console.log(c); // [ 'Google', 'Microsoft', 'zpple' ]
    console.log(d); // [ 1, 10, 2, 20 ]
    ```

    

17. 请结合你对 vue 生命周期的理解分别写出 this.message 与 this.$el 的打印结果：

    ```js
    let vm = new Vue({
      el: "app",
      data: {
        message: 1
      },
      template:'<div id="app"><p>{{message}}</p></div>',
      created() {
        console.log('调用了created'); // 第二步：'调用了created'
        console.log(this.message);  // 1
        console.log(this.$el); // undefined
      },
      beforeMount() {
        console.log('调用了beforeMount'); // 第三步 '调用了beforeMount'
        console.log(this.message);  // 1
        console.log(this.$el); // <div></div></div>
      },
      beforeCreate() {
        console.log('调用了beforeCreate'); // 第一步： '调用了beforeCreate'
        console.log(this.message);  // undefined
        console.log(this.$el); // undefined
      },
      mounted() {
        console.log('调用了mounted'); // 第四步： '调用了mounted'
        console.log(this.message);  // 1
        console.log(this.$el); // <div id="app"><p>{{message}}</p></div>
      },
    })
    vm.message = 2;
    ```

    

18. 什么时候输出 1：

    ```js
    setTimeout(function() {
      console.log(1);
    },2000)
    
    var time = Date.now();
    while(Date.now() - time < 5000){};
    // 5秒以后输出1。定时器里面的回调是异步的，等同步的while循环执行完之后才会执行。
    ```

    

19. ```js
    let a = {
      n:1
    };
    
    let b = a;
    
    a.x = a = {
      n:2
    };
    
    console.log(a.x); // undefined
    console.log(b.x); // {n: 2}
    ```

    

20. JS 合并两个数组的方法：

    ```js
    var a = [1, 2, 3];
    var b = [4, 5, 6];
    // 1. concat
    var c = a.concat(b); // c = [1, 2, 3, 4, 5, 6];
    
    // 2. for 循环
    for (var i in b) {
        a.push(b[i]);
    }
    // 3. apply
    a.push.apply(a,[4, 5, 6]);
    
    // 4. 扩展运算符
    var c = [...a, ...b]
    console.log(c); // c = [1, 2, 3, 4, 5, 6];
    ```

    

21. ```js
    (function executionSequence() {
      setTimeout(function() {
        console.log(1);
      },0)
      new Promise(function(resolve,reject){
        console.log(2);
        resolve()
        console.log(3)
      }).then(function() {
        console.log(4)
      })
      console.log(5)
    })() // 2 3 5 4 1
    ```

22. js DOM 操作方法：

    - write()：这个方法可以把任意字符串插入到文档中。
    - createElement()：创建一个元素节点。
    - appendChild()：将新节点追加到子节点列表的末尾。
    - createTextNode()：创建一个文本节点。
    - insetBefore()：将新节点插入在前面。
    - replaceChild()：将新节点替换旧节点。
    - cloneNode()：复制节点。
    - removeChild()：移除节点。
    - 查找节点：getElementById()，querySelector()等。

23. 1 rem、1 em、1 vh、1 px 各自代表的含义？

    **rem： **页面所有使用rem单位的长度都是相对于根元素<html>元素的font-size大小。即1rem等于根元素元素的font-size大小。

    **em：** 

    - 子元素字体大小的 em 相对于父元素字体的大小。
    - 元素的 width/height/padding/margin 用 em 的话是相对于该元素的 font-size。

    **vh、vw：**全称是 Viewport Width 和 Viewport Height，视口的宽度和高度，1vh相当于 视口高度的 1%。

    **px：**px像素（Pixel），相对长度单位。像素px是相对于显示器屏幕分辨率而言的。

    一般电脑的分辨率有 {1920*1080} 等不同的分辨率。

    1920*1080 前者是屏幕宽度总共有 1920 个像素,后者则是高度为 1080 个像素。

24. 如何中断Ajax请求？

    有两种方式：

    1. 设置超时时间让Ajax自动断开。
    2. 手动去停止Ajax请求，核心是调用 XMLHttpRequest 对象上的 abort 方法。

    ```ls
    xmlHttp.open("POST","Url",true);
     xmlHttp.onreadystatechange=function(){
     ...//得到响应之后的操作
     }
     xmlHttp.send();
     //设置3秒钟后检查xmlHttp对象所发送的数据是否得到响应.
     setTimeout("CheckRequest()","3000");
     function CheckRequest(){
     //为4时代表请求完成了
     if(xmlHttp.readyState!=4){
     alert('数据响应超时');
     //关闭请求
     xmlHttp.close();
     }
     }<br>//根据响应状态的改变关闭
    ```

    **切记：**不可用 abort 方法来作为终止对服务器的请求操作，只有当做在前端页面立刻停止执行 ajax 成功后的方法，因为你执行 abort 方法后，ajax 很可能已经对服务端发送了请求，只是还未返回回馈信息而已。

25. Vuex 中的 action 和 mutation 的区别：

    - 流程顺序：视图触发 Action，Action再触发 mutation。

    - 角色定位：

      Action：业务代码、异步请求。

      Mutation：专注于修改 State，理论上是修改 State 的唯一途径。

    - 限制：

      Mutation：必须同步执行。(Mutation中采取异步函数仍然是有效的，可以实现对state 状态的更改，但是不推荐)

      Action：可以异步，但不能直接操作 State。

26. 小程序, uni-app 生命周期： 

       1. onLoad：首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。
       2. onShow：加载完成后、后台切到前台或重新进入页面时触发。
       3. onReady：页面首次渲染完成时触发。
       4. onHide：从前台切到后台或进入其他页面触发。
       5. onUnload：页面卸载时触发。
       6. onPullDownRefresh：监听用户下拉动作。
       7. onReachBottom：页面上拉触底事件的处理函数。
       8. onShareAppMessage：用户点击右上角转发。

27. 为什么要用闭包？

       闭包是指有权访问另一个函数作用域中变量的函数,创建闭包的最常见的方式就是在一个函数内创建另一个函数,通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域,将函数内部的变量和方法传递到外部。

28. js 实现数组的随机排序。

       方法一：通过数组中的sort方法实现，return一个Math.random()-0.5

       ```js
       var arr = [1,2,3,4,5,6,7,8,9,10];
       arr.sort(function(){
           return Math.random() - 0.5;
       })
       console.log(arr);
       ```

       

       方法二：遍历当前数组，并创建一个暂存容器，每次遍历时，出现一个随机索引，使用随机索引，获取数组中一个随机的值，取出到暂存容器，然后根据当前循环次数的索引，获取数组中的值，放入原来取出的地方，最后把暂存容器的值，赋值给当前循环次数的索引的值，实现随机排序；（即三个容器间的交互）

       ```js
       var arr = [1,2,3,4,5,6,7,8,9,10];
       function randSort1(arr){
         for(var i = 0,len = arr.length;i < len; i++ ){
               var rand = parseInt(Math.random()*len);
               var temp = arr[rand];
               arr[rand] = arr[i];
               arr[i] = temp; 
          }
          return arr;
       } 
       console.log(randSort1(arr));
       ```

       

29. 介绍一下 Web Storage 的概念和用法。

       Web Storage 包含如下两种机制：

       - sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。
       - localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。

       这两种机制是通过 Window.sessionStorage 和 Window.localStorage 属性使用（更确切的说，在支持的浏览器中 Window 对象实现了 WindowLocalStorage 和 WindowSessionStorage 对象并挂在其 localStorage 和 sessionStorage 属性下）—— 调用其中任一对象会创建 Storage 对象，通过 Storage 对象，可以设置、获取和移除数据项。对于每个源（origin）sessionStorage 和 localStorage 使用不同的 Storage 对象——独立运行和控制。

       

30. 介绍一下HTTP缓存控制

       HTTP 缓存请求响应头：

       - Cache-Control：请求/响应头，缓存控制字段，可以说是控制http缓存的最高指令，要不要缓存也是它说了算。
       - Expires：响应头，代表资源过期时间，由服务器返回提供，GMT格式日期，是http1.0的属性，在与max-age(http1.1)共存的情况下，优先级要低。
       - Last-Modified：响应头，资源最新修改时间，由服务器告诉浏览器。
       - Etag：响应头，资源标识，由服务器告诉浏览器。
       - if-None-Match：请求头，缓存资源标识，由浏览器告诉服务器(其实就是上次服务器给的Etag)，和Etag是一对，它两会进行对比。

       HTTP 缓存方案：

       - hash 缓存：通过**不缓存html**，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。
       - CDN缓存(作为了解)
       - 强缓存：不发起http请求，直接使用本地缓存，比如浏览器地址栏回车，使用浏览器的刷新按钮，在Expires或max-age生效的情况下，触发的都是强缓存。
       - 协商性缓存(弱缓存)：在使用本地缓存前，先与服务器协商，核对缓存文件是否为最新。比如设置了cache-control=no-cache，不管你做任何操作，都会发起请求，这一类就是协商性缓存了。

31. ```js
       setTimeout(function(){
         console.log('定时器开始啦');
       });
       new Promise (function(resolve) {
         console.log('马上执行 for 循环');
         for(var i = 0; i < 10000; i++) {
           i == 99 && resolve();
         }
       }).then(function() {
         console.log('执行 then 函数');
       });
       console.log('代码执行结束');
       // 1. '马上执行 for 循环'
       // 2. '代码执行结束'
       // 3. '执行 then 函数'
       // 4. '定时器开始啦'
    ```

       

32. ```js
       var name = "The Window";
       var object = {
         name: "My Object",
         getNameFunc: function () {
           return function () {
             return this.name
           }
         }
       }
       console.log(object.getNameFunc()()); // undefined
    ```

       

33. ```js
       var name = "The Window";
       var object = {
         name: "My Object",
         getNameFunc: function () {
           var that = this;
           return function () {
             return that.name
           }
         }
       }
       console.log(object.getNameFunc()()); // My Object
    ```

       

34. 前端路由和后端路由的区别？

       - 什么是路由？

       路由是根据不同的 URL 展示不同的内容和页面。

       - 什么是前端路由？

         **特点：**不向后台发送请求，不刷新页面，前后端分离。

         前端路由即响应页面内容的任务是由前端来做的，根据不同的url更新页面的内容，随着SPA（单页面应用）的普遍使用，前后端开发分离，项目中基本都使用前端路由，通过路由实现页面的变化。例如，通过vue开发的SPA中，切换路由，并不刷新页面，而是根据路由在虚拟DOM中加载所需要的数据，实现页面内容的改变。

       - 什么是后端路由？

         **特点：**向服务器发送请求，会刷新页面，前后端分离。

         在浏览器的地址栏中切换不同的url时，每次都向后台服务器发出请求，服务器根据不同的响应不同的数据，浏览器接收到数据后再进行渲染，所以后端路由会刷新页面，如果网速慢的话，就会看到一个空白页面等待服务端返回数据，后台路由最大的问题就是不能前后端分离。 

       - 什么时候使用前端路由？

         在单页面应用中，大部分页面结构不变，只改变部分内容时使用。

       - 前端路由的优缺点：

         **优点：**

         - 用户体验好，页面初始化后，只需要根据路由变换页面内容，不需要再向服务器发送请求，内容变换速度快。
         - 可以在浏览器中输入指定想要访问的url。
         - 实现了前后端分离，方便开发。

         **缺点：**

         - 使用浏览器的前进、后退键的时候会重新发送请求，没有合理的利用缓存。
         - 单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动的位置。

35. node.js 中如何读写文件？

    nodejs 中所有与文件相关的操作都在fs模块中，而读写操作又是我们会经常用到的操作，nodejs的fs模块针对读操作为我们提供了readFile，read, createReadStream 三个方法，针对写操作为我们提供了writeFile，write， createWriteStream 三个方法。

    [博客地址](https://www.cnblogs.com/pp-cat/p/6504655.html)
    
36. Linux 中常用的命令？(沛华博客)

    Linux是一套开源免费的操作系统，与系统的交互通常用命令来实现，常用的命令有：

    - `ls` 查看当前文件夹下的文件（list单词的缩写）， `ls -al ` or `ls -a -l`查看隐藏文件并竖向排列
    - `cd` 进入某一个文件夹（change directory）的缩写，`cd ..`回到上一级。`tab`键代码自动补全
    - `clear` 清屏
    - `mkdir` 创建文件夹
    - `touch test.html` 创建一个文件
    - `rm test.html` 删除一个文件
    - `rm -r dir` 删除文件夹
    - `mv 原文件或文件夹 目标文件或文件夹` 移动文件
    - `cat test.html` 查看文件内容
    - `ctrl+c` 取消命令

37. 使用 CSS 实现一个三角形。

    ```html
    <!DOCTYPE html>
    <html lang="en">
        <head>
            <meta name="keywords" content="zidingyi">
            <meta name="description" content="zidingyi">
            <meta>
            <title>triangle</title>
            <style>
                div {
                    height: 0;
                    width: 0;
                    border: 100px solid transparent;
                    border-bottom: 100px solid red;
                }
            </style>
        </head>
        <body>
            <div></div>
        </body>
    </html>
    ```

    

38. 若干根粗细不均匀的绳子，每根烧完均需要1小时，怎样烧能计时45分钟?

    30 分钟：把一根绳子从两头同时烧,就能得到30分钟了。
    45 分钟：方法类似。其中一根绳子从两头烧得到30分钟，另外一根绳子从中折一下两头一起烧，两段时间加起来就可以了。

39. 假如每3个空啤酒瓶可以换一瓶啤酒，某人买了 10 瓶啤酒，那么他最多可以喝到多少瓶？

    喝完10瓶后用9个空瓶换来3瓶啤酒(喝完后有4个空瓶） 喝完这三瓶又可以换到1瓶啤酒（喝完后有2个空瓶）
    这时他有2个空酒瓶，如果他能向老板先借一个空酒瓶，就凑够了3个空瓶可以换到一瓶啤酒，把这瓶喝完后将空瓶还给老板就可以了。
    所以他最多可以喝 10+3+1+1 = 15 瓶。

40. 小程序组件之间数据传递：[博客地址](https://segmentfault.com/a/1190000014474289)

41. 小程序页面跳转和参数传递。

    跳转的三种方式：

    1. wx.navigateTo()：保留当前页面，跳转到应用内的某个页面，使用 `wx.navigateBack`可以返回到原页面。
    2. wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。
    3. 使用组件`navigator>`.

    wx.navigateTo() 和 wx.redirectTo() 的区别：

    - wx.navigateTo() 是保留当前页面，跳转到某个页面，跳转页面后可以返回上一页。
    - wx.redirectTo() 是关闭当前页面，跳转到某个页面，跳转页面后不能返回上一页。

    [博客地址](https://blog.csdn.net/zmd9999/article/details/79970083)

42. 

    ​     

       

    


