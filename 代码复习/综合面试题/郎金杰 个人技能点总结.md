# 个人技能点

## 1. 熟悉h5和c3新特性：语义化标签，flex布局，动画等

### -	H5新特性：

- 我所了解到的h5新特性主要有：新的语义化标签，新的表单增强和表单控件，本地存储，音视频API，Geolocation等，其中在开发中所用到的最多的就是
  - 为什么要语义化标签：
    - 语义化标签更具有可读性，便于团队的开发和维护
    - 在没有css的情况下也能更好的展现出页面的结构
    - 关于seo，搜索引擎能够更好的理解页面之间的关系，能够更准确的搜索信息
    - 在写页面的时候，尽少的使用div+span的布局方式
  - 盒模型：可通过box-sizing来控制盒模型的方式
    - content-box
    - border-box
    - padding-box
    - margin-box（未实现）
  - flex布局
    - 可以通过display：flex来开启
    - 亮点：
      - flex-flow：是flex-direction和flex-wrap的缩写
      - flex：flex-grow，flex-shirink和flex-basis的缩写
        - 默认是0 1 auto
        - none：0 0 auto
        - auto：1 1 auto
        - 1 ：1 1 任意长度+任意单位
  - 动画：

## 2. 熟悉js作用域、原型、事件轮询机制、闭包等原理；

### - js作用域

- 首先，作用域是变量起作用的一个范围

- 作用：用来隔绝变量，防止命名冲突

- js作用域的分类：

  - 全局作用域：全局代码就是一个全局作用域
  - 局部作用域：也被称为函数作用域，
  - 块级作用域：es6新增块级作用域就是一个大括号，并且变量要使用let/const进行定义才能生效

- 作用域产生的条件和销毁

  - 代码定义的时候就会产生，
  - 代码执行完毕销毁的是变量对象而不是作用域
  - 作用域从代码定义的时候就会产生，除非关闭程序才会销毁

- 作用域的实现是变量对象

  - 变量对象存在于执行上下文环境中，只有生成执行上下文的时候，变量对象才会被激活，只有激活变量对象，才能访问当前作用域的属性和方法
  - 变量对象分为全局变量对象和局部变量对象
    - 全局变量对象：window
    - 局部变量对象
  - 变量对象：
    - 首先包含形参和实参
    - 扫描定义的函数，并将函数作为名值对储存在函数变量对象的属性中，如果变量对象中有同名，则直接覆盖
    - 扫描定义的变量，保存在变量对象中，如果与变量对象中的形参和函数同名， 则直接不会影响到他们

- 执行上下文环境

  - js代码在正式执行之前js引擎会先做一些准备工作

  1. 创建执行上下文环境
  2. 创建一个空的对象(执行上下文对象)，该对象用于收集当前作用域的：变量，函数，函数的参数
  3. 确认this的指向
  4. 创建当前环境的作用域链

- 作用域链

  - 作用域链就是查找变量的一个过程，首先会在自身的作用就中查找，如果有就使用，如果没有，去上级作用域中查找，一直查找到window，如果还没有找到就会报错xxx is not defined

### - 闭包

- 什么是闭包：
  - 函数嵌套函数，闭包是嵌套的内部函数
  - 闭包是包含被引用变量的对象，在chrome开发者工具中查看，闭包是clouse属性，他存在于scrope属性中
  - 我认为闭包是一个意外存活的变量对象
    - 证明：两个内部函数同时引入外部函数的同一个变量的时候，他们的闭包是同一个闭包
- 闭包的形成条件：
  - 函数嵌套函数
  - 内部函数引用外部函数的变量
  - 外部函数调用
- 闭包的产生时机
  - 内部函数定义执行
- 闭包的作用
  - 延长局部变量起作用的范围
  - 外部能够操作内部局部变量
- 闭包的缺点
  - 容易造成内存泄漏，甚至造成内存溢出
  - 解决方法让内部函数 = `null`
- 闭包的应用
  - React的高阶函数
  - Vue源码中的数据劫持，watcher保存node节点以及保存更新函数

### - 事件轮询机制

- 事件轮询机制一共有两种一个是js事件轮询一个是nodejs的事件轮询
- js事件轮询机制：
  - js中的代码分为初始化代码（同步代码）和异步回调代码（异步代码）
    - 初始化代码主要是一些设置定时器，绑定事件，发送ajax等
    - 异步回调代码主要是：定时器的回调函数，事件处理回调函数，ajax的回调函数
  - 事件轮询中有个重要模块
    - 事件管理模块
      - 定时器管理模块
      - dom时间管理模块
      - ajax管理模块
      - MutationsObserver管理模块
    - 回调对列
      - 宏任务：
        - setTimeout，setInterval，ajax，dom事件监听，等
      - 微任务
        - promise，async/await，mutationsobserver等
  - js代码的执行过程是
    - 首先会执行同步代码，如果遇到了异步回调代码，会先将异步回调代码交给事件管理模块处理，
    - 当事件管理模块模块中的事件触发，将对应的回调函数注册到回调队列中
    - 当初始化代码执行完毕的时候，会遍历回调队列中的回调函数执行
  - 微任务和宏任务
    - 如果不将主线程中的代码视为第一宏任务，那么微任务优先于宏任务
    - 执行过程是
      - 会优先执行微任务中的所有回调，只有当清空微任务，并且执行完GUI渲染线程，才能执行宏任务中的第一个回调函数，每执行完一个宏任务中的回调都会检查微任务中是否有回调，如果有，则必须清空微任务，在继续执行宏任务中的第一个回调
- nodejs中的事件轮询
  - node中的事件轮询一共分为六个阶段，
    - timers 计时器阶段
    - I/O callback I/O 事件回调
    - idle，prepare 准备阶段
    - poll 轮询阶段
    - check 检查阶段
    - close callbacks 关闭阶段
  - 他们会按照顺序反复执行，每当进入一个阶段的时候，会遍历其中的回调函数依次执行，直到该阶段清空会这达到系统最大上限才会进入下一个阶段进行执行
  - 最重要的有三个阶段：
    - timer计时器阶段：执行setTimeout和setInterval回调
    - poll轮询阶段，执行I/O回调，处理事件轮询中的事件
      - poll阶段会存在两种情况
        - 如果poll阶段为空，
          - 如果check阶段或者是timer阶段有回调函数，则会进入下一个阶段继续执行
          - 如果不为空，则会在此阶段等待回调函数添加
        - 如果poll中有回调。则遍历执行，只到清空或者达到最大上限
    - check阶段，此阶段执行setImmediate
- node中还有一个特殊的process.nextTick，他不属于以上的所有阶段，在每个阶段完成后，如果存在nextTick队列，则会清空回调中的所有回调，这个回调有优于所有的微任务

### 原型

1. 总：
   1. 我们所说的原型，说的是两个属性
      1. 其实是包括函数的显示原型属性`prototype`
      2. 另外一个就是对象上的隐式原型属性`__proto__`
2. 分：
   1. 显示原型属性
      1. 显示原型属性存在与函数中，当然__箭头函数__是没有显示原型对象的
      2. 显示原型在函数创建的时候就会产生，默认是__指向__的是一个`Object`实例对象
      3. 里面有一个`constructor`属性，指向的是拥有这个显示原型的函数
   2. 隐式原型属性
      1. 所有的对象都拥有隐式原型属性`__proto__`
      2. 这个`__proto__`指向的就是这个对象的构造函数的显示原型对象
      3. 所以说构造函数的显示原型对象和这个构造函数的隐式原型对象指向的是同一个对象，这也是他们的联系
   3. 特殊情况
      1. 所有的函数都是由`Function`构造调用得到的函数对象，每一个函数除了拥有显示原型属性之外，也会拥有一个隐式原型属性`__proto__`
      2. `Function`的隐式原型属性`__proto__`会指向的是它本身的`prototype`属性。这条线是作者自己指定的
      3. Object的显示原型对象`prototype`的`__proto__`为null
      4. `js`中由`C`语言创建的内容有
         1. `Object`
         2. `Function`
         3. `Function.prototype`
      5. 由作者自己创建的四条线
         1. `Function.prototype = Function.__proto__`
            1. 目的：函数的所有公共方法都存在`Function.prototype`，所以为了使得`Function`能访问到这些方法，就必须指这条线
         2. `Object`的隐式原型属性和`Function`的显示原型属性，指向的是同一个对象
            1. 目的：同上
         3. `Function.prototype = Object.prototype`
            1. 为了讲原型对象串联起来
         4. `Object.prototype.__proto__ = null`
            1. 为了使得原型链有终点
   4. 原型链
      1. 作用就是查找对象中的属性的一种规则
      2. 规则：
         1. 首先在自身上查找属性，如果有则直接返回值
         2. 没有则沿着隐式`__proto__`上查找
         3. 一直到`Object.prototype.__proto__`由于他的值是null，所以会返回undefined
   5. 原型的作用：
      1. 被同一个构造函数调用的多个实例对象共有属性和方法，实现原型链继承。
      2. vue中的全局事件总线，通过给`Vue`的显示原型对象添加一个`$bus`对象，内部包含了`$on,$emit,$once,$off`等方法，由于组件实例的隐式原型对象的隐式原型对象指向的是`Vue`的显示原型对象，所以能够在任意的组件中使用`$on,$emit,$once,$off`方法
      3. vue中可以给vue原型对象添加方法，所有的组件都能够使用

## 3. 熟悉ES6语法标准promise，async/await异步方案，箭头函数等；

### - `Promise`思路：

- 什么是`Promise`，`Promise`的状态，怎么使用`Promise`，`Promise`原型方法，`Promise`的静态方法，`Promised`的应用

- `Promise`是一个异步编程的解决方法，避免了地狱回调的书写方式。

- `Promise`是一个构造函数，需要实例化调用

  - `new Promise()`后面需要传入一个回调函数，回调函数默认传入两个参数，一个是`resolve`，另一个是`reject`
  - `new Promise`默认会返回一个成功的`promise`，结果是`undefined`
  - 如果在回调中调用了`resolve`，则表示该`promise`对象是成功状态的，结果是`resolve()`中传入的参数
  - 如果在回调中调用了`reject`，则表示该`promise`对象是失败状态的，结果`reject`中的参数
  - 如果`new Promise`中抛出了错误，则返回的`promise`对象也是失败的，失败的原因就是错误的原因

- `Promise`的对象一共有三种状态

  - `pending`：无状态，便是`promise`对象是初始化状态，或者还未完成。
  - `resolve/fulfilled`：表示`promise`为已经完成的状态
  - `reject`：表示`Promise`是失败
  - `promise`的状态只能改变一次，

- `Promise`上的原型方法

  - `then`：默认会返回一个promise对象
    - 返回成功的
      - then函数返回其他值
      - then返回成功的promise对象
    - 返回失败
      - 函数出错
      - 返回失败的promise对象
    - 穿透：返回上一个promise的结构和状态
  - `catch`
    - 是then的一个语法糖，相当于第一个回调没有传入，只传入第二个回调函数

- `Promise`的静态方法

  - `all`:

    - 传入一个或者多个`promise`对象
    - 如果所有的`promise`都返回成功，则会返回成功，如果有一个返回失败则返回失败
    - 如果成功，则`promise`的结果的是一个数组，数组中是所有promise的结果
    - 如果失败，则`promise`的结果是失败的那个`promise`的原因

  - `allSettled`

    - 总是返回成功的`promise`
    - `promise`的结果总会是一个数组，数组中是一个个对象，对象中有status，和value（成功）/reason（失败）

  - `any`

    - 传入一个或者多个promise对象

    - 返回最快成功那个promise对象

    - 如果全部失败，则返回的是一个失败的promise对象，结果是一个对象，对象中的error是一个数组，数值中保存的是失败的原因

    - ```javascript
      Promise {<pending>}
        __proto__: Promise
        [[PromiseState]]: "rejected"
        [[PromiseResult]]: AggregateError: All promises were rejected
          errors: (3) ["p1失败了", "p2失败了", "p3失败了"]
          message: "All promises were rejected"
          stack: "AggregateError: All promises were rejected"
          __proto__: Error
      ```

    - 

  - `race`

    - 返回最快的那个`promise`对象，不管是成功还是失败的

  - `resolve`

    - 返回一个成功的`promise`对象

  - `reject`

    - 返回一个失败的`promise`对象

### - generator

- `generator`是`ES6`引入的语法，是一个可以暂停和继续执行的函数
- 可以当作一个`iterator` 迭代器对象来使用，可以进行遍历操作。
  - `Iterator` 是一种接口，目的是为不同的数据结构提供统一的数据访问机制。也可以理解为 `Iterator` 接口主要为 `for of` 服务的，供`for...of`进行消费。
- 也可以当成一个状态机来使用
  - `generator`使用`function*`来进行定义
  - 函数内部通过`yeild`来暂停函数的执行，表达式默认返回`undefined`
  - 然后执行之后返回的一个迭代器对象的`next()`方法来继续函数的执行，传入的参数是上一次的`yeild`的返回值

### - async/await

- 是解决回调地狱的终极解决方案，以同步代码方式书写异步代码
- 是`generator`的语法糖
- `async`对应的是`*`
- `await`对应的是`next()`
- `async/await`自动进行了`generator`的流程控制
- 并且`await`只会暂停promise的操作，其他的异步不会暂时
- `async/await`的返回值问题
  - `async`函数的返回值是一个`promise`对象
  - 对象的状态由函数状态决定，函数如果执行完毕，则返回一个成功的promise，否则返回一个失败的`promise`
  - 这个`promise`对象的返回值是函数的返回值
  - 如果出错（await后面跟着一个失败的promise也算是报错），会中断promise对象的执行，并且这个返回的promise对象是一个失败的promise,返回值是错误原因

### - promise和async/await的区别

- async/await相对于promise来讲，写法更加优雅
- promise的错误通过catch来捕获，
- async/await通过then来捕获，也可以通过try/catch来捕获

### - 箭头函数

- ES6新增了一种函数的定义方式，箭头函数，使用=>来进行定义，被称为箭头函数
- 箭头函数没有自己的this，它的this指向的是上一层作用域的this
- 箭头函数不能当作构造函数
- 箭头函数没有arguments
- 箭头函数没有原型对象

## 4. 熟悉js组合继承，js数据类型及数据类型转化；

## 6. 了解ajax前后台数据交互原理，熟练使用原生ajax及ajax类库，如: axios；并掌握jsonp、cors、proxy等跨域解决方案；

### 原生ajax写法

1. 创建xhr对象

   `const xhr = new XMLHttpRequest()`

2. 设置请求首行：定义请求方式和请求地址

   `xhr.open(get/post,url)`

3. 设置请求头：GET请求不用设置

   `xhr.setRequestHeader('content-type','application/x-www-form-urlencoded')`

4. 发送请求

   `xhr.send(data)`

5. 监听状态

   ```js
   xhr.onreadystatechange = function(){
   	xhr.readyState === 4// 0 1 2 3 4 
     xhr.status === 200
   }
   ```

### ajax状态码

- 2xx：表示成功处理请求
  - 200：表示成功处理请求
  - 201：添加数据成功
- 3xx：表示需要重定向，浏览器直接跳转
  - 301：永久性重定向
  - 302：暂时性重定向
  - 304：使用缓存
- 4xx：客户端请求错误
  - 401：没有访问权限
  - 404：访问的资源不存在
- 5xx：服务器端错误
  - 500：服务器程序运行错误

### ajax和http请求的区别

- 跨域的预检查：不进行预检查的有：
  - 简单请求GET，HEAD，POST（Content-Type必须是application/x-www-form-urlencoded, multipart/form-data或着text/plain中的一个值）
  - 没有自定义HTTP头部

- ajax请求是一种特别的http请求
- 对服务器端来说，没有任何区别，区别在于浏览器端
  - http不会发生跨域报错，而ajax会发生跨域报错，
- 只有ajax请求或者是fetch发出的才是ajax请求，其他所有都是非ajax请求
- 浏览器端接收到响应
  - 一般请求：浏览器一般会直接接收响应体数据
  - ajax请求：不会对界面进行任何的更新操作，只是调用监视的回调函数并传入相关数据

### 跨域相关

- 同源策略
  - 只有协议名，域名，端口号三者都相同才能称为符合同源策略
  - ajax请求时，浏览器要求当前网页和server必须同源（安全），否则会抛出跨域错误
  - 加载image/link/script时不受同源策略的影响，也就是不会发生跨域报错
- 同源策略限制的范围：
  - 影响ajax请求
  - 影响dom获取：不能获取iframe内联框架和window.open的dom
  - cookie，locaStorage,indexDB
- 解决跨域
  - jsonp
    - 原理：利用了script标签不受同源策略的影响
    - 前台
      - 创建一个函数，用于调用接收服务器返回的数据
      - 创建一个script标签，src上输入需要发送请求的地址，并且参数带上定义的函数
    - 后台
      - 处理请求，产生需要返回的数据
      - 读取请求参数，获取传入的函数
      - 将数据作为函数的实参以字符串的形式返回给前台
    - 前台调用获取数据
  - 缺点：
    - 只能处理get请求
    - 每一个请求都需要进行处理
- cors
  - 原理：设置响应头，让浏览器能够接受跨域的响应
  - 需要在服务器进行设置，前端不需要进行任何设置
  - 一般可以设置允许哪些地址进行跨域
  - 允许哪些请求可以跨域
  - 指定哪些请求头跨域进行跨域
- 代理：
  - proxy正向代理，需要知道目标服务器
  - 原理：服务器与服务器之间不会发生跨域报错，也就是不受同源策略的影响
  - 正常情况下，浏览器向目标服务器发送请求会发生跨域问题
  - 为了解决跨域，可以让浏览器像开发服务器发送请求，然后由开发服务代替浏览器发送请求
  - 目标服务器向代理服务器返回数据，代理服务器再向客户端返回数据
- 反向代理：不需要知道目标服务器，负载均衡

### 从输入url地址到显示页面都发生了什么

- 进行dns解析
  - 会首先在浏览器的dns缓存中查找域名对应的web服务器IP地址，如果没有则依次到计算机dns缓存，路由dns缓存，运营商dns缓存，如果没有，就向公共的域名解析服务器查找，这个查找是一个递归的过程，如果查找到，则跳到下一步
- 检查浏览器中是否有缓存
  - 通过cache-control和expires来检查是否命中强缓存，如果有缓存直接使用缓存进行渲染
  - 如果没有没有命中强缓存，则会向服务器发送请求（会先进行tcp连接），服务器会通过Etag（资源的唯一标识符）和last-Modify（最后一次修改的时候）来确定缓存是否失效，也就是进行协商缓存，若无更改，则返回状态吗304，浏览器读取本地缓存
  - 如果强缓存和协商缓存都没有命中，则返回响应结果
  - ![image-20210624150012654](/Users/jeff/Library/Application Support/typora-user-images/image-20210624150012654.png)
- 进行TCP连接
  - 通过三次握手进行连接，这三次握手可以简单概述为：
    - 浏览器发送给服务器，告诉服务器我准备好了，即将发送请求
    - 服务器发送给浏览器，告诉浏览器我准备好了，请你在确认一遍
    - 浏览器发送给服务器，告诉服务器我确认好了，即将发送请求
- 发送请求：请求报文发送给服务器
- 接收响应：浏览器接受响应报文
- 解析渲染页面
  - 遇到html文件，调用html解析器，生成dom树
  - 遇到css文件，调用css解析器，生成cssom树
  - 遇到js文件，调用js解析器，解析js代码
    - 可能会修改html，再次调用html解析器，修改dom树
    - 可能会修改css，再次调用css解析器，修改cssdom树
  - 将dom树和css进行合并在一次生成render tree（渲染树）
  - 进行渲染，将颜色/文字/图片等渲染上去
- tcp四次挥手
  - 浏览器发送给服务器，告诉服务器请求报文发送完毕
  - 服务器发送给浏览器，告诉浏览器请求报文接受完毕
  - 服务器发送给浏览器，告诉浏览器发送响应报文完毕
  - 浏览器发功给服务器，告诉服务器响应报文接受完毕
- 浏览器断开链接，服务器断开连接

### http1.0/http1.1/2.0的区别

#### http1.0和http1.1的区别

- http1.1相对于1.0引入了更多的缓存策略
  - 1.0只能通过expres和pragma来控制缓存的事件和禁止缓存
  - 1.1引入了Cache-Control来实现缓存
    - max-age：对应expres
    - no-cache：对应pragma
- 带宽优化及网络连接的使用
- 错误处理的通知
  - http1.1新增了49种新的状态处理
  - 比如：
    - 409，表示请求的资源与资源的当前状态发生冲突
    - 410：服务器上的某个资源被与永久删除
- Host头处理
  - HTTP1.1的请求消息和响应消息都支持host域
- 长链接
  - 1.0支持__长链接__和请求的__流水线处理__，在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟，在1.1种默认开启keep-alive

### http和https的区别

- https协议需要申请CA证书
- https传输的内容是加密的
- 是用的是完全不同的连接方式，端口号也不一样
- https可以有效的防止运营商的劫持

### http2.0/1.x的新特性

​	1.新的二进制格式,解析模式从原本的文本解析,变更为二进制解析

​	2.多路复用,一个请求可以请求多个资源

​	3.header压缩,通讯双方都缓存一份header,后续传输即可省略该部分

​	4.服务器推送

## 7. 熟练使用npm、yarn等包管理工具和git版本管理工具；

## 8. 熟悉json-server/express服务器搭建、postman接口测试等工具；

### json-server

Json-server：相当于一个小型的服务器

express：

```js
// 导入express
const express require('express')
// 创建app
const app = express()
// 路由设置
app.get('/user',(request,response)=>{
  // 获取传入的数据
  console.log(request.query)
  console.log(request.parmas)
  // 返回数据
  response.send()
})
// 分配端口
app.listener(500,(error)=>{
	console.log('开启成功')
})
```



## 9. 熟练使用vue开发项目，使用vuex实现多组件数据共享；使用vue-router实现单页面应用；

### vuex

- vuex是专为vue开发的状态管理工具。
- vuex的使用场景
  - 多个组件依赖同一个状态；
  - 多个组件的行为需要变更同一个状态时；
- vuex有五大管理模块
  - state：
    - 数据类型是对象
    - 共享的状态数据，里面的数据是响应式的
  - getters：
    - 数据类型是函数
    - 根据state中的数据来生成新的数据
  - actions
    - 数据类型是函数
    - 进行一些异步操作，一般用来发送ajax等
  - mutations
    - 数据类型是函数
    - 直接修改state中的数据，规范要求必须是同步函数
  - modules
    - 数据类型是对象
    - 用来分割store，实现vuex的多模块编程，这样能够使得更具有扩展性
    - 单模块的问题：
      - 如果管理的状态数据过多，actions和mutations就会过于臃肿，不便于维护
      - 如果添加新的状态数据，需要修改当前的文件，不断的向已有数据进行添加
- 流程：
- vuex面试题
  1. vuex中的mutations可以执行异步操作吗？
     - 可以，但是不符合规范
     - 调试工具只会记录触发的mutations，如果出现异步函数，调试工具将可能无法正常跟踪state的变化，
     - 导致调试工具失效
     - 扩展: 工具如何记录数据变化? ==> 每次mutation函数执行完后, 立即记录当前的数据   ==> 在mutation中同步更新state, 才能被记录到，也就是工具只会记录每次mutations触发之后同步更新的state数据
  2. vuex中的状态数据的响应式原理
     - 创建了一个vm实例对象
     - state中的数据都是data数据（响应式数据）
     - 组件中读取的数据本质上是data中的数据
     - 一旦更新可state中的数据，就会更新使用到state数据的视图
  3. vuex更新数据丢失的问题
     - 每一次数据更新都会同步到sessionStorage中，也就是在mutations中每一次更新的时候都会讲数据更新到sessionStorage中，然后在初始化的时候再从sessionStorage中获取数据
     - 可以通过`beforeunload`事件，在页面刷新之前，将vuex中的数据保存在sessionStorage中，然后在初始化的时候从sessionStorage中获取vuex中的数据

### vue-router

- 使用vue+vue-router创建单页面十分简单，vue-router提供的功能是将组件映射到路由，然后渲染出来，所以vue-router需要满足两个条件
  - 记录当前页面的状态
  - 可以使用浏览器的前进和后退的功能（也就是BOM的history功能）
- 而vue-router为了满足以上两个功能需要满足以下三个条件
  - 改变url且不让浏览器向服务器发送请求
  - 检测url的改变
  - 截取url解析出需要的信息来匹配路由规则

- hash值的特点
  - hash值表示的是地址栏中的#号（也被称为锚点），hash虽然会出现在url中，但是不会被包含在http请求中，因此hash值的改变不会重新加载页面，并且hash值会触发hashchange事件，浏览器的前进后退也能对其进行控制
  - 特点：
    - 兼容低版本的浏览器，vue默认使用的就是hash模式
    - 只有#之前的内容才会包含在请求中被发送到后端，也就是说就算后端中没有对全路由进行覆盖，也不会产生404
    - 会覆盖定位锚点的功能
    - 不太美观，后面传递复杂的数据的话可能会产生问题
- history的特点
  - 利用了H5的新特性：pushState()和replaceState()两个api，通过这两个api完成url的跳转是不会重新加载页面的
  - history提供了类似于hashchange事件的popstate事件，不同的通过pushState和replaceState和a标签不会触发popstate事件，可以拦截 pushState/replaceState的调用和`<a>`标签的点击事件来检测 URL 变化
  - 特点：
    - 兼容性比较差，由于history API低浏览器不支持，所以兼容性比较差
    - `pushState()` 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 `hash` 只可修改 `#` 后面的部分，因此只能设置与当前 URL 同文档的 URL；
    - pushState就算设置的新url与当前的一致，也会添加到历史栈中，而hash只有新值与旧值不一样才会被添加到记录栈中
    - pushState可以通过stateObject参数可以添加任意类型的数据到记录中，而hash只能添加字符串到记录中
    - 在手动输入尤其在用户手动输入 URL 后回车，或者刷新（重启）浏览器的时候。hash由于只会将#之前的url发送到服务器，即使没有实现全路由覆盖，也不会报404错误
    - 而history模式下，前端的url会完整的被发送大后端，如果后端没有配置相应的路由，就会报404错误，所以需要**增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”**

### vue-router原理

- new Router的原理：
  - new Router传入的配置对象，配置对象有model和routes两个属性，model是路由的模式。routes是路由配置数组，将这个routes数组进行数据类型优化，遍历原来的routes数组，变为一个对象的形式，key是路由地址，value是对应的组件，
  - 然后将整个router实例添加为Vue的原型对象上的$ruoter属性，添加一个$route属性在Vue的原型对象上
  - 并且添加path和push方法在$route中，
    - path获取的就是pathname端口号之后的路由路径，并且将path添加为响应式，当他变化，router-view中也会变为相应的组件
    - push方法就是pushState()的实现
- router-view的原理
  - ruoter-view是一个函数式组件
  - 声明当前组件是一个router-view
  - 通过depth变量,记录当前是几级路由
    -  (通过while循环,从当前组件往上找,看遇到了几个rouiter-view,直至找到路由根组件为止)
  - 在render函数中
    - 通过path获取到当前的路由地址
    - 通过router上的mapRoutes对象,配合当前的路由地址,搜索出所有路径相似的路由,获取到对应的组件
    - 将对应的组件通过createElement方法,生成虚拟DOM
- router-link的原理
  - 默认生成一个a标签，当然可以指定标签
  - 给当前的a标签绑定点击事件
  - 禁止a标签的默认行为，防止它自动跳转
  - 点击事件内部，调用编程式导航push方法

#### - history404问题

- 这个问题主要存在刷新的时候会产生，因为history在刷新的时候会将整个地址栏发送到后端进行请求，后端没有相应对应的请求，所以会返回404
- hash模式没有该问题，主要是因为hash值#后面不会进行发送请求
- 

### vue-router的路由导航钩子

#### 1. 全局前置守卫

```js
router.beforeEach((to,from,next)=>{

})
```

#### 2. 全局解析守卫

```js
beforeResolve
```

#### 3. 全局后置守卫

```js
router.afterEach
```



#### 4. 路由独享守卫

```
beforeEnter
```



#### 5. 组件内的守卫

```js
beforeRouteEnter
beforeRouteUpdate // 组件复用的时候调用
beforeRouteLeave // 导航离开该组件的时候调用
```

#### 1. to: Route: 即将要进入的目标 路由对象

#### 2. from: Route: 当前导航正要离开的路由

#### 3. next: Function: 一定要调用该方法将控制权交给下一个守卫，执行效果依赖 next 方法的参数。

- next(): 进入下一个守卫。如果全部守卫执行完了。则导航的状态就是 confirmed (确认的)。

- next(false): 中断当前的导航（把小明腿打断了）。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。

- next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航（小明被打断腿并且送回家了）。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。

- next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。

  #### 永远不要使用两次next，这会产生一些误会。

#### 导航的全过程

导航被触发。

在准备离开的组件里调用 beforeRouteLeave 守卫。

调用全局的 beforeEach 守卫。

在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。（如果你的组件是重用的）

在路由配置里调用 beforeEnter。

解析即将抵达的组件。

在即将抵达的组件里调用 beforeRouteEnter。

调用全局的 beforeResolve 守卫 (2.5+)。

导航被确认。

调用全局的 afterEach 钩子。

触发 DOM 更新。

用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。

### - 路由拦截

依赖meta标签来进行

### - 路由传参

- query
- parmas



## 10. 熟练使用第三方插件库：element-ui、ant-design、swiper、dayjs等；

## 11. 了解Vue响应式数据原理和双向数据绑定原理；

#### - Vue的响应式原理

- 首先vue的响应式原理的核心是`Object.defineProperty()`这个api
- 这个api可以设置一些额外的隐藏属性
  - value：这个属性的属性值
  - writable：这个属性是否可写，一般默认值为true
  - enumerable：这个定时属性是否可被枚举，
  - configurable：是否可以被重新设置
  - get：默认为undefined，当然get/set不能和value和writable共存
  - set：默认为undefined

- vue的响应式原理主要包括三个部分，一个就是数据代理，数据劫持，模板解析

- 数据的代理
  - 将data数据通过defineProperty代理到vm实例上，然后为其添加get/set方法
  - 每次通过实例访问data数据的时候，会触发代理属性的get方法，实际上是去操作的是data中的属性
  - 每次通过实例修改data数据的时候，会触发代理属性的get方法，实际上是去更新的是data中的属性
- 数据劫持
  - 对象的劫持
    - 数据劫持中，主要是通过oberve来进行，第一次将data整个对象传入oberve函数中
    - 首先observe会判断传入的参数是否是一个对象，如果不是则会直接返回
    - 会遍历每一个data对象中的key属性
    - 每一个key属性都会调用defineReactive这个方法，这个方法会将key的vaule值和新创建出来的dep对西那个使用闭包的方式保存下来，这个dep会在模版解析的时候使用上
    - 然后再次隐式调用oberve实现深度劫持
    - 调用defineProperty给重写data中的每一个属性，并添加上get/set方法
    - 在getter中收集依赖，在setter中触发依赖
    - set方法会调用dep.depend()方法，同时返回val
    - set会再次调用oberve进行劫持，并且调用notify通知试图更新
  - 数组的响应式
    - 会改写，push，pop，shift，unshift，splice，sort，reserver这七个数组方法
- 模板解析：
  - 将el中的所有子节点都添加到fragment中
  - 遍历gragment中的所有的子节点
  - 判断子节点的类型nodeType
    - 如果是元素节点nodeType === 1
    - 获取所有的属性节点，判断属性是否以v-开头
      - 如果是v-on则是事件指令则绑定原生事件
      - 如果是普通指令属性
        - 根据普通指令属性的类型调用相应的update方法更新界面
        - 生成一个watcher，缓存node和update方法，并且建立watcher和dep之间的关系
    - 如果是文本节点 nodeType === 3 并且有插值语法
    - 直接调用textUpdate方法更新界面
    - 也会生成一个watcher，
  - 然后将fragment插入到el中生效
- 当更新data的时候，会触发代理属性的set方法
- 然后接着会触发data中对应的set方法，更新闭包中的val值，然后再调用oberve函数，紧接着触发dep.notify通知所有的watcher进行页面的更新

#### - 双向数据绑定原理

- vue是通过v-model来实现双向数据绑定的
- 将指定变量的值通过强制绑定的方式绑定给input的value
- 然后给input绑定上input事件，然后当input事件触发的时候将指定变量的值进行修改，

## 12. 熟练掌握vue组件通信的多种方案：Vuex，props，sync，全局事件总线等以及vue的声明周期钩子函数；

### vue组件之间通讯

1. vuex

   - 任意组件之间的通信
   - 统一管理多个组件之间的共享状态数据

2. props

   - 可以实现父子间的组件通讯
   - 通过在父组件中的子组件标签中以标签属性的方式传入子组件
   - 将更新父组件的函数传入子组件，在子组件中调用函数并且传入实参，即可实现子组件传递给父组件

3. 自定义事件

   - 可以实现子组件向父组件通信

   - 在父组件中给通过标签属性的方法给子组件绑定事件
   - 然后在子组件中通过组件实例的$emit来分发指令，然后调用事件的回调函数并且传递实惨实现子传父

4. 全局事件总线

   - 可以实现任意组件之间的通信

   - 全局事件总线是在自定义事件基础之上，通过在Vue的原型对象上添加$bus为vm实例对象，
   - 组件实例的隐式原型对象是vue实录对象，所以组件实例也可以访问到$bus这个对象，所以在任意组件都可以调用$on,$emit,$once,$off这几个属性
   - 在组件中可以直接通过this.$bus.on绑定事件
   - 可以通过this.$bus.$emit来分发事件

5. v-model

   - 可以实现父子组件通信
   - 相当于通过props传递了一个value属性
   - 绑定了一个input自定义指令用来跟新父组件中的数据

6. .sync

   - 通过props传递一个属性
   - 再通过自定义事件传入update:props属性的自定义事件

7. $attrs/$listeners

   - $attrs可以获取到不通过props接受的props参数
   - $listeners可以获取到绑定给该组件的自定义

8. $refs/$parent/$children

   - 可以直接获取到父组件的实例或者是子组件的实例

9. provide/inject

   - 祖孙之间的组件通信
   - 通过provide定义数据
   - 然后inject直接接受数据
   - 注意：provide传递的不是响应式数据，祖先组件修改，孙子组件不会修改

10. 插槽

    - 向子组件传递标签内容
    - 默认插槽
      - 父`v-slot`
      - 子：`<slot/>`
    - 命名插槽
      - 通过template标签，添加v-slot:slotName标签属性指定名字
    - 作用域插槽

## 13. 熟练解决移动端适配：viewport，rem，vw等；

### 适配方案

- 在终端不设置布局适口的时候，布局视口的宽度是`980px`，此时页面的内容非常小会，如果方法显示，就会比较小，并且会出现横向的滚动条，为了让页面的宽度为视窗的宽度，页面没有横向滚动条，需要进行移动端适配

- 先通过`viewport`将布局视口的宽度设置为设备独立像素的宽度

- 适配方案

  1. `rem`:
     - 设置`rem`，编写样式时统一使用rem为单位，在不同设备上动态调整根字体大小
     - 方法一：通过`js`动态获取到设备的设备独立像素(布局视口)`(DP)`，然后将跟标签的`font-size`设置为`dp/设计稿宽度*100 + ‘px’`，然后在使用的时候，直接将样式设置为:`设计稿尺寸/100rem`
     - 方法二：通过`js`动态获取到设备独立像素（布局视口），然后将跟标签的`font-size`设置为：`dp/10+'px'`，然后将样式直接设置为：`设计稿尺寸/设计稿总宽度*10 rem`
     - 工具：使用`postcss-pxtorem`来进行适配
     - 优缺点
       - 优点：能够实现在不同大小的屏幕上显示的比例一致
       - 在大屏设备上会造成显示的内容超大
       - 解决：
         - 限制`rem`的最大值
         - 通过媒体查询来限制内容的最大宽度
  2. `vm`适配
     - `vw`和`vh`是两个相对单位
       - `1vw` = 等于布局视口宽度的1%
       - `1vh` = 等于布局视口高度的1%
     - 在设置样式的时候，计算出样式比例然后直接添加上
     - 工具：使用`postcss-px-to-viewport`来进行适配
     - 优点：`vw、vh`布局能良好的实现在不同尺寸的屏幕横向填满屏幕
     - 缺点：大屏幕显示过大，兼容性问题
  3. 百分比：
     - 可以使用百分比来进行布局，得到在不同的屏幕尺寸下都比例一致，但是因为百分比相对的是父级，所以当嵌套过深的时候会发生问题，或者是需要固定的尺寸时会产生问题
  4. 媒体查询
     - 通过媒体查询，可以针对不同的屏幕进行单独设置，但是针对所有的屏幕尺寸做适配显然是不合理的，但是可以用来处理极端情况（例如 IPad 大屏设备）或做简单的适配（隐藏元素或改变元素位置）

  5. px 为主，搭配 vw/vh、媒体查询与 flex 进行布局
     - 我们从页面编写的角度出发，页面中更多的是文本和布局，关于文本，我们应该使用 `px` 作为单位，来实现在大屏设备显示更多的内容，而不是更大的文本；关于布局，我们可以使用 `flex` 实现弹性布局，当实现特定宽高元素时，可以适当的使用 vw/vh，当特定的值使用 vw/vh 计算复杂或存在误差时，也可以使用 rem

- 一像素问题

  - 通过媒体查询，当设备像素比为`2`的时候，将边框写为`0.5px`，在设备像素比为`3`的时候，将边框设置为`0.33px`
  - 直接设置`viewport`
    - 使用`window.deivcePixelRatio`获取到设备的像素比
    - 然后进行判断（也就是将布局适口的宽度设置为和设备物理像素一致的宽度）
      - 当设备像素比为`1`的时候，`inital-scale = 1`
      - 当设备像素比为`2`的时候，`inital-scale = 0.5`
      - 当设备像素比为`3`的时候，`inital-sclae = 0.33`
    - 使用`document.docuemntElement.clientWidth`获取到布局视口，然后进行`rem`适配
    - 然后边框在进行样式设置的时候使用`px`不使用`rem`，就保证了每一个边框都是`1px`

rem适配

viewport适配

百分比适配

flex在某种场景下也能适配

## 14. 熟悉小程序开发，熟悉小程序的WXML、WXSS、JS等开发规范；

### 小程序的特点

- 体积小，压缩包的体积不能大于2M
- 没有DOM对象
- 基于组件化开发
- 小程序环境不同于浏览器环境
  - 浏览器的全局对象是window
  - 小程序的全局对象是wx
  - 小程序环境中没有window对象

### 小程序适配

- 小程序适配单位是rpx响应式单位
- 小程序中规定的所有机型中页面宽度都是750px
- 底层已经做了viewport适配

### 小程序相关语法

1. 数据绑定
   - 单项数据流：model --> view
   - 修改状态数据：this.setDate()，同步修改
   - 页面中的数据均来自于data
2. 事件绑定
   - 事件类型：冒泡事件 || 非冒泡事件
   - 绑定事件：bind+事件名称｜catch+事件名
3. 路由跳转
   - wx.navigateTo() || wx.redirectTo()
4. 本地存储
   - 语法：
     - wx.setStorage()||wx.setStorageSync()：异步设置 || 同步设置
     - wx.getStorage()|| wx.getStorageSync()：异步获取 || 同步设置
   - 储存
     - 单个key上限是1MB
     - 整体上限是10MB
5. 全局穿参
   - app.js中可定义全局参数globalData

### 微信小程序登录流程

- wx.getUserProfile实现用户授权
  - 注意：
    - 必须绑定在tap事件中的回调才能生效
    - 调用一次该api，就会产生一个弹窗
- wx.getUserInfo二次免登录授权
  - 必须在授权之后才能使用

### 小程序获取用户唯一标识（openId）

1. 客户端先通过wx.login(获取code
2. wx.request()发送code给服务器
3. 服务器端发送请求携带参数(code, appSecret（开发密钥）, appId)给微信服务器获取openId
4. 微信返回openId给服务器后，服务器进行加密再返回给前端
5. 前端进行本地储存，下次发送请求时携带参数

### 小程序支付流程

1. 用户在小程序客服端下单(包含用户及商品信息)
2. 小程序客户端发送下单支付请求给商家服务器
3. 商家服务器同微信服务器对接获取唯一标识openID
4. 商家服务器根据openId生成商户订单(包含商户信息)
5. 商家服务器发送请求调用统一下单API获取预支付订单信息
6. 商家对预支付信息签名加密后返回给小程序客户端
7. 用户确认支付（鉴权调起支付）
8. 微信服务器返回支付结果给小程序客户端
9. 微信服务器推送支付结果给商家服务器端

### 面试问题

- Iphone6的dpr为多少？Iphone6Plus比Iphone6显示图像清晰吗？

  视网膜屏幕是分辨率超过人眼识别极限的高分辨率屏幕，Iphone4的dpr = 2; 人类肉眼分辨的极限

- 生命周期函数实际测试和官网描述有差

- wx.setStorage()，单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB

- 性能优化

  一个页面一次只有一个video标签，其余的使用image代替

- 请求相关

  小程序为了安全起见只支持Https请求

  wx.request最大并发限制10个（浏览器最大并发数是6个）

- 如何使用组件

  先创建组件，在对应的json文件下设置component: true

  到使用组件页面的json文件中，注册组件填写相应的路径

- 使用npm包

  下载后，勾选使用npm模块，再构建npm，会将node_modules中的包打包到miniprogram_npm中

- 分包相关

  分包后可解决2M限制，并且能分包加载内容，提高性能

  分包后单个包的体积不能大于2M，所有包的体积不能大于16M

  1. 常规分包

     加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容

     分包的页面可以访问主包的文件，数据，图片等资源

  2. 独立分包

     独立分包可单独访问分包的内容，不需要下载主包

     独立分包不能依赖主包或者其他包的内容

     通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包，如：临时加的广告页 || 活动页

  3. 分包预下载

     在加载当前包的时候可以设置预下载其他的包

     缩短用户等待时间，提高用户体验

## 15. 熟练使用commonjs和es6模块化规范进行开发；

## 16. 对页面进行懒加载、限制前台页面不必要请求、节流防抖等优化方案；

## 17. 了解TypeScript语法，接口，类，泛型等；

### 接口

接口是对象的状态(属性)和行为(方法)的抽象(描述)

### 类

类类型：类的类型，通过接口来实现

### 泛型

在定义函数，接口或者类的时候，不预先指定具体的类型，而在使用的时候再指定具体的类型

## 18. 了解Vue3新特性（setup，ref，reactive，新组件等）

### render函数和template有什么区别

- 相同点：都叫类编译器
- render是template的下一步
  - render(h)=>h相当于creareElement





## 19. 了解webpack配置基本设置，掌握tree shaking、代码分割等优化方案；

## 20. 补充

#### - 免登录

1. 第一次登录的时候，前端调后端的登陆接口，发送用户名和密码

2. 后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token

3. 前端拿到`token`，将`token`存储到`localStorage`和`vuex`中，并跳转路由页面

4. 前端每次跳转路由，定义一个全局前置守卫，判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面

5. 每次调后端接口，都要在请求头中加token

6. 后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401

7. 如果前端拿到状态码为401，就清除token信息并跳转到登录页面

8. 调取登录接口成功，会在回调函数中将token存储到localStorage和vuex中

### - 自定义指令

**bind**：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置

- 触发情况：一般只在内存中就触发了

**inserted**：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。

**update**：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。

**componentUpdated**：指令所在组件的 VNode 及其子 VNode 全部更新后调用。

**unbind**：只调用一次，指令与元素解绑时调用。

简化写法同时触发了bind和update钩子函数，也就是直接写函数的情况下

**el**：绑定当前元素的dom

**binding**：是一个对象，内部保存很多关于指令的属性

- value：指令绑定的值
- expression：原样输出
- oldvalue：仅在update和componentUpdate中生效

**vnode**

**oldVnode**

### - Vue的性能优化

对象层级不要过深，否则性能就会差

不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）

v-if 和 v-show 区分使用场景

computed 和 watch 区分使用场景

v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if

大数据列表和表格性能优化-虚拟列表/虚拟表格

防止内部泄漏，组件销毁后把全局变量和事件销毁

图片懒加载

路由懒加载

第三方插件的按需引入

适当采用 keep-alive 缓存组件

防抖、节流运用

服务端渲染 SSR or 预渲染

### 深拷贝

### 1. 自定义深拷贝

```js
// 首先定义一个数据类型的检测
function checkType(arg){
	return Object.prototype.toString.call(arg).slice(8,-1).toLowerCase()
}
// 定义一个深拷贝的函数
function deepClone(obj){
	// 首先判断是否是一个对象
  if(checkType(obj) === 'object'){
    // 新建一个对象
    var newObj = {}
  }else if(Array.isArray(obj)){
    // 新建一个数组
    var newObj = []       
  }else{
  	// 如果是其他的数据类型，则直接返回
    return obj
  }
  // 进行拷贝
  for(let key in obj){
    newObj[key] = deepClone(obj[key])
  }
  // 返回对象
  return newObj
}
```

#### 2. 利用json串

```js
JSON.parse(JSON.stringify(obj))
```

- 缺点：方法/函数会丢失

### - 取消请求

在axios中，可以通过axios内部提供的cancelToken来取消请求

实现：

	- 在当前页面发送请求的时候，在axios发送请求的时候，在配置项cancelToken中：new axios.cancelToken((c)=>{})，回调函数中会自动传入一个当前请求的标识C，以数组的形式将当前请求保存到vuex中，
	- 然后在跳转页面的时候，通过全局前置路由来判断是否跳转了路由，如果发生了跳转页面，则遍历数组中的请求，直接进行C()调用即可取消请求



### - Vue打包优化

1. 

### - 权限控制

总：

- 首先权限控制主要就是解决两个问题

  - 获取到用户有哪些权限

    - 在用户登录的时候，会返回用户的权限路由

  - 让用户不能访问没有权限的页面

    1. 让用户的菜单页面只能显示用户权限路由中的页面

       这里一般会有两种方法：

       1. 注册所有的路由，然后在显示的时候只显示用户权限路由相关的页面，为了防止用户自己在地址栏输入地址进入没有权限的路由，在全局前置守卫中进行判断
       2. 另外一种方法是：刚开始只定义一个常量路由，然后通过addRoutes动态注册用户的权限路由，

    2. 主要用的是第二种方法

思路：

- 在定义路由的时候，会首先创建一个常量路由，一般会包含登录/注册/首页/404，还有一个异步路由（包含所有的权限路由）

	- 登录成功，在后台返回的数据中，会包含该用户的路由权限，路由权限是一个数组，数组中每一项都是该用户拥有的路由权限的名称；
	- 然后通过权限路由名称过滤异步路由
 - 首先判断异步路由中的一级路由是否包含在权限路由中，如果包含在权限路由中
    - 再判断该路由是否拥有子路由，如果没有自路由则直接将该路由返回
      	- 如果有子路由，在对子路由进行递归过滤
      	- 过滤完，如果该路由没有权限子路由，则该路由也将会被过滤掉
- 过滤之后得到用户自己的权限路由表
- 然后将常量路由表和过滤后的用户路由进行合并并且保存在state.routes中，有什么用？，用于遍历生成菜单，并且判断是否有hidden为true，有hidden为true则不会被显示出来
  - 用于遍历生成路由菜单，判断是否拥有child属性或者只有一个chidl属性
  - el-menu：最外面的菜单容器
  - el-menu-item：生成一级菜单
  - el-submenu：生成二级菜单
- 然后调用router.addRoutes将权限路由添加到路由器

### - 按钮权限值

#### 1. 方法一：自定义指令

定义一个全局自定义指令permission，在inserted中判断当前呢只定义指令的value值是否在用户的按钮权限中，如果在，则将该按钮移除，

然后在按钮中添加该自定义指令，并且传入该按钮的权限值

#### 2. 方法二：v-if

定义一个方法，该方法定义一个形参，使用数组的includes方法判断传入该函数的按钮是否在用户的按钮权限中，将该函数添加为Vue的原型上的方法，然后在按钮是使用v-if判断该函数的返回值。

### webpack优化

#### 1. 配置webpack

1. 初始化webpack

   `npm add init -y`

2. 下载依赖，开发依赖

   `yarn add webpack@4 webpack-cli@3 -D`

3. 配置文件

   `webpack.config.js`

4. 五大核心概念

   1. entry：入口文件
   2. output：出口文件
   3. lodaer：加载器
   4. plugins：插件
   5. mode：

#### 2. 优化

##### - 数摇

- 将环境设置为开发模式，然后使用es6模块化导入模块，就能减少打包的代码体积

##### - 代码分割

- 问题：如果多个文件共同依赖于一个文件，该文件内容会被两个同时打包，最终导致项目js文件体积过大，影响首次渲染速度
- 实现：
  - 多入口配置：
    - 在webpack.config.js中，配置optimization.splitChunk.chunks = all
    - 问题，miniSize默认值为：30000（30KB），自定义miniSize
  - 单入口配置
    - 在webpack中使用import函数引入的文件会被单独切割为一个js文件，等浏览器执行到import函数的时候才会发送请求获取当前js文件
    - 使用场景：组件懒加载，可以减小index.js的文件大小，提高首屏渲染速度
    - 懒加载的使用：相对于没有使用懒加载之前，懒加载之后，后续页面的渲染速度会变慢。

##### - 缓存配合：后端如果使用强缓存

缓存的时候使用contentHash

强缓存：通过cache-control：maxAge：指定缓存的时间

协商缓存：每一次都会发送Etag，last-modify发送给服务器，如果请求对比的

- hash模式，每一次打包编译，所有文件都会被重新打包
- chunkHash：每一个入口重新打包编译都会创建一个唯一值
- contentHash：每一个文件重新打包会创建一个唯一值，

##### - PWA

- 离线缓存
- 使用workbox-webpack-plugin进行离线缓存
- 在入口文件中注册Seevice-Workes
- 然后就会把整个网页缓存到cache-storage中

##### - 多进程打包

- webpack默认单进程打包
- 使用thread-loader配置多进程打包
- 多耗费600ms
- 进程与进程之间通信也会耗费时间

### - 项目相关

#### 1. axios二次封装

- 原生的axios请求会存在一下问题

  1. 请求地址每次都需要重新完整的输入
  2. 每个公共的参数也需要手动输入
  3. 不能直接得到返回的数据，需要res.data才能拿到需要的数据
  4. 响应返回的状态码只能代表响应成功，不能代表功能成功，
  5. 错误提示不够友好
  6. 没有进度条显示：NProgress.start/NProgress.end

- 解决：进行axios的二次封装

  1. 定义公共的请求路径

     1. ```js
        const request = axios.create({
        // 公共的请求路径
          baseUrl:"",
        // 定义超时时间
          timeout:10000, // 默认为60000ms
        })
        ```

  2. 定义请求的公共参数：在请求拦截器中进行发送

     1. 在请求拦截器中定义响应头的公共参数

        1. 发送用户的唯一id
        2. 发送用户的token

        ```js
        // 定义响应拦截器
        request.interceptors.request.use(
          // 成功的回调函数
          (config)=>{
            // 定义唯一id 需要使用 uuid生成唯一id 
            config.headers.userTempId = "xxx";
            config.headers.token = "xxx";
          }，
          // 失败的回调函数一般不需要指定
        )
        ```

  3. 直接返回数据

     1. 定义响应拦截器
     2. 只有状态码为200才能算是成功
     3. 成功之后直接返回响应的数据
     4. 定义更好的错误提示
        1. 响应失败的错误提示码在error.response.status中
        2. 请求失败的错误提示码在error.message中，可以利用字符串的includes进行判断是否存在

     ```js
     request.interceptors.response.use(
       // 成功响应的回调函数
     	response=>{
       	// 判断后台返回的数据是否是200
         if(response.data.code === 200){
           // 返回成功数据
         	return response.data.data
         }
         // 返回失败的数据
         return Promise.reject(response.data.message)
       },
       error=>{
       	// 判断是否是响应失败,响应失败在response中，如果没有数据，说明不是响应失败
         if(error.response){
         	// 失败的结果，定义一个错误状态码对应的错误情况
           return Promise.reject(errorObj[error.response.status]||"未知错误")
         }
         // 如果不是响应失败，可能是请求失败，请求失败的结果会在error.message中，数据类型是字符串
         if(error.message.includes("newwork")){
         	return Promise.reject("网络错误")
         }
         return Promise.reject("未知错误")
       }
     )
     ```

#### 2. 路由传参数问题

##### - query和params传参数

1. 都可以通过在路由中传递参数

2. query传参

   1. 问号后面的可以被称为query参数
   2. query参数可以直接在路由的后面进行传递参数，而
   3. 编程式导航也可以传递
   4. 声明式导航也可以
   5. 即可以使用name的方式，也可以使用path的方式进行传递

3. params传参

   1. 作为路由的一部分的参数叫做params参数
   2. 原则上params参数需要在路由指定占位符
      1. 占位符：.../:id：表示必须传入一个id的params参数
      2. 占位符：.../:id?：表示传入的params参数id是可选的
   3. 编程式导航可以指定
   4. 声明式导航也可以
   5. 在以对象的形式传递参数的时候，必须只能使用name的方式，而不能使用path

4. 也可以传递props参数

   1. 需要在路由中定义函数，并且返回一个对象，该对象就可以被添加到props中

   ```js
   props($route)=>({...$route.query,...$route.params})
   ```

5. 问题：

   1. 当如果传递parmas参数的时候，如果参数是一个""的时候，回跳转到/，

      1. 解决：不指定该参数，或者指定一个undefined

   2. 当通过编程式导航跳转到当前路由（参数不变的情况下），会抛出NavigationDuplicated的警告错误

      1. 问题：vue-router3.1.0之后，push()引入了promise的语法，如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调，并且内部会判断如果要跳转的路由路径与当前路径一样，就会抛出一个失败的promise，

      2. 解决：

         1. 在push的时候，传入回调函数来进行处理：第一个为成功的回调函数，第二个为失败的回调函数

         2. 在push的时候使用catch来处理错误

         3. 高级方法：重写push/replace方法，在定义vue-router的地方进行重写

            ```js
            // 导入vue-router
            import VueRouter from "vue-router"
            // 缓存push函数
            const originPush = VueRouter.prototype.push
            // 重写push方式
            VueRouter.protype.push = function(location,onComplete,onAbort){
              // 如果传递了回调
              if(onComplete || onAbort){
                // 调用push方法
                originPush.call(this,location,onComplete,onAbort)
              }else{
                return originPush.call(this,location).catch(()=>{console.log("error callback")})
              }
            }
            ```

#### 3. lodash按需引入

- 防抖节流的使用
  - 防抖：如果同一个事件在指定间隔的时间内多次触发，则只执行最后一次
  - 节流：如果同一个事件在一段时间内多次触发，指定时间触发的间隔

#### 4. 使用dataset进行数据的传递

- dataset是H5新增的自定义属性方式
- 在标签上使用data-作为前缀
- 在js中通过dataset获取到自定义属性

### 4. swiper

- swiper对象，必须在列表数据生成dom对象之后才能创建--->在mounted上进行创建，
- 原则：就是依赖的数据以及swiper结构生成dom节点的时候创建
  - 解决：
    - 在swiper的html结构中使用v-if，当获取到数据的时候再返回true
    - 在mounted上创建
    - 使用watch+nextTick进行创建，
    - 使用watch+nextTick+deep进行创建
- new Swiper如果传入的是一个类选择器的话，多个new Swiper只会生成一个数组，每一个Swiper是数组中的一个对象，所以在进行处理的时候最好就是使用refs

#### 5. 自定义分页器

- 自定义分页器的时候，首先肯定需要接收一个totals，pageSize，pageSizes，currentPage，pageCount：显示的按钮数量
- 思路：一般情况下，显示的按钮书否是奇数，为了对称
  - 按钮显示的时候，会显示第一页，最后一页，中间的页数会以当前页作为中间对称显示
  - 已知的肯定是当前页，需要根据当前页来动态的显示中间部分的第一个按钮和最后一个按钮
  - 计算公式：start = currentPage - （pageCount-3）/2；end = start +（pageCount-3）
  - 特殊情况：当start小于2的时候，必须强行指定为2，当end大于最大页面-1强制指定为最大页面-1
  - 当总页面小于指定的页面的时候
    - 当页面大于2的时候
    - 页面等于2
    - 页面小于2

### vue后台项目

- 用户权限管理
- 按钮权限管理

- 实现element-ui的按需引入
- 使用深度选择器修改element-ui的样式
- 动态显示输入框自动获取焦点
- el-table在获取该行的数据的时候，使用到插槽，

### 面试

### React

#### 生命周期钩子函数

- 挂载阶段（初始化阶段）
  - constructor
  - componentWillMount
  - render 
  - componentDidMount
- 更新阶段：父组件render的时候会触发
  - componentWillReceiveProps：接收props
  - shouldComponentUpdate：组件自身this.setState会触发，这个钩子返回true，则才回触发更新
  - componentWillUpdate：当触发forceUpdate的时候会触发这个钩子
  - render
  - componentDidUpdate
- 卸载阶段
  - componentWillUnmount
- 用的最多的就是componentDidMount和componentWillUnmount
- 即将废弃：
  - componentWillMount
  - componentWillReceiveProps
  - componentWillUpdate
- 新增的钩子
  - getDerivedStateFromProps
    - 必须是类组件的静态方法
    - 取代componentWillMount、componetnWillUpdate
    - 接收的参数
      - 第一个：props
      - 第二个：改变之后的state状态
    - 返回值：
      - 返回的是一个对象或者是null
      - 返回的对象中的内容会被添加到state中
  - getSnapshotBeforeUpdate
    - 在render()和componentDidUpdate之间进行操作
    - return的值会在componentDidUpdate中接收

### React路由

- 路由组件

  - BrowserRouter：包住Route和Link/NavLink，一般只需要包住整个项目
  - Link：用于匹配路由
  - NavLink：用于匹配路由，
  - Route：用于匹配路由组件
    - 普通组件和路由组件的区别：
      - 路由组件的三大特性：
        - history：操作历史记录的方法
        - location：pathname：路由地址，search：传递的查询字符串，state：编程式导航传入的第二个参数state
        - match：匹配信息，path，params
  - Switch：匹配到一个Route便终止匹配
  - Redirect：to，重定向

- 路由懒加载的话，需要Suspense来定义loading

  `<Suspense fallback={<div>Loading...</div>}></Suspense`

- 路由传参数

  - 声明式导航
    - NavLink to={path:,state} => 接受：location.state
    - NavLink to="/home/id" => Route配合：Route path="/home/:id" => 接受：match.params
    - NavLink to="/home?key1=val1&key2=val2"  => 接受：location.search
  - 编程式导航

### Redux

### - 面试补充

#### 1. 数组的ES6方法

- arr.find：需要传入一个回调
- arr.findIndex：需要传入一个回调
- arr.fll：value，start，end
- arr.includes：（val），代替arr.indexOf，indexOf会返回下标
- Array.from：将伪数组转换为真数组
- Array.of：创建数组

#### 2. 字符串的ES6方法

- str.startWidth
- str.endWith
- str.includes
- str.repeat

### - 自定义组件的步骤

- 实现静态组件: 模板/样式写好
- 设计从外部接收的数据: props
- 设计内部的数据: data
- 设计基于props和data的计算属性数据: computed
- 根据props和data数据和computed进行动态显示，
- 更新数据, 更新界面, 通知父组件（watch+自定义事件）

### - 在项目中遇到过什么难点

- 在搜索页面的时候，如果传入一个空的params参数会直接跳转到`/`
- swiper问题
- push到相同地址的问题 NavigationDuplicated 的问题
- 二级路由刷行`reset`失效的问题
  - 修改为绝对路径
  - 但是`history`模式下，以`/`开头的嵌套路径会被当作根路径，所以使用`“./”`引入文件，就会找不到文件了，因为文件本身就是在项目根目录下的，并不在嵌套路径这个目录下。
- axios二次封装
- 当从搜索页跳转到详情页的时候，详情页的滚动条位置会和在搜索页的位置一样
  - `scrollBehavior`
- 渲染多级别数据的时候会抛出错误：比如a.b.c，三级数据
  - 方法：v-if
  - 进行初始化
  - 计算属性进行判断

### 浏览器，小程序和node中的js有什么区别

- **浏览器中JavaScript**的实现由以下三个部分组成：
  - 核心（ECMAScript）
  - 文档对象模型(DOM)
  - 浏览器对象模型(BOM)
- **NodeJS中JavaScript**的实现由以下三个部分组成：
  - 核心（ECMAScript）
  - NPM：包管理系统
  - Native：node原生模块，做一些js做不了的事情，比如文件的操作，数据库等等等
- **微信小程序中 JavaScript**的实现由以下三个部分组成
  - 核心（ECMAScript）
  - 小程序框架：
  - 小程序API：app，wx等

### 苹果树面试
commonJs和ES6模块化语法的区别

为什么需要用ts而不用JS（ts的好处是什么）
扁平化数组转树形结构数组

### 小鹅通面试

- 一上来就问请介绍你觉得做的做好的项目

- 跨域报错是怎么报错的
- 在

### 蘑菇投面试

- 你在写代码的时候

### 名竹科技

- 设计模式需要了解
- promise用的什么设计模式
- vue生命周期的触发顺序

### 爱德博

- map
- 数组扁平化
- map手写
- vue中哪些地方用到了发布订阅模式
