

**默认插槽**

	子组件<slot></slot>接收并写在需要放置的位置，父组件在引入的子组件标签内写内容

**命名插槽**

	在父组件中引入的每个子组件外部套一个<template slot="名">标签
	
	子组件中在<slot name="名">接受父组件传过来的内容

**keep-alive的作用？**
	<keep-alive include=" 组件名">  : 缓存该组件内的数据，防止跳转卸载

​	kepp-alive组件用来做缓存的,保证组件不会被销毁，它是一个抽象组件(自身不会渲染一个DOM元素，也不会出现在父组件链中)
​	可以在这个组件上定义3个属性，分别是：

     		1. include ==> 缓存白名单,标识哪些组件可以缓存
              		2. exclude ==> 缓存黑名单,标识哪些组件不可以被缓存
                      		3. max ==> 定义可以缓存组件的最大数量，当超出时，会把第一个被缓存的组件干掉，把当前缓存的组件放入

**webpack的核心概念**
	Entry (ˈentri)：入口，Webpack进行打包的起始点(文件)
	Output：出口，webpack编译打包生成的bundle(打包文件)
	Loader：模块加载(转换)器，将非js、非json模块包装成webpack能理解的js模块
	Plugin (plʌgɪn)：插件，在 Webpack 构建流程中的特定时机插入具有特定功能的代码
	Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件, 如果是其它类型文件利用对应的loader转换为js模块



**vue中做过的性能优化**

 1. 不希望组件被重新渲染影响使用体验，可以使用 keep-alive 实现页面缓存

 2. 防抖节流。解决触发频率高导致浏览器响应速度跟不上。

 3. 第三方UI库按需引入，减少项目体积。

 4. 图片懒加载跟路由懒加载

    

**form 表单怎么阻止重复提交？**

1. 点击后可以让button失效，

  2. session方式，当表单页面被请求时，生成一个token，存在**session**中，同时放在表单的**隐藏域**里。接受处理表单数据时，检查token是否存在，且表单中和session中的token相同，那么提交表单，并立即从session中删除它。下次请求过来，如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，属于重复提交。
  3. Axios使用cancel token取消请求

**懒加载遇到大量数据加载不出来怎么优化？**
	改变图片的质量，分段获取数据

**UI怎么给图片给你？**
	通过“摹客”

**组件路由两种方式了解吗?**
	**声明式** 和 **编程式导航**
	声明式：通过标签形式跳转。route-link     to="地址"	active-class="active":点击当前高亮        <router-view>:指定展示的位置。

​	编程式导航：

	1. router.push ()：跳转到指定url路径，并向history栈中添加一个记录，点击后退会返回到上一个页面
	2. router.replace() ：跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)
	3. router.go(n）：对应浏览器的前进，后退，跳转操作。n为-2就倒退2个页面，n为2就向前2个页面。

**VueRouter是什么,作用, 单页面应用优缺点.**
	vueRouter是用来开发单页面应用的，管理多个配置路由

​	作用：用于管理多个路由间的跳转

​	优点：用户体验好，切换快，不需要重新加载页面，对服务器压力较小。		

​	缺点：单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理。

​				初次加载时耗时多。

​				页面复杂度提高。

​				对seo 搜索引擎不友好，因为单页面的话有很多内容没有展现出来，而搜索引擎只擅长对静态资源的抓取和分析。

**说说路由守卫? 应用场景?**
	作用： 对路由跳转进行权限控制
	全局守卫：
		全局前置： 每个路由切换前执行	router.beforeEach((to , from , next){判断条件}
		全局后置 ：路由切换完了执行	router.afterEach((to , from ){判断条件}	一般用来修改网页的title
	独享路由守卫：只对单个路由的权限控制	router.beforEnter((to , from ,next ){判断条件}
	组件路由守卫：组件内部写守卫
		进入守卫，进入该组件时被调用	beforeRouteEnter（to , from , next ）{}
		离开守卫 ，离开该组件时被调用	beforeRouteLeave（to , from , next ）{}

**data中初始一个的对象只有一个属性,后续自行添加的属性不是响应式的怎么解决?**  Vue.Set

​	Vue 通过 Object.defineProperty() 的方式实现对数据的监听和响应式，导致的后来新增的属性不会被监听到！在实例创建后，如果需要追加新属性可以通过 Vue 官方提供的 Vue.set() 方法，保证新属性的数据响应式。

**Vue的异步渲染,  直接给某元素的模板标签进行赋值,DOM无法直接渲染,数据是同步的,渲染是异步的.**  $nextTick

Vue中怎么将后台的数据展示到视图层的,其中都用了哪些方法?

需求: 后台写了一个接口,前台有两个不同的域名, 想登录同一个系统. 不同的域名,使用同一个代码, 使用不同的接口.   通常只配置一个域,不管是在生产环境还是在开发环境下. 一套代码,两个域名都要指向一个项目,但是拿到的数据是通过两个不同的域名拿到的不同的, 共同的代码去解析获取不同的后台的数据. 根据这个域名去请求不同的端口的数据    (这个是实际问道的问题,意思就是一套代码多个域名,请求渲染不同的数据)

**vue的事件修饰符有哪些？**

​	.stop 阻止事件冒泡

​	.prevent 阻止默认行为

​	.once 事件只会触发一次

​	.capture:使用事件的捕获模式

​	.self:只有event.target是当前操作的元素时才触发事件

​	.passive:事件的默认行为立即执行，无需等待事件回调执行完毕。





**——JS——**

封装过什么原生写的逻辑?

深拷贝和浅拷贝,深拷贝实现方法知道几种?

数组内容复杂如何进行解构? 有对象,层级多

let,const,var的区别

数组排序,数组去重

JSON实现原理

防抖节流原理,如果手动封装如何实现?

**谈谈闭包：**

​	1.什么时候产生闭包？内部函数执行函数定义的时候产生闭包

​	2.如何产生闭包？内部函数引用外部函数的变量，外部函数被调用

​	3.闭包的坏处？会导致额外的内存消耗（内存泄漏）

​	4.闭包的好处?延长局部变量的生命周期

​	5.解决副作用？及时释放闭包，将无用的闭包及时释放，让垃圾回收机制回收

​	6.什么是闭包？本该随着外层函数执行结束销毁的变量对象，被内部函数引用，导致意外存活。




​	
**promise是什么,作用, 所有的方法**

	* 什么是promise:
	  - 一个异步编程的解决方案，将异步操作以同步的形式表达出来，避免回调地狱方式的书写。

  promise对象
      - Promise是一个构造函数，需要实例化调用，得到一个实例化的promise对象
            - Promise对象上有静态方法：all、allSettled、any、race、reject、resolve。
            - Promise原型对象上有：catch、finally、then

  promise的使用
      - promise接受一个函数作为参数,把异步代码写入这个函数中即可
            - promise是处理异步代码的，但是本身是同步执行的

  promise的函数参数的两个参数：
      - resolve:成功回调函数，当异步处理成功了，则直接调用成功回调函数
            - reject:失败回调函数，当异步处理失败了，则直接调用失败回调函数
            - 无论调用resolve还是reject，都会把结果返回给promise对象
                  - resolve和reject方法调用的时候，可以传递参数，把成功的结果或失败的报错信息返回给promise对象接收

  promise实例化对象：
      -[[PromiseState]]：promise状态
          - pending:初始化状态，异步代码正在执行中，或者开发人员没有调用resolve或reject
                    - resolved/fulfilled:成功状态，只要在promise中调用了resolve即可返回成功状态
                    - rejected:失败状态，当promise调用了reject()方法的时候，返回失败状态

  - [[PromiseResult]]:promise内部成功或失败的时候，调用resolve或reject方法，给的参数

谈一谈promise的原型方法
  promise.then(): 
      - 可以捕获promise对象的成功状态，然后再执行下一步回调函数
            - then方法接受一个函数作为参数
            - then的返回值
          - 如果穿透了(then中不书写回调函数)，则一定返回成功
          - 如果then内部出现错误信息，则返回失败promise，值为错误信息
          - 其他情况只要看then回调函数return的promise对象即可
            - then回调函数的参数 就是调用then的成功promise对象的promiseResulte值

  promise.catch():
      - 可以捕获promise对象的失败状态，然后对错误处理
      - catch的返回值：
          - 如果穿透了(catch中不书写回调函数)，则一定返回失败
          - 如果catch内部出现错误信息，则返回失败promise，值为错误信息
          - 其他情况只要看catch回调函数return的promise对象即可
      - catch回调函数的参数 就是调用catch的失败promise对象的promiseResulte值

  promise.finally():
      - 可以捕获成功或失败的promise状态，一般作为整个promise异步操作的最后异步
    promise.then和catch如果不书写任何参数，则会直接把调用then或catch的promise对象穿透过来并返回
    
    
    

**async...await**	

​	await之后的代码，会被自动放在.then内部

​	await之后可以书写任何内容，但是如果是非promise对象，就失去async的意义了

如果想要实现类似catch效果，可以在async函数内部使用try{}cath (error){...},它会被自动编译成.catch

**try {...} cath (error){...}**  ： 一般用作不在乎这个是否错误，正常往下运行

try {...} : 尝试着解析，如果没问题就正常运行

cath (error){...} : 如果出错，就提示出来



**谈谈原型（尽可能多说）**

- 总
  - 我们说原型指的是两个原型属性：
    - `prototype`，我们叫做显示原型属性
    - `__proto__`, 我们叫做隐式原型属性
- 分
  - 除了箭头函数以外的其他函数都有显示原型属性，指向它的原型对象，原型对象上有constructor指向函数本身
  - 构造函数通过new出来的实例化对象，它的__porto__指向其构造函数的原型对象。
  - Function可以看作是new自己产生的，所以Function的隐式原型指向Function的显示原型，他们的值指向同一个对象
    - `Object.prototype.__proto__ === null` 原型链的尽头

  - 数组都是new Array产生的，Array原型对象上filter、map、reduce等方法，所以所有数组的实例都能通过隐式原型继承得到这些方法
  - 函数都是new Function产生的，Function原型对象上call、apply、bind等方法，所以所有函数的实例都能通过隐式原型继承得到这些方法

  - 原型链
    - 作用：对象查找属性的规则
    - 规则：
      - 先在自身属性中查找，找到就返回值
      - 沿着隐式原型属性一层层查找，找到就返回值
      - 最后来到`Object.prototype.__proto__`, 它的值是null，就不找到了，返回值是undefined

- 总
  - 作用：用来继承的（构造函数的方法，复用代码）
  - 开发应用：
    - Vue中全局事件总线
    - Vue的原型上添加全局方法，从而所有实例都能使用

**箭头函数所有知识点**
	箭头函数没有自己的this，箭头函数内部的this不是调用时指向的对象，而是定义时所在函数的this指向
	箭头函数没有arguments ,只能使用rest参数
	箭头函数不能当构造函数使用，也就是不能使用new关键字调用


**改变原数组的方法：**
		shift：将第一个元素删除并且返回删除元素，空即为undefine
		unshift：向数组开头添加元素，并返回新的长度
		pop：删除最后一个并返回删除的元素
		push：向数组末尾添加元素，并返回新的长度
		reverse：颠倒数组顺序
		sort：对数组排序
		splice:splice(start,length,item)删，增，替换数组元素，返回被删除数组，无删除则不返回

**不改变原数组的方法：**
		join：将数组中所有元素以参数作为分隔符放入一个字符
		slice：slice(start,end)，返回选定元素
		reduce ： 累加器
		map , filter , forEach , some , every , 等不改变原数组

​		concat: 数组中新增元素，创建一个新副本

**ES6+常用的语法有哪些：**

​	const与let、箭头函数、rest接收、扩展运算符、模板字符串、模块化语法（export、import）


**继承几种方法？**

原型链继承：
构造继承：复制父类的实例属性给子类。
实例继承：为父类实例添加新特性，作为子类实例返回。
拷贝继承:
组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类的原型，实现函数复用。



——小程序——

小程序的生命周期：
	    进入：

1. onLoad(页面加载,类似于created)

 2. onShow(页面显示,类似于activated)

 3. onReady(页面初次渲染完成,类似于mounted)

    离开：

 4. onHide(页面隐藏,类似于deactivated)

 5. onunLoad(页面初次渲染完成,类似于mounted)

    

**小程序的http请求**： 通过wx.request向https发送请求，没有Ajax请求



小程序的路由跳转：

1. **声明式导航**

   1. navigator组件(类似于router-link)

2. **编程式导航**

   1. wx.navigateTo	：**保留**当前页面实例，页面栈不能超过**10层**,旧版中不超过5层（离开当前页面时会触发	onHide，回到当前页面时会触发onShow,不会触发onLoad和onReady）

   2. wx.redirectTo	：**关闭**当前页面实例。（离开当前页面时会触发onUnload，如果想要再次显示该页面,需要重新执行三个进入钩子函数）

   3. url既可以是相对路径,也可以是绝对路径,相对路径参考当前js文件路径

      

**小程序的优化有哪些？**

 	1. 剔除无用的代码逻辑
 	2. 组件和逻辑的复用，较少重复代码
 	3. 分包加载，启动时先下载主包，启用分包减少下载时间 
 	4. 分屏渲染： 先渲染可视区域内容，然后再渲染非可视区域内容或者滚动到视野范围内再渲染。



——h5——

- storage ,  cookie , session  基本必问
  cookie存放于客户端，session存放于服务器端。
  cookie一般用来存放不敏感的信息，敏感的信息用session存储，比如用户的登录信息

- webworker 很少问 
  JavaScript 语言采用的是单线程模型，Web Worker 的作用，就是为 JavaScript 创造多线程环境，
  允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后
  台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。

**event  loop? 事件轮询机制**

​	先执行同步代码》再执行微任务》	微任务执行完后GUI线程渲染界面》再执行宏任务》每执行完宏任务就会去询问有没有微任务，没有微任务就继续宏任务 

​	一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。
​	

——css ——

  **水平垂直居中的方法知道几种?** 
	margin：0 auto;
	display: flex;   justify-content: center;  align-items: center;
	position: absolute;  left: 50%;  top: 50%;  transform: translate(-50%,-50%);

 

 标准盒模型和怪异盒模型的区别？
	主要区别是对于宽高的定义不同。
	标准盒模型：设置的宽度就等于内容的宽度
	怪异盒模型：宽度=内容宽度+border宽度+padding宽度	

Vue用的什么模式？
	静态路由，做后台权限管理的时候用到过动态路由。

**封装过的组件有哪些？**商品展示，优惠券，倒计时，input框，页面的头部底部

**有哪些情况会造成内存泄漏？**一个是闭包，一个是定时器没有及时关闭。还有设置了方法没用了及时清理

**封装的模块有哪些？**
	没有封装过，但可以封装



					数据库增删改查？
						新增： insert 音色额妥
						删除：delete
						更改：update 
						查询：select   色赖科妥

小程序组件怎么传参给页面？

​	data-

**HTMl的组成？**head,body

如何理解MVC与MVVM？

​	MVC是单向数据流；主要是数据层到视图层的渲染，如果视图层想改变数据，那么需要手动去调用监听视图层的数据修改。

​	MVVM是双向数据流；MVVM比MVC效率更高，因为底层源码就已经封装好了



**v-if与v-show区别?** v-if是从dom树移除，而v-show是使用dispaly:none

**组件中data为什么是一个函数?**

组件中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了。new Vue的时候data可以写成对象，因为产生的是一份实例，多次new Vue实例上的数据不会被共享



vue事件绑定原理

**虚拟DOM和key属性的作用**：为了复用之前的数据而提高渲染速度，只修改或者增加元素不影响其他的元素渲染。

**在哪个生命周期初始渲染?**

​	beforemount之前会解析模板，生成虚拟DOM，before mount之后将虚拟DOM转为真实DOM，并渲染。

​	所以在before mount之后mounted之前初始渲染。在mounted之后所有的渲染完成，可以操作数据。

**怎么解决下拉加载卡顿BUG?** 看情况，如果是数据过多引起的话可以分段获取数据

**小程序单页面跳转最大的层数,达到后怎么处理的?**最大页面10个，到达10层了只能由redirectTo不保存当前页跳转

**vue组件生命周期调用顺序**

​	初始化挂载时:

1. 调用父组件的beforeCreate函数

2. 调用父组件的created函数

3. 调用父组件的beforeMount函数

4. 调用子组件的beforeCreate函数

5. 调用子组件的created函数

6. 调用子组件的beforeMount函数

7. 调用子组件的mounted函数

8. 调用父组件的mounted函数

   

**vue2父子组件通信**： props

**跨级组件通信** ：全局事件总线，VUEX，插槽：

**全局事件总线：**

​	1.首先需要安装全局事件总线：new Vue后面 beforeCreate(){Vue.prototype.$bus=this}

​	2.分享的组件通过$bus.$emit()，接收方用$bus.$on()

全局事件总线

**SSR（服务器端渲染）**
服务端渲染就是先向后端服务器请求数据,然后生成完整首屏html返回给浏览器, 服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML,网络爬虫可以抓取到完整的页面信息,SSR另一个很大的作用是加速首屏渲染,因为无需等待所有的JavaScript都完成下载并执行,才显示服务端渲染的标记,所以用户会更快地看到完整渲染的页面





产品经理对接需求 ，画图，RP图，项目经理评估合理，需求宣讲，研发会议实现，

后端给的接口：

1.result : 瑞造妥，布尔值

2.message : 字符串，接口说明

3.code：200

4.deta:数据

**检测数据类型的方法?**
	typeof 操作符返回一个用来表示数据类型的字符串
	instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置.
	Object.prototype.toString.call()

**_深拷贝：**

JSON.parse(JSON.stringify(obj))     **缺点：**函数、正则无法拷贝 		二级以下可以深拷贝

Object.assign()    **优点：**可以拷贝函数，正则        二级以下无法实现深拷贝，为浅拷贝

递归方法实现

**_浅拷贝：**

​	借调赋值

_页面响应优化有哪些方法：路由懒加载，预解析，减少页面的重绘重排

_parms传参如果刷新页面会不会受影响：

_小程序怎么上线的：自己测试OK的话，就点击上传提交，然后微信平台会进行审核，审核通过就可以使用了。

_怎么获取openID：首先要获取用户的codeID,然后再将codeID传给后端，后端根据codeID获取到openID。

_后端给你的接口，你只需要该接口里数据的一部分，其他数据不要，让你批量性的实现默认处理？

​	可以将数据进行过滤

H5语义化标签：aside 、section、article、header、footer、nav

七天免登录：在用户每次登录该网站的时候将用户名与密码保存到cookie，并设置有效时间，在这段时间内再次登录该网站可实现免登录。cookie有效时间到期后将自动删除数据。

 

**css部分**

盒子阴影：box-shadow : 水平距离  垂直距离  模糊距离  阴影尺寸  rgba颜色

文字阴影： text-shadow : 水平 垂直 模糊 颜色

清除浮动：

  		1. clear：both;	在父元素内最后添加div，设置clear:both;
  		2. overflow:hidden;  在父元素添加;
  		3. :after伪元素;
  		4. :after :before双伪元素；

元素的显示与隐藏：

​	1.dispay : none / block; 不占位置

​	2.visibility : hidden / visible ; 占位置

​	3.overflow : hidden ; 溢出隐藏

背景不重复：no-repeat

过渡动画：从一个状态渐渐的过渡到另外一个状态，经常跟：hover配合使用

​	transition : 要过渡的属性 、花费的时间、运动的曲线、何时开始

​	要过渡的属性：宽度，背景颜色，内外边距。也可以时all. 必须填

​	花费的时间：单位时秒S。

​	运动曲线：默认是ease:逐渐慢下来，linear:匀速，ease-in加速，ease-out：减速，ease-in-out:先加速后减速

​	何时开始：默认是0 S，可以设置延迟时间。



**H5新特性：**

​	视频：<video>支持MP4、webM、Ogg，MP4所有浏览器都支持。

​	属性：src="视频地址"

​				autoplay = ”autoplay“视频自动播放。

​				muted = ”muted“ 自动静音播放（谷歌可自动播放）

​				controls = 'controls' 显示播放控件

​				loop="loop" 无限制循环播放

​				poster="图片地址" 显示默认背景图

​				preload 属性可设置是否预先加载

​	width、height 可设置宽高

​		

​	音频：<audio>格式支持：MP3、Ogg、Wav

​		属性：autoplay = "autoplay" 音乐自动播放

​					controls = 'controls' 显示播放控件

​					loop="loop" 无限制循环播放

​					src = "播放的文件地址"

input表单：需在input外层（父元素）添加<form>表单域；属性type="类型值"自动校验

表单属性：required =”required“  表示必须填写内容

​					placeholder = "填写的内容"  占位符

​					autofocus =”autofocus“	光标自动聚焦属性

​					autocomplete = ”on “  用于记录搜索过的记录，输入时展现之前的记录

​					multiple = ”multiple“  可以多选文件提交

​					