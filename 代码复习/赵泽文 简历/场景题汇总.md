1. axios 拦截器使用场景：

   1. **请求拦截器：**在每一个请求路径中都需要添加`“http:localhost:8080/”`，我们可以在设置axios 的默认请求路径。
   2. **请求拦截器：**在访问需要认证身份的后端接口时需要在请求头中添加 token，我们可以在 axios 的前置拦截去统一处理。
   3. **响应拦截器：**如果登录失败，我们是需要弹窗显示错误的，比如验证码错误，用户名或密码不正确等。不仅仅是这个登录接口，所有的接口调用都会有这个情况，所以我们可以做个 axios 的后置拦截，对返回的结果进行分析，如果是异常就直接弹窗显示错误，这样我们就省得每个接口都写一遍了。

   这里说一下 token，一般是在登录完成之后，将用户的 token 通过 localStorage 或者 cookie 存在本地，然后用户每次在进入页面的时候，会首先从本地存储中读取 token，如果 token 存在说明用户已经登陆过，则更新 vuex 中的 token 状态。然后，在每次请求接口的时候，都会在请求的 header 中携带 token，服务器就可以根据你携带的 token 来判断你的登录是否过期，如果没有携带，则说明没有登录过。

2. 使用 axios 拦截器的方法：

   1. 在 src 目录下创建 axios.js 文件。
   2. 在 main.js 中删除原来导入的`import axios from 'axios'`，因为在 axios 中已经引入。

   ```js
   import axios from './axios'
   Vue.prototype.$axios = axios // 全局使用axios库
   ```

   

3. promise.all 应用场景：

   在一个微信小程序项目中，做一个表单的输入内容安全验证，调用的是云函数写的办法，表单有多7个字段需求验证，都是调用的一个 内容安全校验接口，全部验证经过则 能够 进行正常的提交

4. 小程序监听全局变量：

   最近开发的一款商城小程序，客户要求在某些特定需要授权的地方加上全局的授权弹框。我写了一个授权组件，在需要的页面引入（小程序没有全局WXML页面，所以也只能这么挨个引入），授权的条件是，当接口调用返回未登录态时，弹框显示。

   由于未登录态是接口的一个全局的返回 code = -1代表未登录，即当返回-1就要显示弹框,就需要一个全局变量去控制弹框的显示与否。

5. **nextTick**什么场景使用，实现的原理是什么？可以在哪个生命周期使用？
   	什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在 nextTick 所指定的回调函数中执行。
   	作用：在下一次 DOM 更新结束后执行其指定的回调。
   	语法：this.$nextTick(回调函数)。

6. 

