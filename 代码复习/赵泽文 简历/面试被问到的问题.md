1. history 模式怎么配置。

2. vue-router 跳转页面并刷新为什么会闪屏？

   功能：在 vue-router 中，在当前页面中点击当前页面的路由，页面是不会进行刷新的，如何做到点击当前页面并进行刷新呢？

   解决方法：

   1. `this.$router.go(0);`
   2. `location.reload()`

   上两种方法都会出现商品的现象，影响用户体验，如果做到页面刷新不闪屏呢？

   终极解决方案：

   1. 在 App.vue，声明 reload 方法，控制 router-view 的显示或隐藏，从而控制页面的再次加载。(provide /inject )。**祖先组件(provide )会向其所有子孙后代(inject )注入一个依赖**
   2. 在需要的页面 调用方法。

   [博客地址](https://www.cnblogs.com/lovecode3000/p/13871559.html)

3. js 复制对象的方法有哪些？

   1. JSON 方法：JSON对象的深度克隆。方法是先 JSON.stringify() 转为 json 字符串， 再JSON.parse() 转为 json 数组。

      **缺点：**

        1. 如果你的对象里有函数, 函数无法被拷贝下来。
        2. 无法拷贝 copyObj 对象原型链上的属性和方法。

   2. jQuery extend(object) 方法：扩展 jQuery 对象本身，用来在 jQuery 命名空间上增加新函数。

   3. Object.create() 方法：复制对象存在于Object原型prototype中

   4. for 循环遍历法。

      1. 浅拷贝：只是拷贝了基本类型的数据；然而引用类型数据， 只是复制了指针，复制后也是会发生引用。
      2. 深拷贝：深拷贝, 就是遍历那个被拷贝的对象。判断对象里每一项的数据类型。如果不是对象类型, 就直接赋值, 如果是对象类型, 就再次调用递归的方法去赋值。

   5. 原型链继承方法：通过原型来继承父类的公共属性。

   6. Object.assign() 方法：

      ```js
      const ObjA = Object.assign({}, obj)
      ObjA.data = 'a'
      ObjA.info.d = 'b'
      
      const ObjB = Object.assign({}, obj)
      ObjB.data = 'c'
      ObjB.info.d = 'd'
      
      console.log(ObjA)
      console.log(ObjB)
      /* 
      ==========输出==========
      { data: 'a', info: { d: 'd' }, un: undefined, fn: [Function: fn] }
      { data: 'c', info: { d: 'd' }, un: undefined, fn: [Function: fn] }
      */
      ```

      

   [博客地址](https://www.cnblogs.com/hjson/p/10243806.html)

4. js 复制数组的方法有哪些？|| 浅拷贝的方法有哪些？

   1. 扩展运算符(浅拷贝)。

   2. for 循环 (浅拷贝)。

   3. while 循环 (浅拷贝)。

   4. Array.map() (浅拷贝)。

   5. Array.filter() (浅拷贝)。

   6. Array.reduce() (浅拷贝)。

   7. Array.slice() (浅拷贝)。

   8. JSON.parse() & JSON.stringify()(浅拷贝)。

   9. Array.concat() (浅拷贝)。

   10. Array.from() (浅拷贝)。

   11. 直接赋值：

       ```js
       var obj = {
         a: 1,
         b: 2,
       }
       
       var obj1 = obj;
       console.log(obj1); // {a:1, b:2}
       ```

   [博客地址](https://www.cnblogs.com/ld1024/p/10750162.html)

5. 深拷贝的方法有哪些？

   1. 迭代递归法：判断类型 + for ... in 遍历。
   2. jQuery 中 extend() 方法：`jQuery.extend([deep], target, object1, [objectN]);`
   3. lodash 工具库
      - 引入：`import _ from 'lodash'`
      - 使用：`const b=_.cloneDeep(a)`

6. 谈谈你对 iframe 的了解

   `<iframe>` 标签规定一个内联框架。一个内联框架被用来在当前 HTML 文档中嵌入另一个文档（可以是本地 html 页面，也可以是第三方网页）。

   所有的主流浏览器都支持`<iframe>`标签。你可以把提示的文字放到` <iframe>` 和 `</iframe>`里面，这样不支持` <iframe>`的浏览器就会出现提示的文字。

   使用 iframe 是不是一个好的用法（good practice），不能一概而论，但是可以肯定是，现在的大部分网站避免采用这种方式的。

   比较早期的网站使用 iframe，主要是用于导航栏（navigator）。为什么？
   因为一个网站很多页面的导航栏部分是相同的，在避免切换页面的时候重复下载，将导航栏和正文分开在 iframe 中，是一个方便的做法。
   同时带来的不利是，默认情况下，使用了 iframe 的网站的 URL 不会随着页面的变化而变化。
   这就意味着一旦刷新，网站可能又回到首页。
   那么现在的网站是如何解决不同页面使用相同的 navigator 而避免重复编码呢？
   不同后台技术都有自己的方法，比如 ASP 有 SSI，PHP 有 require、require_once 或 include 函数，JSP 也有 include 指令。

   iframe 一直是浏览器标准规范之一，只有很早期的浏览器不支持 iframe，现在几乎已绝迹。
   所以从兼容性上来说，iframe 是没问题的。

   那么现在什么时候会用到 iframe 呢？
   因为 iframe 的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent 的 CSS 或者全局的 JavaScript 的影响。
   典型的，比如所见即所得的网页编辑器（WYSIWYG Online HTML Editor），因为它们需要 reset 自己的 CSS 到自己的标准，而不被 parent CSS 的 override。 

   说到上面一点了，顺便说一下，知乎的这个编辑器不是用 iframe，它使用了一种叫 contentEditable 的属性，用来启用页面元素的编辑，在早期版本 IE 下不支持的。

   正是因为刚刚提到的 iframe 等于新建了一个全新的，不受 parent 影响的页面上下文，所以在一定程度上，类似于沙箱隔离（sandbox）。
   除此之外，如果有可以不用 iframe 来解决的问题，还是避免使用 iframe。
   替代方案一般就是动态语言的 include 机制、ajax 动态填充内容，以及以后会普及的 contentEditable。

7. 谈一谈 http 缓存：

   **定义：**http 缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。

   常见的 http 缓存只能缓存**get**请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指 GET 请求。http 缓存都是从第二次请求开始的。

   **分类：**

   1. 根据是否需要重新向服务器发起请求来分类，可分为**强制缓存**和**协商缓存**。

   2. 根据是否可以被单个或者多个用户使用来分类，可分为**私有缓存**和**共享缓存**。

      **强制缓存：**强制缓存在缓存数据未失效的情况下（即 Cache-Control 的 max-age 没有过期或者Expires 的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。

      **协商缓存：**当第一次请求时服务器返回的响应头中没有 Cache-Control 和 Expires **或者** Cache-Control 和 Expires 过期**还或者**它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。

      

      **分类注意点：**强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。

   **为什么要使用 HTTP 缓存：**

   1. 减少了冗余的数据传输，节省了网费。
   2. 缓解了服务器的压力， 大大提高了网站的性能。
   3. 加快了客户端加载网页的速度。

   **总结：**

   1、对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行协商缓存策略。
   2、对于协商缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。

   [博客地址](https://www.jianshu.com/p/227cee9c8d15)

8. 谈一谈 浏览器 缓存：

   **定义：** web 缓存是指一个 web 资源（如html页面，图片，js，数据等）存在于web服务器和客户端（浏览器）之间的副本。

   浏览器缓存方式：

   1、http 缓存：是基于 HTTP 协议的浏览器文件级缓存机制。
   2、websql：这种方式只有较新的 chrome 浏览器支持，并以一个独立规范形式出现。
   3、indexDB：是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。
   4、Cookie：一般网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。
   5、Localstorage：html 5 的一种新的本地缓存方案，目前用的比较多，一般用来存储 ajax 返回的数据，加快下次页面打开时的渲染速度。
   6、Sessionstorage：和 localstorage 类似，但是浏览器关闭则会全部删除，api 和 localstorage 相同，实际项目中使用较少。
   7、application cache：是将大部分图片资源、js、css 等静态资源放在 manifest 文件配置中。
   8、cacheStorage：是在 ServiceWorker 的规范中定义的，可以保存每个 serverWorker 申明的 cache对象。

   **作用：** 

   1. 减少网络宽带消耗。
   2. 降低服务器压力。
   3. 减少网络延迟，加快页面打开速度。

9. http 缓存和浏览器缓存的区别：

   前端缓存主要是分为 HTTP 缓存和浏览器缓存。

   1. HTTP 缓存是在 HTTP 请求传输时用到的缓存，主要在服务器代码上设置。
   2. 而浏览器缓存则主要由前端开发在前端 js 上进行设置。

10. #### 1. ES5 数组方法：

    改变原数组：

    push(), pop(), shift(), unshift(), reverse(), sort(), splice()

    不改变原数组：

    concat(), join(), slice(),map(), filter(), forEach(), some(), every(), reduce()

    #### 1. ES6 数组方法

    - arr.find：需要传入一个回调。

    - arr.findIndex：需要传入一个回调。

    - arr.fill: value，start，end。

    - arr.includes：方法返回一个布尔值，表示某个数组是否包含给定的值。

      该方法主要用来替代`indexOf()`，因为`indexOf()`是`全等运算`，而`NaN`和`NaN`也不相等。Array.flat: 拉平数组。

    - Array.from：将伪数组转换为真数组。

    - Array.of：用于将一组值转换为数组。返回新数组。

    不改变原数组：
    some、every 返回 true、false。 
    map、filter 返回一个新数组。 
    forEach 无返回值。

    

    #### 2. ES5 字符串方法

    - charAt()，根据传入的位置取得其所在的字符。

    * charCodeAt()，根据传入的位置取得其所在的字符编码（unicode码）。（不常用）

    - String.fromCharCode()，根据传入的 unicode 码，转换为相应的字符。返回转化后的字符。

    - concat()，将一或多个字符串拼接起来返回拼接得到的新字符串。

    - **indexOf(searchValue[,offset])，从一个字符串中向后搜索给定的子字符串，然后返回子字符串的位置（如果没有找到该子字符串，则返回-1）。第二个参数可以指定从哪开始(默认从0位置开始查找)。（常用）**

    - **replace()方法，替换子字符串。（其他功能讲正则的时候说）将某个字符串置换成某个字符串。**

    - **slice(beginSlice[,endSlice])，提取一个字符串的一部分，返回一个新的字符串。beginSlice 从 0 开始，endSlice 可以省略，如果省略 endSlice 会一直提取到字符串末尾。（beginSlice 是开启的位置，endSlice 是结束的下标的----但结果不会包含结束的下标）---用的较多。（按下标取字符串）**

    - **valueOf()，返回对象的字符串、数值或布尔值表示。如果是包装类型返回包装类型的值，如果是对象则返回对象本身。**

      __该方法没有参数__

      __返回值：如果是包装对象，返回的是包装对象中的基本值；如果不是包装对象类型，返回的是对象本身。__

      **toString()，返回对象的字符串表示。**

      __该方法没有参数__

      __返回值：如果是包装对象，返回的是包装对象中的基本值转换为字符串；如果不是包装对象类型，根据对象类型的不同返回值也不同。__

    - toLowerCase()，将字符串转换为小写。

    - toUpperCase()，将字符串转换为大写。

    #### 2. ES6 字符串方法

    - str.startWidth(): 判断开头有没有包含某个字符串。
    - str.endsWith(): 判断结尾有没有包含某个字符串。
    - str.includes(): 判断字符串是否包含某个字符串。
    - str.repeat(): 重复当前的字符串，可以规定次数。
    - str.trim(): 删除字符串两端的空白符。
    - trimStart() 去除首部的空格。
    - trimEnd() 去除尾部的空格。

    

11. 封装过哪些插件？(非上传 npm 上的)

12. h5 适配怎么做？

    flexible 是淘宝开源的 h5 适配方案，手机淘宝从14年开始至今一直在使用，比较稳定，并且在开发过程中不要进行复杂的折算，直接使用设计稿中的尺寸，方便好用。该方法是主流的 h5 前端开发方案之一。

    **使用方法：**

    1. Flexible的使用方法非常简单，只需要引入 flexible_css.js 和 flexible.js [下载地址](https://github.com/amfe/lib-flexible)

    2. 将 px 转成 rem。

       如果按 750px 的设计稿进行开发，为了方便换算，flexible 将屏幕宽度为750的`<html>`元素设置 font-size 为 75px，我们将 75px 称之为 rem 基准值，针对这份设计稿，我们可以知道 1rem=75px。

    3. 字号不要使用 rem。

       在不同的屏幕下，我们是不希望看到字号也随屏幕缩放，我们希望在小屏上看清文本，在大屏上看到更多的文本，所以字号还是用px单位设置，以及现在绝大多数的字体是点阵字体，通常是16px和24px，所以不希望出现13px、15px这样的奇葩尺寸。

       根据flexible的适配方案，dpr=2 时`<meta name="viewport">` initial-scale 属性为 0.5，dpr=3 时`<meta name="viewport">`initial-scale 属性为 0.3333333333

13. 什么是 SaaS 平台？

    - 什么是 SaaS？

    SaaS 是一种软件布局模型，其应用专为[网络](https://baike.baidu.com/item/网络/143243)交付而设计，便于用户通过互联网托管、部署及接入。

    * 什么是 SaaS 平台？

    [SaaS](https://baike.baidu.com/item/SaaS)平台是运营 saas 软件的平台。SaaS 提供商为企业搭建信息化所需要的所有[网络基础设施](https://baike.baidu.com/item/网络基础设施/5183560)及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无需购买软硬件、建设[机房](https://baike.baidu.com/item/机房/5066792)、招聘IT人员，即可通过[互联网](https://baike.baidu.com/item/互联网/199186)使用信息系统。

    **白话解释：**就像打开自来水龙头就能用水一样，企业根据实际需要，从 SaaS 提供商租赁软件服务。

14. Vue 里面传递给组件的 props 如何验证？

    想象一下当有一个人要使用 foo-component 组件的时候，他可能对于其要接受的参数有什么要求并不是很清楚，因此传入的参数可能会在开发子组件的人的意料之外，程序就会发生错误，就像我们在函数调用之前先检查一下函数一样，props 也可以进行一个预先检查。

    校验器模式就是指把在函数开头的对参数校验的部分提取出来作为一个公共的部分来管理，让一个什么东西来专门负责校验，当类型不正确的时候就抛个异常根本不去调用这个函数，很多框架设计时都是这么设计的（Spring MVC、Struts2等等），props 也提供了这个功能，想一下如果没有这个功能的话，为了保证正确性我们可能需要在每次使用 props 属性之前都写一段代码来检查。校验器最大的好处就是大多数情况下我们只需要声明我需要什么样的数据，让校验器检查好了再塞给我。

15. 为什么要用async 和 await？
    可以通过同步代码实现异步效果，可读性强。

    .then 和 .catch 不是说不能用，只是说可读性要差一些，因为里面还是有异步代码(异步回调函数)。

16. 





































































