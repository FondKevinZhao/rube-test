## DOM



### 01. DOM基础和DOM事件晨测

- null和undefined区别
    - null是一个空对象指针，指向的一个空对象
    - undefined是找不到
    - null的使用场景
        * 作为函数的参数，表示该函数的参数不是对象
        * 作为对象原型链的终点
        * 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值
    - undefined的使用场景
        * 变量被声明了，但没有赋值时，就等于undefined
        * 调用函数时，应该提供的参数没有提供，该参数等于undefined
        * 对象没有赋值的属性，该属性的值为undefined
        * 函数没有返回值时，默认返回undefined
- SelectorAPI或传统获取元素的区别？
    - 传统方法获取元素 获取的元素是动态的，如果元素发生改变，则获取的对象代表的元素也会发生改变
    - SelectorAPI获取的元素的静态的，一旦获取到之后，如论元素怎么改变，对象都不会改变


- 如何快速获取html和body元素？

  

- 节点类型有哪些？



- 如果获取所有子元素节点和父元素节点？


- js的组成部分及作用
    ECMAScript：语法规范
    DOM：文档对象模型 操作节点
    BOM：浏览器对象模型 操作浏览器



### 02.DOM事件

- window.onload 的作用

    

- 请分析window对象

    

- 鼠标的mouseover事件和mouseenter事件的区别

    

- 下标方式手写Tab切换（已知 OTitles是标题元素们  oCons是内容元素们）

    

- 分析基本数据类型和引用数据类型的区别
    string number boolean(基本包装类型)
    new String()
    new Number()
    new Boolean()
    
    var str = "abc";
    str.index = 1;
    var _str = new String(str);
    _str.index = 1;
    delete _str;
    console.log(str.index);

    常见的视频格式：webM  mp4  ogg
    ```html
    <video >
        <source src="01.mp4">
        <source src="01.webM">
        <source src="01.ogg">
        垃圾浏览器 换吧 
        <a download="./chrome.exe" href="">点击我下载最新谷歌浏览器</a>
    ```
<video>
    ```

​    
​    
- 标签元素的分类：  
        空元素 <br> <img> <input> <hr> <source>
        替换元素 <img> <input> <video> 
        行元素
        块元素
        行内块元素

- 书写一个[20,50)随机数 
[0,1) * 30 ==> [0,30)
[0,30) + 20 ==>[20,50)



### 03. BOM&脚本化CSS

- 如何设置设置两种计时器 并清除计时器

  

- BOM 中有哪些对象 分别是做什么的

  

- 获取窗口的高度

  

- offsetWidth 和 clientWidth 的区别

  

- display:none 和 visibility:hidden 的区别

  

- 获取时间戳的方法有哪些



### 04. DOM进阶&脚本化css

- 如何设置和获取系统滚动条的位置信息

  

- 如果获取窗口的高度 和 文档的高度

  

- 解释 offsetLeft、offsetWidth、clientLeft、clientWidth、scrollLeft

  

- 1.创建一个新的 li 节点 2.给节点一个内容 3.把节点插入到 ul 中

  

- 谈一下盒子模型 1.什么是盒子模型 2.盒子模型的构成 3.解释盒子模型分为（怪异盒子模型和标准盒子模型）
  把每一个元素当做是一个盒子，拥有盒子的平面外形和空间。
  盒子模型由 content padding border margin4 个部分构成
  盒子模型分为标准盒子模型和怪异盒子模型（box-sizing:border-box）
  标准盒子模型占用的空间是（content+padding+border+margin）
  怪异盒子模型占用的空间是（content（包含了 padding 和 border）+margin）：width 设置的宽度是 content+padding+border



### 05.DOM进阶

- 解释 innerHTML、innerText、outerHTML、outerText、textContent
  innerHTML:设置或获取某个元素内的内容 （获取可以获取到标签，设置可以解析标签）
  innerText:设置或获取某个元素内的内容 （获取直接获取文本内容，设置不可以解析标签）
  outerHTML:设置或获取某个元素的内容（包括当前元素） （获取可以获取到标签，设置可以解析标签）
  outerText:设置或获取某个元素的内容（包括当前元素） （获取直接获取文本内容，设置不可以解析标签）
  textContent:设置或获取某个元素内的内容（获取直接获取到文本内容，设置不可以解析标签，IE 低版本不兼容）
- 旧方法设置删除获取自定义属性
  ele.setAttribute(key,value);
  ele.getAttribute(key);
  ele.removeAttribute(key);
- 新方法设置删除获取自定义属性
  ele.dataset.key = value
  ele.dataset.key
  delete dataset.key
- 分析懒加载思路
  图片进入窗口内容之前，不进行加载
  可以不设置真实的 src 属性，把 src 属性保存在其他的自定义属性上
  当图片即将进入页面的时候，把自定义属性的路径赋值给 src 属性
  （当图片距离屏幕顶部的距离 <= 屏幕的高度的时候）到临界值
- html 标签的语义化
  1.更好的阅读
  2.良好样式
  3.SEO（搜索引擎优化）



### 06.DOM高级

- DOM0 和 DOM2 绑定事件的区别

  - DOM0：只能绑定一次 绑定多次会覆盖，默认冒泡
  - DOM2：可以绑定同一个事件多次，可以选择或者冒泡，DOM2 的事件只能是 DOM2 方法绑定
  - 一般选择使用 DOM0，在必要情况下才使用 DOM2
- 如何移除 DOM0 和 DOM2 的事件

  - DOM0 将事件函数设置为 null
  - DOM2 使用 remove。。。。。来删除某个事件的函数
- DOMContentLoaded 事件和 window.onload 事件的区别

  - DOMContentLoaded 等待所有节点加载完成即可执行
  - window.onload 是所有的节点及资源（音视频等）全部加载完成才执行
- 阻止默认事件和阻止传播

  - ev.preventDefault ev.returnValue = false;
  - ev.stopPropagation ev.cancelBubble = true;
- 请分析拖拽思路





### 07. 自定义滚动条

- 请描述 W3C 事件流 1.捕获： 2.目标事件执行 3.冒泡
- 什么是事件委托？事件委托的原理？事件委托的优点
- 如何禁用系统滚动条

  - 设置 body：scroll 的时候 系统有滚动条
  - 设置 html：scroll 的时候 系统有滚动条
  - 结论：系统滚动条的来历是 body 和 html，此时要禁用 html 和 body 的滚动条
- 谈一下滚轮事件（兼容性）
  onmousewheel ： e.wheelDelta
  DOMMouseScroll: e.detail
- reduce 方法解析



### 08.js高级-基础

- 如何判断数据类型，及每次方法可以检测的类型是什么
  typeof
  undefined number boolean string function

  instanceof / constructor
  Object 、Array 、 function 、RegExp

  ===
  null 和 undefined

  - Object.prototype.toString()

- 什么是回调函数

  - 自定义的
  - 自己没有调用
  - 最后执行了

  事件 计时器 ajax 生命周期

- 匿名函数的调用方法 及 作用

  - 赋值给变量（函数表达式）
  - 自调用 IIFE

  - 构建一个局部作用域，防止污染全局变量
  - 可以构建模块化

- 请描述 对象属性操作中 点操作符和中括号操作符的区别

  - .操作符后只能跟对象的属性（直接解析为对象的属性，不会当成变量解析）
  - []操作符 可以进行运算和解析变量，当然也可以直接写入字符串 作为对象的属性

- 描述一下对象销毁的方法

  - 函数保存在堆中，当函数运行的时候，会在栈中设置一个区域，让函数运行，运行完成后，把栈中的内容删除 此时局部的变量和对象都会销毁
  - 全局的变量和对象不会自己销毁，但是当对象没有被引用的时候，这个对象就会变成一个垃圾对象，等待回收。
  - 我们可以主动把对象引用的变量 设置为 null 让对象没有被引用，即可销毁

- 变量的类型有哪些？数据的类型有哪些

  - 变量类型：
    主要说的是变量保存的值的类型
    基本类型
    引用类型
  - 数据类型：
    主要说的就是数据的类型
    基本类型
    对象类型

- 函数传参的时候，赋值是值的传递还是引用传递
  - 只有值传递 没有引用传递
  - 函数传参的时候，是把变量保存的值传递给了形参的变量



### 09.js高级-函数

- 使用 Object 的 toString 检测数据类型 举例说明，并说出返回值

  - typeof
  - ===
  - instanceof constructor
  - Object.prototype.toString.call(obj) '[object Object]'
- 谈一谈 call apply bind
  call apply bind：都是改变 this 指向
  call apply:首先改变 this 指向，然后调用函数，但是两个的传参不同，call 的传参的方式是多个形参，apply 的传参是一个数组格式
  bind：指挥改变 this 的执行，传参方式和 call 相同，但是不会调用函数，会返回一个函数，供我们调用
- 谈一谈显式原型
  每一个函数都有自己的显式原型（prototype）
  显式原型指向函数的原型对象
  只有实例化的对象才能访问原型对象
  原型对象默认存在，是一个空对象
- 谈一谈原型链
  每一个函数都有自己的显式原型（prototype）
  每个对象都有自己的隐式原型
  对象的隐式原型指向其构造函数的显式原型
  设置对象属性的时候，会直接设置给当前的对象
  获取对象属性的时候，会沿着原型链依次查找当前属性
- 谈一谈 this
  this 是在函数调用的时候确定的
  this 是一个指针，指向当前调用函数的对象

  - call apply bind 硬绑定 this 指向 call 方法规定的对象
  - new 实例化调用 this 指向实例化对象
  - 隐式绑定 obj.fn() this 指向调用函数的上下文对象
  - 隐式丢失 fn = obj.fn 赋值的传递是引用值的传递，所以 fn 调用后 指向 window
  - 默认绑定 fn 直接调用的函数 其实是 window.fn() 所以指向 window
- 画终极原型图
- A instanceof B
  B 的原型对象在 A 的原型链上的时候，就返回 true



### 10.js高级-对象

- new 的过程

  - 创建一个对象 o（最后会返回当前对象）
  - 把构造函数的 this 指向 指向对象 o 并调用构造函数和传参（call apply）
  - o 的隐式原型 指向 构造函数的原型对象
  - 考虑构造函数中有没有 return 对象类型，如果有，则丢弃 o 返回 return 的对象类型

- 什么是闭包？闭包的优点？闭包的缺点？

  - 闭包是函数嵌套函数，是包含了内部函数引用外部函数变量的对象
  - 闭包的构成条件：1.函数嵌套函数 2.内部函数引入外部函数变量 3.调用外部函数
  - 闭包特点：1.延长局部变量的生命周期，可以长期驻留在内存中 2.外部可以间接访问内部的局部变量
  - 缺点：局部变量长期驻留在内存中，可能占用过多内存，造成内存泄漏

- 谈一谈作用域链

  - 作用域链是在函数定义的时候就确定了，在函数调用的时候，把当前的变量添加到已经存在的作用域链顶端，构成完整的作用域链
  - 作用域链：保证对 内部执行环境对所有变量和函数的有序访问
  - 当查找一个变量的时候，会沿着作用域链一次查找
  - 作用域最末尾一定是 window

- 谈一谈执行上下文

  - 执行上下文是在函数调用的时候才产生，是一段代码开始执行的时候做的准备工作
  - 分为全局执行上下文和局部执行上下文
  - 因为执行上下文过多，所以会把执行上下文放在一个执行上下文栈中保存
  - 当某段代码执行完毕，则把当前执行上下文弹出
  - 执行上下文包含：1：变量对象 2.确定 this 3.激活作用域链

- 区分 公有 私有 静态 特权 概念

  - 设置给实例对象的属性和方法 被称作为公有属性和公有方法
  - 在构造函数中声明的变量和函数 被称作为私有属性和私有方法
  - 给构造函数当做对象，扩展的属性和方法 被称作为静态属性和方法
  - 特权方法：在构造函数中 给实例对象扩展的方法

- 谈一谈变量对象
  - 变量对象在执行上下文确定后产生
  - 保存了当前作用域所有的变量和方法
  - 分为全局和局部变量对象，全局的变量对象就是 window
  - 局部的变量对象首先保存 形参和实参
  - 再提升函数，如果函数和形参重复，则直接覆盖
  - 最后提升变量，如果变量和函数或实参重复，则在变量赋值前 忽略变量的值



### 11. JS高级

- 说一下事件轮询机制
- 说一下 进程和线程
- 书写一个组合继承
- 描述多态和封装
- 简单描述h5新属性多线程的书写过程



### 12. less


- 定义一个清浮动的混合，并调用

- 分析 模式匹配、重载、守卫

- 举例说明转义和字符串插值

- AB 两个元素垂直排列，A 元素高度是 100px B 元素占用剩余高度（3 种）



### 13. jquery01

- jQuery 对象和 js 对象互换

  - jq--js [] 或者是 get() (eq()也是下标 但是获取的是 jq 对象)
  - js--jq \$()

- jQuery 的执行时机怎么书写 和其他的区别
  \$(document).ready(function(){})

- 分析 jQuery 的结构


- 表单的新的属性有哪些 及 作用


- 表单的所有 type 类型



### 14. jquery02

- 书写一个自定义动画实现 show 或者是 hide 方法案例（只需要实现动画效果 ）

- stop 方法解析

- jq 方法：1.设置一个新的元素（div.con） 插入到父级（div.out）中 2.新元素.con 中 有一个子元素 a 标签，点击 a 标签可以删除当前的 con 元素

- html5 新的标签及解析
  header
  footer
  nav
  div section article
  aside

- 已知数组[{name:"lily",age:18},{name:"lucy",age:19},{name:"laowang",age:12}]，请让数组按照年龄排序



### 15. ES5
- 谈一谈严格模式

- json对象和字符串的互换 举例说明


- Object.create创建对象 说明每一个的含义


- 举例使用defineProperty属性
- 谈一谈getter和setter及使用
- 谈一谈let和const和var



### 16. 晨测
- 谈一谈模板字符串

- 描述扩展运算符和rest参数

- 谈一谈箭头函数（写法 和 特点）



### 17. ES6
- for in 和 for of

- 谈一谈 新增的两种数据类型
    Symbol
    BigInt

- 谈一谈 新增的两种数据结构
    Set :new Set([1,2,3,4])
    Map :new Map([["name","lily"],[true,"false"]])

- 手写iterator


- 谈一谈generator


- 谈一下 class



### 18. ES6
- 使用extends书写一个继承
- 解释Promise可以处理的问题
- 解释promise的三种状态
- then方法的返回值
- 解析Promise的静态方法  
  all allsettled race resolve reject
- 谈一谈async和await
- 谈一谈import

### 19. node01
- nodejs轮询机制
    1.nodeJS使用了第三方库libuv，nodeJS会把一些异步操作（I/O、文件的读写）交给libuv处理。nodejs的主线程没有必要等待，可以继续处理其他事情。
    2.libuv会开启多个线程去执行这些异步操作，当异步代码操作完毕以后，会把回调函数放到回调队列中，主线程在适当的时候回去轮询回调队列。
    3.nodeJs把异步代码分为了两大类，分别是微任务和宏任务。微任务优先宏任务执行。
    4.宏任务也是根据异步代码不同，而产生多种回调队列，nodejs会依次轮询这几个回调队列：timers、pendding callback、idle、poll、check、close
        1).timers阶段：处理setTimeout和setInterval的回调函数
        2).pedding阶段：处理系统级别操作的回调函数
        3).idle阶段：处理nodejs内部的回调函数
        4).poll阶段：处理I/O或者网络请求等异步操作的回调函数
            - 当poll阶段不为空的时候，那么执行完回调函数，就继续执行下个阶段check了
                    - 当poll阶段为空，会一直等待poll中有其他的回调函数
                    - 或者当poll阶段为空的时候，如果 timer阶段的计时器到期了，或者check阶段有setImmediate等待执行的时候，会直接跳入check阶段
        5).check阶段：setImmediate的回调函数
        6).close阶段：执行一些关闭的函数

    


- 微任务和宏任务
    1.nodejs把所有的异步操作代码分为了微任务代码和宏任务代码
    2.nodejs会优先执行微任务代码，然后才执行宏任务代码
    3.微任务：process.nextTick，Promise的then\catch\finally、queueMicrotask
    4.process.nextTick一定是最先执行，其他微任务根据书写代码依次执行
    5.在宏任务每次执行下一个阶段之前，都会去检查微任务队列中是否有微任务需要执行，然后才会执行下一个阶段

    

    

- nodejs模块化的暴露和引入

    - 暴露：使用module.exports.XXX=XXX:给暴露的对象扩展一个XXX方法  
            使用module.exports = XXX:暴露的直接就是XXX方法
            exports.XXX = XXX:给暴露的对象扩展一个XXX方法
            exports = XXX:错误方法不能写！！！！
    - 引入：
        使用require方法引入即可，如果引入的是自定义模块，则方法的参数是模块路径

    

    

- 分析module.exports和exports的区别

    - 模块真正暴露出来的是module.exports指向的对象，module.exports指向的对象可以随意修改。
    - exports指向的是最module.exports对象，可以直接给exports扩展属性和方法，但是如果修改了exports对象的指向（exports = XXX），则exports指向的就不是暴露的对象了，就不能暴露了



### 20. node02
- 分析node的外层函数
    - module
    - exports
    - require
    - __dirname
    - __filename

- 谈一谈Buffer
    Buffer.from()

- 谈谈process

- 谈谈path.resolve()方法

- 谈一谈fs文件系统 



### 21. node03
- 谈一谈加密

- 什么是http协议

- nodejs搭建一个服务端，并返回一个html数据

- 书写一个快速读写文件



### 22. node04
- 请求方式及解析
- 常见响应状态码
- 什么是TCP三次握手
- 什么是TCP四次挥手
- 从输入url到解析出页面 中间经历的过程



### 23. node05
- 谈一谈cookie
    1.“HTTP 是一个无状态的协议”:即使同一个客户端连续两次发送请求给服务器，服务器也识别不出这是同一个客户端发送的请求。为了解决 HTTP 无状态导致的问题，后来出现了 Cookie
    2.Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据
    3.Cookie作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成
    4.Cookie的设置
        - 客户端发送 HTTP 请求到服务器
        - 当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段
        - 浏览器收到响应后保存下 Cookie
        - 之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。
    5.一些设置：
        - Expires 用于设置 Cookie 的过期时间
        - Max-Age 用于设置在 Cookie 失效之前需要经过的秒数
        - HTTPOnly：设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。


- 谈一谈缓存
    1.缓存是性能优化中简单高效的一种优化方式。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷
    2.缓存分为强缓存和协商缓存
        - 强缓存：不会向服务器发送请求，直接从缓存中读取资源，并且显示from disk cache或from memory cache字样，强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。
            - 协商缓存：协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
            - 描述协商缓存过程

- 谈一谈session
    1.因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态
    2 Session 是基于Cookie 实现的另一种记录服务端和客户端会话状态的机制
    3 Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中
    4 描述Session的过程

- 正则表达式的两种创建方式 案例说明
