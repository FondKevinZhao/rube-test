# 面试问答

### 1、js闭包的优缺点

```js
function fn() {
    // 创建局部变量name和局部函数test
    var name = "1111";
    
    // test()是函数内部方法，是一个闭包
    function test() {
        // 使用了外部函数声明的变量，内部函数可以访问test函数外面的变
        console.log(name); 
    }
    
    test();  // 调用test函数
}

// 现在来调用fn函数，会输出‘1111’
fn();
// test函数内部可以使用函数外部声明的变量，test就是一个闭包
```

##### 闭包的三特性：

- 函数嵌套函数
- 函数内部可以应用外部函数的变量
- 参数和变量不会被垃圾回收机制回收

##### 优点：

- 变量可存储在内存中，实现变量数据共享
- 避免了全局变量的污染
- 允许私有成员的存在

##### 缺点：

- 常驻内存，内存消耗很大
- 在IE中可能导致内存泄露

### 2、this和$this的区别

##### this ：

-  是DOM对象

- 使用js获取到的对象

- 只能使用js方法

##### $(this) ：

- 是jquery对象

- 使用jquery方法获取到的对象

- 只能使用jquery方法

##### 相互转换：

- JS=>JQuery      $(js对象)
- JQuery=>JS       $('div')[0] 或  $('div').get[0]



### 3、用递归实现累加求和

**定义**：递归函数就是在函数体内调用自己，要注意函数终止条件，避免死循环

```js
function add(num){
    if(num==1){
        return num
    }else {
        return num = num+this.add(num-1)
    }
}

var t = add(3)
console.log(t);  // 结果 6
```



### 4、什么是面向对象

**面向过程：**

- 分析出解决问题需要的步骤，按照步骤执行，关注顺序
- 打开网易音乐播放器=》播放音乐

**面向对象：**

- 把事物分解成一个个对象，一个人就是一个对象
- 不关注顺序
- 手机就是一个对象，网易是他的属性，播放音乐是方法
- 特征：封装、继承、多态
- 特点：代码可以复用、易维护和开发

### 5、vue的生命周期

**定义：**

- vue每个组件是相互独立的，每个组件都要生命周期
- 组件创建：beforeCreate/created
- 数据初始化：beforeMount/mounted
- 更新：beforeUpdate/updated
- 销毁：beforeDestory/destoryed
- https://segmentfault.com/a/1190000011381906

### 6、vue-router路由传参的方式

场景：点击当前某个按钮跳转到另一个页面中去，并将值带过去

```js
// 方法1,传递name
this.$router.push({
    path:`/home/$uname`
})

// router的配置文件中，配置路由
{path:'/home/:uname' ,name:'home', component:home}

// 其他页面获取到传过来的参数
this.$route.params.uname

// 说明：拼接在path后面，页面刷新数据不会丢失
```

```js
// 方法2,传递uname
this.$router.push({
    name:'home',
    params:{
        uname:name
    }
})
// router的配置文件中，配置路由
{path:'/home' ,name:'home',component:home}

// 其他页面获取到传过来的参数
this.$route.params.uname

// 说明：使用params，页面刷新数据会丢失
```

```js
// 方法3,传递uname
this.$router.push({
    name:'home',
    query:{
        uname:name
    }
})
// router的配置文件中，配置路由
{path:'/home' ,name:'home',component:home}

// 其他页面获取到传过来的参数
this.$route.params.uname

// 说明：使用query，参数会在url后面显示?id=xxx
```



### 7、vue和js、jquery对比

```html
// 以往p标签添加一段文字为例
// 1、原生js
var msg = 'hello'
var p = document.querySelector('p')
p.innerHTML = msg

// 2、jquery
var msg = 'hello'
$('p').html(msg)

// 3、vue，不需要操作dom
<div>{{msg}}</div>
......
new Vue({
  el:'#app',
  data:{
    msg:'hello'
  }
})
```

### 8、同步异步函数执行

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
 
async function async2() {
    console.log('async2');
}
 
console.log('script start');  // 执行1
 
setTimeout(()=>{
    console.log('setTimeout');
},0)
 
async1();                    // 执行2
 
new Promise((resolve)=>{
    console.log('promise1');
    resolve();
}).then(()=>{
    console.log('promise2');
});
 
console.log('script end');

//  答案
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

- Promise 优先于 setTimeout 宏任务
- Promise 一旦被定义就会立即执行
- Promise 的 resolve 和 reject 是异步执行的回调
- await 执行完后，才会让出线程

### 9、Vue 中的 data 为什么是函数

组件中的`data`写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的`data`，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份`data`，就会造成一个变了全都会变的结果

当data是一个函数的时候，每一个实例的data属性都是独立的，不会相互影响

data是一个函数的话，这样每复用一次组件，就会返回一份新的`data`，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份`data`，就会造成一个变了全都会变的结果。

所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。