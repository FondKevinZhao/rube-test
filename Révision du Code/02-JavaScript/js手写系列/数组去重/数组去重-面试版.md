### 1. es6 set对象去重

```js
var arr = [1, 2, 2, 3, 5, 3, 5];
var set1 = new Set(arr);
console.log([...set1]);
```

```js
// 数组去重
var arr = [1, 2, 2, 3, 5, 3, 5];
console.log([...new Set(arr)]);
```

```js
// 字符串去重
let str = 'aaaabbeeaaddcbc'
console.log([...new Set(str)].join(''));
```

### 2. 用 indexOf方法

```js
// 用 es5 的方法
var arr = [12, 23, 12, 15, 23, 25, 14, 12];
var newArr = [];
for (var i = 0; i <arr.length; i++) {
    if(newArr.indexOf(arr[i]) == -1) {
        newArr.push(arr[i]);
    }
}
console.log(newArr);

// 或者这样写
let arr = [12, 23, 12, 15, 23, 25, 14, 12]
let newArr = []
arr.forEach((item) => {
  if (newArr.indexOf(item) === -1) {
    newArr.push(item)
  }
})
console.log('indexOf', newArr)
```



### 3. 用 filter 方法

```js
// 用 filter 方法
var arr = [12, 23, 12, 15, 23, 25, 14, 12];
    var newArr = arr.filter(function(value,index,self){
    return self.indexOf(value) === index;
});
console.log(newArr);

详解：
我们来走走遍历过程

第一次循环，传入元素1，index(1)的索引为0，而此时1的索引本来就是1，OK，满足。

第二次循环，传入元素2，index(2)的索引为1，而此时2的索引也是1，OK，也满足。

第三次循环，传入元素2，index(2)的索引为1，而此时2的索引为2，OK，不满足，被PASS，这里就是巧妙的借用了indexOf始终查找到第一次出现的位置。
```



### 4. es5+ reduce() 去重

```js
// 用es5 + reduce() 去重
let arr = ['a', 'b', 'c', 'a', 'd', 'c'];
let newArr = arr.reduce((pre, cur) => {
  // 此时的pre一开始上来是一个空数组[]
  // cur 是数组中的每一项。如：'a', 'b', 'c', 'a', 'd', 'c'
  // if(!pre.includes(cur)) 判断pre数组中是否包含当前所遍历的cur
  // console.log('pre', pre);
  if (!pre.includes(cur)) {
    // 这里要用concat，不能用push
    return pre.concat(cur);
  } else {
    return pre;
  }
}, []);
```









































































































































