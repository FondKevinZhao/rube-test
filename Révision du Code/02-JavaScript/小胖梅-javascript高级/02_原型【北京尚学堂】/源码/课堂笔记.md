## 回顾
1. 面向过程与面向对象区别
1.1 面向过程：分析问题-步骤-函数
1.2 面向对象：分析问题-抽象对象-属性和方法-相互关系

2. 优缺点
   面向过程：
    优点：性能相对面向对象高 
    缺点：可维护性低、不易扩展 
   面向对象：
    优点：可维护性高、易扩展、易复用
    缺点： 性能相对面向过程低


3. 创建对象
3.1 原始对象
    let obj=new Object()
    let obj2={ name:'',age:'' }

3.2 构造函数创建对象 

## 构造函数创建对象 （掌握）
1. 概念
构造函数--生成对象的模板 
2. 语法
    function Fn(name){
        this.name=name;
        this.eat=function(){

        }
    }

    let Demo = function(name){
        this.name=name;
    }

    //生成实例对象
    let fn=new Fn('xx')//{name:'',eat:fn}

3. 构造函数特点
3.1 生成实例对象 作为对象的模板 
3.2 必须new 
3.3 函数首写字母大写
3.4 this指向--实例对象 

## new命令
执行调用构造函数 
### 原理
1.  创建空对象{}，空对象为了接受实例对象准备的
2. 执行构造函数，传递实参 
3. 执行this挂载数据 this指向实例对象 this->{}
4. 查看构造函数返回值

## 构造函数返回值
1. 构造函数返回值，并且return的是对象（引用类型），构造函数的返回值就是这个对象赋值给实例对象
2. 如果return的是基础数据类型，构造函数的返回值就是this （和没有一样）


## this指向
1. 函数调用 
2. 构造函数调用
3. 对象调用

特殊：
setInterval setTimeout  IIFE ---》this window 
call apply bind 修改this指向
箭头函数没有this 


## 作业
思路：
1. 布局样式：全屏的布局 黑色背景 小球移动：定位属性 左右上下位置  css圆
2. 小球--对象
    2.1 小球大小 [20,50]
    2.2 小球颜色 [0,255]  
    小球的颜色库=[pink,blue,red,green,sky]
    2.3 小球的位置 left top 
    2.4 小球的位置变化：移动的位置 [-10,10]
    2.5 小球绘制：创建小球容器div 追加页面上 添加样式
    2.6 小球运动：left top 修改 --移动的位置 ---添加样式


## 原型 prototype
1. 原型对象：
    原型上的属性和方法都可以被实例对象共享 

2. 构造函数的特点（缺点）
    构造函数可以实现属性和方法在实例对象上的共享
    但是如果实例对象相同的方法。每次创建实例对象的时候会创建一遍 浪费资源空间
    原型对象就是解决这个缺点的 

    实例对象  构造函数  原型对象（prototype）

    每个函数都有一个属性prototype 指向当前的函数的原型对象


3. prototype特点：
             1. 原型对象上的属性和方法 可以在实例对象之间共享
             2. 原型对象上的属性或方法修改了，实例对象会立即修改
             3. 实例对象获取属性和方法 先查找自己的构造函数 没有找原型上 相同优先选择自身的 


## constructor 
原型对象（prototype）对象上的属性constructor属性 指向所在的构造函数

## __proto__ 
__proto__指向创建他的构造函数的prototype(原型对象)


## 原型链
原型与原型层层相链接的过程即为原型链

原型链应用
对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有__proto__原型的存在
每个对象都有__proto__原型的存在

## 回顾
1. 构造函数创建对象  
    优点：创建的实例之间共享属性和方法
    缺点：实例对象上方法相同，创建实例每次创建一遍，浪费资源空间

    function Cat(name){
        this.name=name;
        this.eat=function(){

        }
    }
    let cat1=new Cat()
    let cat2=new Cat()

2. 原型-prototype 
说明：
    函数身上的属性：prototype 
构造函数.prototype --->构造函数的原型对象 （原型对象）
作用：
    prototype上的属性和方法 可以被实例对象之间共享  
    构造函数上公共的方法 放到原型对象上 

特点：
    1. 属性和方法被实例共享
    2. prototype身上的属性或者方法修改了，立即同步实例对象
    3. 实例对象使用属性和方法时候-优先找自身的，找不到找原型对象 

语法：
    Cat.prototype.xxx=xxx;

图形：
    实例对象  构造函数  原型对象 

3. constructor-构造函数
说明：
    对象身上的属性 

语法：
    构造函数.prototype.constructor 
    指向当前的原型对象所在的构造函数 

4. __proto__  
说明：
    谷歌新：[[prototype]]  旧：__proto__ 
    指向原型对象 
    对象和函数都有这个属性 

语法：
    cat1.__proto__ === Cat.prototype 
    cat1.__proto__.__proto__ === Object.prototype
    cat1.__proto__.__proto__.__proto__ === null 

    Cat.__proto__  === Function.prototype 
    Cat.__proto__.__proto__ === Object.prototype

    Function.prototype 
        Array.__proto__
        String.__proto__ 
        Number.__proto__
        Boolean.__proto__ 
        Object.__proto__
        Function.__proto__ 

    cat1.toString();

## 作业


## 继承
说明：
    子类可以使用父类的所有功能，并且对这些功能扩展。
    B继承A 

1. 原型链继承
    B.prototype=A.prototype 
    B.prototype.constructor=B       

2. 构造函数继承
    A.call(this,...)

3. 组合继承

4. 寄生组合继承
    B.prototype = Object.create(A.prototype)
    B.prototype.constructor=B 

## class基本语法
1. 说明：
    class创建对象的模板 是构造函数的简单写法（ES6）

2. 语法：
    class Cat{
        //自执行
        constructor(name){
            this.name =name;
        }
        //原型上
        eat(){

        }
    }
    let cat =new Cat('xx')

3. 特点：
    1. class 类名-首字母大写
    2. 必须new创建实例对象
    3. class类里面 不能加,


4. 继承

