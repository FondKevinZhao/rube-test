## 回顾
继承：B继承A
1. 原型链继承
    核心：
      B.prototype=A.prototype 
      B.prototype.constructor =B
    缺点：
      只能继承原型
      子类修改会影响父类
      子类实例对象会有影响 

2. 构造函数继承
    核心： 
        B的构造函数内 
        A.call(this,...)
    缺点：
      只能继承构造函数
     原型对象上的属性和方法不能继承

3. 组合继承
    B的构造函数内 
        A.call(this,...)
    核心：
      B.prototype=A.prototype 
      B.prototype.constructor =B

4. 寄生组合继承
    B的构造函数内 
        A.call(this,...)
    核心：
      B.prototype=Object.create(A.prototype) 
      B.prototype.constructor =B

5. ES6创建类 ---功能：创建实例对象
class 创建对象的模板 （构造函数的简写）
语法：
    class 类名{
        constructor(name){
            this.name=name;
        }
        //方法
        eat(){

        }
    }

    let 实例=new 类名('xx');

继承：B继承A
 Class B extends A{
    constructor(name){
        super(name)
    }
 }


6. Object方法
 1. 实例.hasOwnProperty() 查看是否有某个属性 （不包含继承）
 2. Object.keys() Object.values() Object.entries() 
 3. Object.create()


## 作用域链
1. 作用域
说明：定义的变量或者函数可使用的范围区间 
2. 作用域分类
    全局作用域 函数级作用域
    全局作用域：
        在代码任意位置都可以使用 window 
        什么销毁：浏览器关闭的时候
    函数级作用域（局部作用域）
        定义在函数内的变量 在函数中使用
        function fn(num){ } //参数也是局部的
        什么销毁：函数使用完毕 内存释放

3. 特点
    作用域 内层作用域可以外层作用域，但是外层不可以访问内层作用域的变量
    作用域用途：隔离变量 
    变量获取会先找自身的用，如果没有向上级作用域查找

4. 作用域链
    在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链

## 闭包
1. 概念
    在函数的外面访问函数内的局部变量

2. 作用
    1. 可以访问函数内的变量 
    2. 让这些变量一直保存在内存中
    3. 避免全局变量污染 

3. 优缺点
    优点：
        1. 避免全局变量污染  （封闭的作用域）
        2. 延长变量的作用域（让变量一直保存在内存中）
        3. 私有成员存在  

    缺点：
        内存消耗大  滥用闭包会影响性能 不当使用会导致内存泄漏

## 垃圾回收
1. 垃圾回收机制：js引擎里面包含的 周期性的释放内存 
    当变量或者函数不被使用或者引用的时候 js引擎就会回收掉 释放内存

2. 回收方式
    有两种方式： 标记清除、引用计数 ，其中标记清除更为常用

## 错误类型


    



