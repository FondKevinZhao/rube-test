![图片](./images/logo.png)

# 闭包和静态成员

**主要内容**

* 作用域链
* 闭包

**学习目标**

| 知识点   | 要求 |
| -------- | ---- |
| 作用域链 | 掌握 |
| 闭包     | 掌握 |

## 一、**作用域链**

### 1.变量的作用域

作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期。在 Javascript 中，作用域分为全局作用域和函数作用域。

==全局作用域==：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。

==函数作用域==：在函数内部才可以访问

Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。

```javascript
var n=999;

function f1(){
    alert(n);
}

f1(); // 999
```

另一方面，在函数外部自然无法读取函数内的局部变量。

```javascript
function f1(){
    var n=999;
}

alert(n); // error
```

这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

```javascript
function f1(){
    n=999;
}

f1();

alert(n); // 999
```

![1](images\1.png) 

作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。<font color='red'>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。</font>

作用域最大的用处就是<font color='red'>隔离变量</font>，不同作用域下同名变量不会有冲突。![2](images\2.png)

​	1）泡泡1是全局作用域，有标识符foo；

​	2）泡泡2是作用域foo，有标识符a,bar,b；

​	3）泡泡3是作用域bar，仅有标识符c。

### 2.作用域链

一般情况下，变量取值到创建这个变量的函数的作用域中取值。

但是<font color='red'>如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链（scope chain）。</font>

作用域链来保证对执行环境<font color='red'>有权访问</font>的变量和函数的<font color='red'>有序访问</font>。

```javascript
var a = 10,b = 20;
function fn() { //这里可以访问a、b、c
    var a = 100,c = 30;
    function bar() { //这里可以访问a、b、c、d
        var a = 100, d = 40;
        console.log(a); //100--先访问自己作用域中的变量
        console.log(b); //20--当前作用域中没有逐级向上查找
        console.log(c); //30--当前作用域中没有往上级作用域中查找
    }
    bar();
}
fn();
//上级作用域不可以访问下级作用域中的变量
//这里只可以访问a、b
console.log(c); //ReferenceError: c is not defined
```

以上代码涉及了3个执行环境：全局环境、fn()局部环境和bar()局部环境。在一个变量环境中只能访问他自己的环境和父执行环境。bar(）的父执行环境就是fn()，而fn()的父执行环境就是全局环境。如果还不清楚可以参考下图：

 ![3](images\3.png)

我们这时候会发现函数外部是无法访问内部的局部环境的，但是我们想突破作用域链怎么办呢？这时候就有了闭包共享作用域。闭包这个名词就出现了。

### 3.闭包

#### 3.1闭包介绍

出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。

那就是在函数的内部，再定义一个函数。

```javascript
function f1(){

    var n=999;

    function f2(){
        alert(n); // 999
    }

}
```

在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），<font color='red'>子对象会一级一级地向上寻找所有父对象的变量</font>。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

```javascript
function f1(){

    var n=999;

    function f2(){
        alert(n);
    }

    return f2;

}

var result=f1();

result(); // 999
```

上面代码中的f2函数，就是闭包。<font color='red'>闭包就是有权访问另一个函数作用域中的变量的函数。</font>

```javascript
function f1() {
    var a = 100;
    return function () {//闭包
        console.log(a);
    }
}
console.log(a);//ReferenceError: a is not defined
var result = f1(); //相当于 var result = function(){console.log(a);}
result(); //100
```

闭包就是return后面的匿名函数，即能够<font color='red'>读取其他函数内部变量的函数</font>。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“<font color='red'>定义在一个函数内部的函数</font>”。在本质上，闭包就是<font color='red'>将函数内部和函数外部连接起来的一座桥梁</font>。

#### 3.2闭包作用

闭包的最大用处有两个，一个是<font color='red'>可以读取外层函数内部的变量</font>，另一个就是<font color='red'>让这些变量始终保持在内存中</font>，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。

```javascript
function foo(num) {
    return function () {//闭包
        console.log(++num);
    }
}
var result = foo(5); //var result=function () {console.log(++5);}
result(); //6
result(); //7
result(); //8
var result = foo(5); //var result=function () {console.log(++5);}
result(); //6
result(); //7
result(); //8
```

在这段代码中，result实际上就是闭包。前三次调用的值分别是6,7,8这证明了，函数foo中的局部变量num一直保存在内存中，并没有在foo调用后被自动清除。

为什么会这样呢？原因就在于foo是匿名函数的父函数，而匿名函数被赋给了一个全局变量，这导致匿名函数始终在内存中，而匿名函数的存在依赖于foo，因此foo也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

上面代码中，num是函数foo的内部变量。通过闭包，num的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包result使得函数foo的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。

#### 3.3闭包应用场景

1.封闭作用域 (全局变量私有化)

JavaScript的GC机制
在JavaScript中，如果一个对象不再被引用，那么这个对象就会被GC回收，否则这个对象一直会保存在内存中。
封闭作用域又称为封闭空间，小闭包，匿名函数自调

优点：1、不污染全局空间；2、内部所有的临时变量执行完毕都会释放不占内存；3、可以保存全局数据；4、更新复杂变量

```js
//基本结构
(function()())();
;(function()())();

//例子
(function (){
    var age=18;
    console.log(age);
})();//匿名函数不需要调用，进入到函数中就执行了,输出为18
(function(){
    console.log(age);
})();//报错了，age is not defined
//虽然var age=18；是一个全局变量，但是在第二个函数中是拿不到的，因为它在一个封闭的作用域中。
```

案例：

​	![1](images\bibao.jpg)

```html
<button onclick="num()">普通神经号 </button>
    <button onclick="vipNum()">专家神经号</button>

    <h3>闭包实现</h3>
    <button onclick="fn('a')">普通神经号 </button>
    <button onclick="fn2('b')">专家神经号</button>
```

```js
//闭包
        //普通函数写法
        let num1 = 0;
        let num2 = 0;

        function num() {
            console.log('普通号：', ++num1);
        }

        function vipNum() {
            console.log('专家号：', ++num2);
        }   
        console.log('---------------------------------------');

        //闭包写法
        function getNum(num) {
            return function (ele) {
                console.log(ele+'当前取号：',++num);
            }
        }
        //普通
        let fn =getNum(0)
        let fn2=getNum(0)
```

2. 索引值问题

```js
//索引值问题
        let ul = document.querySelector('ul')
        let lis = document.getElementsByTagName('li');//数组[li,li,...]
 		//方法1：let变量块级 推荐 
            for(let i=0;i<lis.length;i++){
               lis[i].onclick = function(){
                   // console.log(i);//5
                   console.log(lis[i].innerHTML);
               }
           } 

        //方法2：时间绑定this 
            for(let i=0;i<lis.length;i++){
               lis[i].onclick = function(){
                   console.log(this.innerHTML);//this指向事件的调用者
               }
           } 

        //方法3：闭包 自执行函数
           for (var i = 0; i < lis.length; i++) {
               (function (i) {
                   lis[i].onclick = function () {
                       console.log(this.innerHTML);//this指向事件的调用者
                   }
               })(i)
           }
```

闭包应用-3秒钟之后,打印所有li元素的内容 

```js
for (var i = 0; i < lis.length; i++) {
            (function (i) {
                setTimeout(function () {
                    console.log(lis[i].innerHTML);
                }, 1000)
            })(i)
        }
```

案例：打车花费计算

```js
/*需求分析
打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格
如果有拥堵情况,总价格多收取10块钱拥堵费*/

 var car = (function() {
     var start = 13; // 起步价  局部变量
     var total = 0; // 总价  局部变量
     return {
       // 正常的总价
       price: function(n) {
         if (n <= 3) {
           total = start;
         } else {
             //起步价加上超出的公里数的价格
           total = start + (n - 3) * 5
         }
         return total;
       },
       // 拥堵之后的费用
       yd: function(flag) {
         return flag ? total + 10 : total;
       }
	}
 })();
console.log(car.price(5)); // 23
console.log(car.yd(true)); // 33

```



3. 函数防抖与节流 （后续讲）



4. 封装对象的私有属性和私有方法

```javascript
function Person() {
    var _age;//封装私有变量
    function setAge(n) {
        _age = n;
    }
    function getAge() {
        return _age;
    }
    return {
        getAge: getAge,
        setAge: setAge
    }
}
var p1 = Person(); //{getAge: ƒ, setAge: ƒ}
p1.setAge(24);
console.log(p1.getAge()); //24
console.log(p1._age); //undefined
```

上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。用户只能通过get ，set对数据进行查看和更改等操作，没法对age直接更改。 我们用<font color='red'>下划线来约定私有变量</font> \_name 和 \_age ,它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的变量污染。

#### 3.4闭包的优缺点

优点：

- ​    1:变量长期驻扎在内存中
- ​    2:避免全局变量的污染
- ​    3:私有成员的存在

缺点：

闭包使函数中的变量都保存在内存中，所以<font color='red'>内存消耗很大</font>。因此不能滥用闭包，否则会造成网页的性能问题。

常驻内存 增大内存的使用量 使用不当会造成内存的泄露.

**内存泄漏**

**程序的运行需要内存**。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

定义：程序中己动态分配的[堆内存]由于某种原因**程序未释放或无法释放**引发的各种问题。

js中可能出现的内存泄漏情况：结果：变慢，崩溃，延迟大等



虽然前端有垃圾回收机制，但当某块无用的内存，却无法被垃圾回收机制认为是垃圾时，也就发生内存泄漏了。

**哪些情况会引起内存泄漏**

**1. 意外的全局变量**

全局变量的生命周期最长，直到页面关闭前，它都存活着，所以全局变量上的内存一直都不会被回收。

当全局变量使用不当，没有及时回收（手动赋值 null），或者拼写错误等将某个变量挂载到全局变量时，也就发生内存泄漏了。

**2.遗忘的定时器**
setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期，所以当在某个页面使用了定时器，当该页面销毁时，没有手动去释放清理这些定时器的话，那么这些定时器还是存活着的。

也就是说，定时器的生命周期并不挂靠在页面上，所以当在当前页面的 js 里通过定时器注册了某个回调函数，而该回调函数内又持有当前页面某个变量或某些 DOM 元素时，就会导致即使页面销毁了，由于定时器持有该页面部分引用而造成页面无法正常被回收，从而导致内存泄漏了。

如果此时再次打开同个页面，内存中其实是有双份页面数据的，如果多次关闭、打开，那么内存泄漏会越来越严重。而且这种场景很容易出现，因为使用定时器的人很容易遗忘清除。

**3.使用不当的闭包**
函数本身会持有它定义时所在的词法环境的引用，但通常情况下，使用完函数后，该函数所申请的内存都会被回收了。

但当函数内再返回一个函数时，由于返回的函数持有外部函数的词法环境，而返回的函数又被其他生命周期东西所持有，导致外部函数虽然执行完了，但内存却无法被回收。

**4. 遗漏的 DOM 元素**
DOM 元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了
但如果某个 DOM 元素，在 js 中也持有它的引用时，那么它的生命周期就由 js 和是否在 DOM 树上两者决定了，记得移除时，两个地方都需要去清理才能正常回收它。

总结：

全局变量
dom 清空时，还存在引用
定时器未清除
子元素存在引起的内存泄露



## 二、垃圾回收机制

### 1.简介

JS自带一套内存管理引擎，负责创建对象、销毁对象，以及垃圾回收。垃圾回收机制主要是由一个叫<font color='red'>垃圾收集器</font>（garbage collector，简称GC）的后台进程负责监控、清理对象，并及时回收空闲内存。JavaScript 中的内存管理是自动执行的，而且是不可见的。

js的[垃圾回收]机制是为了防止内存泄漏（已经不需要的某一块内存还一直存在着），垃圾回收机制就是不停歇的寻找这些不再使用的变量，并且释放掉它所指向的内存。
<font color='red'>垃圾回收</font>机制，<font color='red'>JS的执行环境负责管理代码执行过程中使用的内存</font>。垃圾收集器会**定期（周期性）**找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。



变量的生命周期

当一个变量的生命周期结束之后，它所指向的内存就会被释放。js有两种变量，局部变量和全局变量，局部变量是在他当前的函数中产生作用，当该函数结束之后，该变量内存会被释放，全局变量的话会一直存在，直到浏览器关闭为止。



### 2.可达性（Reachability）

GC的最主要职责是监控数据的**可达性（reachability）**；哪些数据是所谓的**可达的**呢？

1. 所有显示调用，被称为`根`，包括
   - 全局对象
   - 正被调用的函数的局部变量和参数
   - 相关嵌套函数里的变量和参数
   - 其他（引擎内部调用的一些变量）
2. 所有从根引用或引用链访问的对象

举个简单的例子：

```javascript
let user = {
    name: 'Onion'
}
```

这里全局变量user指向内存里的对象`{name: 'Onion'}`，我们称其为引用。这时对象Onion（以下均以名字简称）是所谓**可达的**。

 ![4](images\4.webp)

将user置为null后，引用丢失，Onion对象就变成不可达了。最终GC会将它从内存中清除。

 ![5](images\5.webp)

 再举一个复杂一点的例子：

```javascript
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman,
  }
}

let family = marry({
  name: "Onion"
}, {
  name: "Garlic"
});

```

 如图，现阶段所有对象都是可达的。

 ![6](images\6.webp)

现在我们删除一些对Onion的引用

```javascript
delete family.father
delete family.mother.husband
```

如图，尽管Onion还有对Garlic的引用，但是它本身已不可达，所以很快就会被GC发现并回收。

 ![7](images\7.webp)

### 3.回收算法

js垃圾回收方式
有两种方式： 标记清除、引用计数 ，其中标记清除更为常用

**标记清除**(mark-and-sweep)：是对于脱离作用域的变量进行回收，当进入作用域时，进行标记，离开作用域时，标记并回收这些变量。到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。

**引用计数**：引用计数是跟踪记录每个值被引用的次数。就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象，每当过一段时间开始垃圾回收的时候，就把被引用数为0的变量回收。引用计数方法可能导致循环引用，类似死锁，导致内存泄露。

最基本的垃圾回收算法被称为**标记清除法（mark-and-sweep）**。有这么几步：

1. GC标记所有`根`的变量

 ![8](images\8.webp)

2.访问所有变量的引用，并标记它们

 ![9](images\9.webp)

3.标记所有引用链上的对象，已标记的对象不再被访问

![10](images\10.webp) 

4.最后删除所有未被标记的对象（**注**：并非未被引用的对象，如图右）

 ![11](images\11.webp)

现代的GC引擎自然比这个复杂得多，很多优化手段早已被用到各大厂家中，比如V8的分代回收（Generational collection）、增量回收（Incremental collection）、空闲时回收（Idle-time collection）等等。不再深入探讨。

引用计数：

```js
 function person() {
        var objA = new Obejct();
        var objB = new Object();

        objA.some = objB;
        objB.other = objA;
      }
```

在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露

**如何减少垃圾回收开销**

由于每次的垃圾回收开销都相对较大，并且由于机制的一些不完善的地方，可能会导致内存泄露，我们可以利用一些方法减少垃圾回收，并且尽量避免循环引用。

1. 在对象结束使用后 ，令obj = null。这样利于解除循环引用，使得无用变量及时被回收；

2. js中开辟空间的操作有new(), [ ], { }, function (){..}。最大限度的实现对象的重用；

3. 慎用闭包。闭包容易引起内存泄露。本来在函数返回之后，之前的空间都会被回收。但是由于闭包可能保存着函数内部变量的引用，且闭包在外部环境，就会导致函数内部的变量不能够销毁

   

## 三、原生错误类型

### 1.SyntaxError 对象

`SyntaxError`对象是解析代码时发生的语法错误。

```javascript
// 变量名错误
var 1a;
// Uncaught SyntaxError: Invalid or unexpected token

// 缺少括号
console.log 'hello');
// Uncaught SyntaxError: Unexpected string
```

上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出`SyntaxError`。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。

### 2.ReferenceError 对象

`ReferenceError`对象是引用一个不存在的变量时发生的错误。

```javascript
console.log(a);// ReferenceError: a is not defined
```

### 3.RangeError 对象

`RangeError`对象是一个值超出有效范围时发生的错误。

```javascript
// 数组长度不得为负数
new Array(-1)
// Uncaught RangeError: Invalid array length
```

### 4.TypeError 对象

`TypeError`对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。

```javascript
let obj = {};
obj();//TypeError: obj is not a function

let str = new 'hello';// TypeError: "hello" is not a constructor
```

### 5.URIError 对象

URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()

```javascript
console.log(decodeURI('%2'));//URIError: URI malformed
```

### 6.EvalError 对象

`eval`函数没有被正确执行时，会抛出`EvalError`错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。



