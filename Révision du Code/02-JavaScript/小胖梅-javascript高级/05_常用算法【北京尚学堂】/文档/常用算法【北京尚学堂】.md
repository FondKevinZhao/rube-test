![图片](./images/logo.png)

# 常用算法

**主要内容**

* 数组去重
* 冒泡排序
* 选择排序
* 插入排序
* 快速排序
* 折半查找

**学习目标**

| 知识点   | 要求 |
| -------- | ---- |
| 数组去重 | 掌握 |
| 冒泡排序 | 掌握 |
| 选择排序 | 掌握 |
| 插入排序 | 掌握 |
| 快速排序 | 掌握 |
| 折半查找 | 掌握 |

## 一、**数组去重**

### **1.双重for循环**

这是一个最笨的方法，双重循环

```javascript
 function newArrFn() {
            //创建一个新数组
            let newArr = [];
            for (let i = 0; i < arr.length; i++) {
                //创建一个开关 如果是true存进去 否则不存
                let flag = true;
                for (let j = 0; j < newArr.length; j++) {
                    console.log('循环比较次数：'); //40
                    //原数组和新数组比较 如果一致开关为 false 
                    arr[i] === newArr[j] ? flag = false : flag;
                }
                if (flag) {
                    newArr.push(arr[i])
                }
            }
            return newArr;
        }
```

### **2.for循环 +IndexOf**

indexOf的特性，查找元素找不到就返回-1， 接下来就需要判断，如果是-1，说明没找到，就往新数组里面添加元素。

```javascript
function newArrFn2() {
            let newArr = [];
            for (let i = 0; i < arr.length; i++) {
                console.log('for结合indexOf()的循环次数'); //10
                 newArr.indexOf(arr[i]) === -1 ? newArr.push(arr[i]) : newArr;
            }
            return newArr;
        }
```

### **3.includes**

利用 includes 检查新数组是否包含原数组的每一项。 如果不包含，就push进去

```javascript
 function newArrFn3() {
            let newArr = [];
            for (let i = 0; i < arr.length; i++) {
                //ES6新方法 includes()：返回布尔值，表示是否找到了参数字符串
                newArr.includes(arr[i]) ? newArr : newArr.push(arr[i]);
            }
            return newArr;
        }
```

### **4.Set**

ES6中新增了数据类型Set，Set的一个最大的特点就是数据不重复。Set函数可以接受一个数组（或类数组对象）作为参数来初始化，利用该特性也能做到给数组去重

```javascript
 function newArrFn4() {
            // console.log(new Set(arr));
            let newArr = ([...new Set(arr)])
            return newArr;
        }
```

### 5.set + Array.from

利用 set数据不重复的特点，结合 Array.from （es6）

```js
function newArrFn5() {
            // let newArr = ([...new Set(arr)])
            let newArr = Array.from(new Set(arr))
            return newArr;
        }
```

### 6.sort 排序

首先利用 sort 方法进行排序。进行循环，如果原数组的第 i 项和新数组的 i - 1 项不一致，就push进去

```js
 function newArrFn6() {
            arr = arr.sort(); //数组排序 缺点：会修改数组的数据位置 
            let newArr = [];
            for (let i = 0; i < arr.length; i++) {
                console.log('循环的次数');
                arr[i] === arr[i + 1] ? newArr : newArr.push(arr[i])
            }
            return newArr;
        }
```

### 7.splice

```js
 function newArrFn7() {
            //遍历数组 两两比较 相同的话 切割去掉当前的数组数据
            for (let i = 0; i < arr.length; i++) {
                for (let j = i + 1; j < arr.length; j++) {
                    console.log('循环次数');
                    if (arr[i] === arr[j]) {
                        arr.splice(j, 1); //参数1：下标 参数2：删除的个数  
                        j--; //数组删除了一个元素
                    }
                }
            }
            return arr;
        }
```



## 二、算法相关概念介绍

### 1. 算法概述

**<font color='red'>算法</font>**（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述**<font color='red'>解决问题的策略机制</font>**。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。<font color='red'>**一个算法的优劣可以用空间复杂度与时间复杂度来衡量**。</font>

**简单来说，算法就是解决某些问题的一种计算方式，它可以在有限的时间和空间内对问题进行解决，最终得到一个结果**。
​**同一类问题，可能有多种算法解决方案，评价某个算法的好坏就看它在解决问题过程中花费的时间多少和占用的空间大小**。

### 2. 算法特征

算法具备如下五个重要的特征：

* 有穷性(Finiteness)：算法的有穷性是指算法必须能在执行有限个步骤之后终止。
* 确切性(Definiteness)：算法的每一步骤必须有确切的定义。
* 输入项(Input)：一个算法有0个或多个输入，以刻画运算对象的初始情况。所谓0个输入是指算法本身定出了初始条件。
* 输出项(Output)：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的。
* 可行性(Effectiveness)：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。

### 3. 算法的分类

常见排序算法可以分为两大类：

- <font color='red'>**比较类排序**</font>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。

- <font color='red'>**非比较类排序**</font>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

  ![1](images\1.png)

### 4.相关概念

稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面(冒泡、插入)。

不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面(选择、快排)。

时间复杂度：对排序数据的总的操作次数。

空间复杂度：是指算法在计算机内执行时所需存储空间的度量。 

## 三、排序

### 1.冒泡排序（Bubble Sort）

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

#### 1.1算法描述

1）比较相邻的元素。如果第一个比第二个大，就交换它们两个；

2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；

3）针对所有的元素重复以上的步骤，除了最后一个；

4）重复步骤1~3，直到排序完成。

#### 1.2动画演示

![2](images\2.gif)

#### 1.3代码实现

```javascript
function bubbleSort(arr) {
    //外层循环控制趟数
    for (var i = 0; i < arr.length - 1; i++) {
        //内层循环控制相邻两个数的比较
        for (var j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) { // 相邻元素两两对比
                var temp = arr[j + 1]; // 元素交换
                arr[j + 1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

### 2.**选择排序（Selection Sort）**

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

#### 2.1算法描述

1）将无序区中最小的元素和无序区的第一个元素互换位置

2）查找最小值,必须找到最小值的索引

#### 2.2动画演示

![3](images\3.gif)

#### 2.3代码实现

```javascript
//选择排序
function selectionSort(arr) {
    //声明最小值的下标
    var minIndex, temp;
    //外层循环控制趟数
    //无序区的第一个元素的索引从0开始,依次递增,使用i来代表
    for (var i = 0; i < arr.length - 1; i++) {
        // 内层循环控制本趟的无序区的最小元素索引的查找
        //假设无序区的第一个元素就是最小值,再依次和后面的元素比较
        minIndex = i;
        //j的取值从无序区的第一个元素开始到最后
        for (var j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) { //寻找最小的数
                minIndex = j; //将最小数的索引保存
            }
        }
        //将无序区的最小值和无序区的第一个元素交换位置
        if (i !== minIndex) {
            temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
    return arr;
}
```

### 3.**插入排序（Insertion Sort）**

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入（将无序区的第一个元素插入到有序区的合适的位置，插入之后保证有序区依然有序）。

#### 3.1算法描述

1）从第一个元素开始，该元素可以认为已经被排序；

2）取出下一个元素，在已经排序的元素序列中从后向前扫描；

3）如果该元素（已排序）大于新元素，将该元素移到下一位置；

4）重复步骤3，直到找到该元素（已排序）小于或者等于新元素；将新元素插入到该位置后；

5）重复步骤2~5。

#### 3.2动画演示

![4](images\4.gif)

#### 3.3代码实现

```javascript
//插入排序
function insertionSort(arr) {
    // 外层循环控制趟数
    // i控制了循环的次数 也代表了无序区的第一个元素的下标
    for (var i = 1; i < arr.length; i++) {
        //current表示无序区的第一个元素
        var current = arr[i];
        //内层循环进行本趟的current和合适的位置的查找(从后往前查找)
        //从后往前拿到有序区的所有数组元素
        //arr[j]>current -- 有序区的元素大于无序区第一个元素
        for (var j = i - 1; j >= 0 && arr[j] > current; j--) {
            //所有比current大的有序区的元素,依次后移
            arr[j + 1] = arr[j];
        }
        //将current赋值给最后移动的那个元素的位置上
        arr[j + 1] = current;
    }
    return arr;
}
```

### 4.快速排序（Quick Sort）

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

#### 4.1算法描述

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

1）选择数组中间数作为基数，并从数组中取出此基数；

2）准备两个数组容器，遍历数组，逐个与基数比对，较小的放左边容器，较大的放右边容器；

3）递归处理两个容器的元素，并将处理后的数据与基数按大小合并成一个数组，返回。

#### 4.2动画演示

![5](images\5.gif)

#### 4.3代码实现

```javascript
//  快排
function quickSort(arr) {
    //递归结束的条件
    if (arr.length <= 1) {
        return arr;
    }
    //定义基准值
    //确定基准值的下标
    var pivotIndex = Math.floor(arr.length / 2);
    //确定基准值 并在原数组中删除基准值
    //splice返回删除的数组元素组成的新数组
    var pivot = arr.splice(pivotIndex, 1)[0];
    var left = []; //存储比基准值小的数组元素
    var right = []; //存储比基准值大的数组元素
    //拿到所有数组元素
    for (var i = 0; i < arr.length; i++) {
        //比基准值小的元素添加到left数组中
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else { //比基准值大的元素添加到right数组中
            right.push(arr[i]);
        }
    }
    //left和right数组重复执行上面的操作
    return quickSort(left).concat([pivot], quickSort(right));
}
```

## 四、折半查找(二分查找)

### 1. 概述

折半查找又称为二分查找，这种查找方法需要待查的查找表满足两个条件：

二分查找：是一种搜索某个值的索引的算法。

基本条件：有序的数组。

思路：

​	1）将数组折半，分成左右两个数组。

​	2）判断要查找的数和中间位置数值的大小，来判断要查找的数是在哪一半。

​	3）之后继续折半查找，直至找到这个数。

### 2. 查找演示

key = 21 的查找过程：

![image-20220119140339169](images\image-20220119140339169.png) 

key = 85的查找过程：

![image-20220119140405450](images\image-20220119140405450.png) 

### 3. 循环实现

```javascript
//对指定的数组进行二分查找指定的值,找到返回对应的索引,否则返回-1
function binarySearch(arr, key) {
    //low--表示待搜索区域的开始位置
    //high--表示待搜索区域的结束位置
    var low = 0;
    var high = arr.length - 1;
    //中间值的索引
    var mid;
    while (high >= low) {
        //每次搜索的范围发生改变后,需要重新定义中间值的索引
        mid = Math.floor((low + high) / 2);
        //获得中间值的索引以后,用该索引的元素和待搜索的值进行比较
        //如果mid的值和key相等 返回mid
        if (arr[mid] === key) {
            return mid;
        } else if (arr[mid] > key) {
            //如果mid的值比key大 改变high到mid-1
            high = mid - 1;
        } else if (arr[mid] < key) {
            //如果mid的值比key小 改变low高mid+1
            low = mid + 1;
        }
    }
    //循环结束没有查找到 返回-1
    return -1;
}
```

### 4. 递归实现

```javascript
function binSearch(arr, start, end, key) {
    var mid = Math.floor((end + start) / 2);
    if (start > end) {
        return -1;
    }
    if (arr[mid] == key) {
        return mid;
    } else if (key > arr[mid]) {
        return binSearch(arr, mid + 1, end, key);
    } else {
        return binSearch(arr, start, mid - 1, key);
    }
}

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var result = binSearch(arr, 0, arr.length - 1, 31);
console.log(result);
```

