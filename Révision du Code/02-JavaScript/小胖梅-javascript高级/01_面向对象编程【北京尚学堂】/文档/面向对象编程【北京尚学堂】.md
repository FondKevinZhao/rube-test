![图片](./images/logo.png)

# 面向对象编程

**主要内容**

* 面向对象介绍
* 通过原始模式创建对象
* 通过构造函数创建对象
* new命令
* this

**学习目标**

| 知识点               | 要求 |
| -------------------- | ---- |
| 面向对象编程思想     | 了解 |
| 原始方式创建对象     | 掌握 |
| 使用构造函数创建对象 | 掌握 |
| new命令              | 掌握 |
| this                 | 掌握 |

## 一、面向对象介绍

### 1. 面向过程和面向对象的区别

<span style="color: red;">面向过程编程</span>（Process Oriented Programming，缩写为POP）就是分析出解决问题所需要的 <span style="color: red;">步骤</span>，然后用 <span style="color: red;">函数</span>把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

<span style="color: red;">面向对象编程</span>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程方式。它将真实世界各种复杂的关系，抽象为若干个 <span style="color: red;">对象</span>，然后让对象具有需要的属性和功能,再通过对象之间的分工与合作，完成对真实世界的模拟。

面向对象的三大特征是 <span style="color: red;">继承、封装、多态</span>。JS可以模拟实现继承和封装，但是无法模拟实现多态，所以我们说JS是一门 <span style="color: red;">基于对象</span>的语言，而非是面向对象的语言。

![2](images\2.jpg)

```javascript
//例子：将大象装进冰箱
//面向过程
//①打开冰箱  ②把大象装进去  ③关上冰箱门
function open() {
    console.log('冰箱门被打开了');
}
function elephantIn() {
    console.log('大象进入冰箱了');
}
function close() {
    console.log('冰箱门关上了');
}
open();
elephantIn();
close();

//面向对象
// 将问题中的事物抽象为对象，一个大象，一个冰箱
var elephant = {
    name: '宝宝大人',
    enterFridge: function (fridge) {
        console.log(this.name + '钻进了' + fridge.name);
    }
};
var fridge = {
    name: '海尔',
    open: function () {
        console.log(this.name + '的门打开了');
    },
    close: function () {
        console.log(this.name + '的门关上了');
    }
};
fridge.open();
elephant.enterFridge(fridge);
fridge.close();
```

### 2. 面向过程与面向对象的优缺点

用面向过程的方法写出来的程序是一份 <span style="color: red;">蛋炒饭</span>，而用面向对象写出来的程序是一份 <span style="color: red;">盖浇饭</span>。蛋炒饭最后的一道工序肯定是把米饭和鸡蛋混在一起炒匀。盖浇饭呢，则是把米饭和盖菜分别做好，你如果要一份红烧肉盖饭呢，就给你浇一份红烧肉；如果要一份青椒土豆盖浇饭，就给浇一份青椒土豆丝。盖浇饭的好处就是"菜"“饭"分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是 <span style="color: red;">"可维护性"比较好</span>，“饭” 和"菜"的 <span style="color: red;">耦合度比较低</span>。蛋炒饭将"蛋”“饭"搅和在一起，想换"蛋”"饭"中任何一种都很困难， <span style="color: red;">耦合度很高</span>，以至于 <span style="color: red;">"可维护性"比较差</span>。

 ![1](images\1.webp)

#### **2.2.1面向过程**

优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;

缺点：没有面向对象易维护、易复用(耦合度高,可维护性差)

#### **2.2.2面向对象**

优点：易维护、易复用，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护

缺点：性能比面向过程低

### 3. 怎样创建对象

创建对象可以使用两种方式：

1. 原始模式（前面已经学过）
2. 构造函数模式

## 二、原始模式创建对象

### 1. 原始模式创建对象

假设我们将某个学生看做是一个对象，他有`姓名`和`年龄`两个属性。

```javascript
var Student = {
    name:'',
    age:0
}
```

现在，我们就可以根据这个原型对象的规格（schema），生成两个实例对象。

```javascript
var student1 = {}; //创建一个空对象
student1.name = '张三'; //按照原型对象的属性赋值
student1.age = 20;

var student2 = {};
student2.name = '李四';
student2.age = 18;
```

问题：

目前我们使用原始的方式创建了对象，也将两个属性封装在一个对象中了。但是这种写法有两个缺点：

1. 如果多生成几个对象的话，写起来就非常麻烦了
2. 实例与原型之间，看不出来有什么实际上的联系

### 2. 原始模式的改进

我们可以写一个函数，解决上面创建对象时存在的一些的问题。

```javascript
function Student(name, age){
    return {
        name:name,
        age:age
    };
}
```

然后生成实例对象，就等于是在调用函数：

```javascript
var student1 = Student('张三', 19);
var student2 = Student('李四', 25);
```

利用目前这种方式，虽然可以很快的创建出多个对象，但是还是存在问题：`student1`和`student2`之间没有内在的联系，不能反映出他们是同一个原型对象的实例。

## 三、构造函数模式创建对象

### 1. 自定义构造函数

面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常 <span style="color: red;">需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</span>

典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是 <span style="color: red;">基于构造函数（constructor）和原型链（prototype）</span>。

 ![2](images\11.jpg)

​	![2](images\22.jpg)

<span style="color: red;">JavaScript 语言使用构造函数（constructor）作为对象的模板。</span>所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。

构造函数就是一个普通的函数，但具有自己的特征和用法。为了与普通函数区别， <span style="color: red;">构造函数名字的第一个字母通常大写</span>。

#### **1.1创建构造函数1**

注意：箭头函数不可以创建构造函数（**箭头函数没有自己的this，而是继承父作用域中的this**。）

```javascript
var age = 18;
let obj = {
    age: 28,
    fn1: function () {
        console.log(this.age);//28
    },
    fn2: () => {
        console.log(this.age);//18
    }
}
obj.fn1();
obj.fn2();
```

 ```javascript
 //语法1 函数声明
         function 构造函数名(){
             this.属性1=value1;
             this.属性2=value2;
             ...
         }
 //语法2 函数表达式
         var 构造函数名 = function(){
             this.属性1=value1;
             this.属性2=value2;
             ...
         }
 // 创建学生的构造函数
         function Student() {
             this.name = '王一博';
             this.age = 20;
             this.gender = '男';
             this.study = function () {
                 console.log(this.name + '热爱街舞');
             }
         }
 //使用构造函数创建学生对象--对象的实例
         var stu1 = new Student();
         var stu2 = new Student();
         console.log(stu1 == stu2); //false
 ```

上面代码中，Student就是构造函数。但是上述的构造函数创建的对象的属性和功能是一致的，我们希望对象之间是存在差异的。

#### **1.2创建构造函数2**

```javascript
//模板
//语法1
        function 构造函数名(value1,value2,...){
            this.value1=value1;
            this.value2=value2;
            ...
        }
//语法2
        var 构造函数名 = function(value1,value2,...){
            this.value1=value1;
            this.value2=value2;
            ...
        };
//【实例】
// 创建学生的构造函数
        function Student(name, age, gender) {
        //构造函数中的this表示生成的对象的实例
            this.name = name;
            this.age = age;
            this.gender = gender;
            this.study = function () {
                //this表示调用study的对象
                console.log(this.name + '热爱街舞');
            }
        }
//使用构造函数创建学生对象--对象的实例
        var stu1 = new Student('王一博', 24, '男');
        var stu2 = new Student('王博', 20, '男');
```

### **2.构造函数的特点**

​	1）函数体内部使用了 <span style="color: red;">this</span>关键字，代表了所要生成的 <span style="color: red;">对象实例</span>。

​	2）生成对象实例的时候， <span style="color: red;">必须</span>使用new命令。

​	3）定义构造函数的目的是为了通过它去创建若干个对象。

​	4）构造函数在创建对象的过程中充当模板的角色。

### **3.new命令**

#### **3.1**基本用法

new命令的作用，就是 <span style="color: red;">执行构造函数</span>，返回一个实例对象。

```javascript
var Student = function () {
    this.name = '王一博';
}
var s = new Student();
console.log(s.name); //王一博
```

上面代码通过new命令，让构造函数Student生成一个实例对象，保存在变量s中。这个新生成的实例对象，从构造函数Student得到了name属性。new命令执行时， <span style="color: red;">构造函数内部的this，就代表了新生成的实例对象</span>，this.name表示实例对象有一个name属性，值是’王一博’。

使用new命令时，根据需要，构造函数也可以接受参数。

```javascript
var Student = function (name) {
    this.name = name;
}
var s = new Student('王一博');
console.log(s.name); //王一博
```

new命令本身就可以执行构造函数，所以后面的构造函数 <span style="color: red;">可以带括号，也可以不带括号</span>。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。

```javascript
// 推荐的写法
var s = new Student();
// 不推荐的写法
var s = new Student;
```

#### **3.2不使用new调用构造函数**

一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？

这种情况下，构造函数就变成了 <span style="color: red;">普通函数</span>，并不会生成实例对象。 <span style="color: red;">this这时代表全局对象</span>，将造成一些意想不到的结果。

```javascript
var Student = function () {
    this.age = 20;
}
var s = Student();//调用函数 函数的默认返回值为undefined
console.log(s); //undefined
console.log(age); //20
```

上面代码中，调用Studeng构造函数时，忘了加上new命令。结果，变量s变成了undefined，而age属性变成了全局变量。因此，应该非常小心，避免不使用new命令、直接调用构造函数。

<font color='red'>为了保证构造函数必须与new命令一起使用</font>，一个解决办法是， <span style="color: red;">构造函数内部使用严格模式</span>，即第一行加上 <span style="color: red;">‘use strict’</span>。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。

```javascript
var Student = function (name, age) {
    'use strict'
    this.name = name;
    this.age = age;
}
var s = Student();
//TypeError: Cannot set properties of undefined (setting 'name')
```

上面代码的Student为构造函数，use strict命令保证了该函数在严格模式下运行。由于<font color='red'>严格模式中，函数内部的this不能指向全局对象，默认等于undefined，</font>导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。

另一个解决办法， <span style="color: red;">判断this是否是构造函数的实例</span>，如果不是直接返回一个实例对象。

```javascript
var Student = function (name, age) {
    //this不是构造函数的实例
    if (!(this instanceof Student)) {
        //直接返回一个实例对象
        return new Student(name, age);
    }
    this.name = name;
    this.age = age;
}
var s1 = Student('王一博', 24);
var s2 = new Student('王博', 20);
```

上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。

#### **3.3**new 命令的原理

使用new命令时，它后面的函数依次执行下面的步骤。

​	1）申请一块堆内存，创建一个空对象，作为将要返回的对象实例。并将该空对象赋值给this，this就代表了刚刚创建的对象。

​	2）将实参的值赋值给形参。

​	3）给this从上到下绑定属性。

​	4）所有的属性绑定完毕之后，对象初始化完毕。

​	5）由new关键字将创建好并初始化完毕的对象的地址赋值给左边的变量。

也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。

### **4.构造函数中的返回值**

如果构造函数内部有return语句，而且 <span style="color: red;">return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。</span>

```javascript
var Studeng = function () {
    this.name = '王一博';
    //构造函数中返回字符串
    return '王博';
}
var s = new Studeng();
console.log(s.name);//王一博
```

上面代码中，构造函数Student的return语句 <span style="color: red;">返回一个字符串</span>。这时，new命令就会 <span style="color: red;">忽略这个return语句</span>，返回“构造”后的this对象。

但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。

```javascript
var Studeng = function () {
    this.name = '王一博';
    //构造函数中返回对象
    return {
        name: '王博'
    };
}
var s = new Studeng();
console.log(s.name); //王博
```

上面代码中，构造函数Student的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。

### **5.构造函数的优缺点**

#### **5.1优点**

构造函数定义了一个模板，使用该模板，可以更方便快捷的创建若干个对象。而且创建的对象是有类型的，自定义的类型。

#### **5.2缺点**

构造函数创造的对象会极大的影响着浏览器的内存，影响系统的运行效率。通过构造函数创建的对象，每个对象都具有自己的私有属性的内存空间，对于对象的方法也是每个对象一份，对于 <span style="color: red;">不同对象相同的方法不能实现对象之间的共享，浪费了内存。</span>



### **6.练习**

```javascript
//老师一对多教学
//老师的模板
function Teacher(name, age, gender, subject) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.subject = subject;
    //students是一个学生数组
    this.teach = function (students) {
        console.log(`${this.name}用心教学`);
        for (var i = 0; i < students.length; i++) {
            console.log(`${students[i]}的成绩刷刷的提高`);
        }
    }
}

//学生模板
function Student(name, age, gender, score) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.score = score;
    this.study = function () {
        console.log(`${this.name}同学努力学习,成绩从${this.score}提高到了${++this.score}`);
    }
}
// 创建学生的实例
var stu = new Student('王一博', 24, '男', '66');
console.log(stu);
stu.study();
//创建老师实例
var shi = new Teacher('小胖梅', 18, '女', 'javascript');
console.log(shi);
var students = ['王一博', '王博', '张艺兴', '郭艾伦', '张杰'];
shi.teach(students);
```

### **7.this三种指向**

this主要有以下几个使用场合。

1.以函数调用

2.以构造函数调用

3.以对象方法调用



#### 7.1普通函数

全局环境使用this，它指的就是顶层对象window。

```javascript
this === window // true
function f() {
  console.log(this === window);
}
f() // true
```

上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。

#### **7.2**构造函数 

构造函数中的this，指的是实例对象。

```javascript
function P(name) {
    this.name = name;
}
var p1 = new P('王一博');
```

上面代码定义了一个构造函数P。由于this指向实例对象，所以在构造函数内部定义this.name，就相当于定义实例对象有一个name属性。

#### **7.3**对象的方法

如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。

```javascript
var obj1 = {
    name: '王一博',
    say: function () {
        console.log(`大家好,我叫${this.name}`);
    }
}
var obj2 = {
    name: '王博'
}
obj1.say(); //大家好,我叫王一博
obj1.say.call(obj2); //大家好,我叫王博
```

#### 7.4 修改this指向

计时器setTimeout() setInterval() this指向window 

call apply bind修改this指向

IIFE立即执行函数 没有明确this指向，默认window 

this出现在箭头函数中时，this和父级作用域的this指向相同

```js
 let obj = {
            name: '前端小白',
            show: function () {
                console.log(this);//指向obj对象
                setTimeout(function () {
                    console.log('setTimeout里面的this', this);//window
                }, 10);
            },
            count: function () {
                setTimeout(() => {
                    console.log(this);//obj对象
                }, 10);
                // console.log(this);//window
                // setInterval(function(){
                //     console.log(this);//window
                // },1000)
            }
        }
        obj.show();
        obj.count()
```

call apply

```js
 let aa = {
            a: 10
        }
        function fn1() {
            console.log(this);//window
            console.log(this.a);//undefined
        }
        function fn2() {
            console.log(this);//aa{ a:10 }
            this.a = 30;
            fn1();
        }
        fn2.call(aa);
        console.groupEnd()
```

立即执行函数

```js
var obj2 = {
            name: "小明",
            showName: function () {
                console.log(this.name); //小明
                (function () {
                    console.log('this.name自执行函数：',this.name) // '' this->window 
                })();
            }
        }

        obj2.showName();

        (function(){
            console.log('IIFE',this);//window
        })()
```



## 四、作业

### 构造函数实现躁动的小球

