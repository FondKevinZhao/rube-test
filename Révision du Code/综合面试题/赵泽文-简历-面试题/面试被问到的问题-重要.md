## history 模式怎么配置？

在 pages 的 index.js 中配置：

```js
const router = new VueRouter({
    mode: 'history',
    routes: [
        {
            name: 'guanyu',
            path: '/about',
            component: About,
            meta:{isAuth:true,title:'关于'}
        }
    ]
})
```

vue3中使用的路由模式是：

```js
const router = new VueRouter({
    history: 'createWebHashHistory', // 使用hash模式
  	// history: 'createWebHistory', // 使用history模式
    routes: [
        {
            name: 'guanyu',
            path: '/about',
            component: About,
            meta:{isAuth:true,title:'关于'}
        }
    ]
})
```



## 谈谈你对 iframe 的了解

`<iframe>` 标签规定一个内联框架。一个内联框架被用来在当前 HTML 文档中嵌入另一个文档（可以是本地 html 页面，也可以是第三方网页）。

所有的主流浏览器都支持`<iframe>`标签。你可以把提示的文字放到` <iframe>` 和 `</iframe>`里面，这样不支持` <iframe>`的浏览器就会出现提示的文字。

使用 iframe 是不是一个好的用法（good practice），不能一概而论，但是可以肯定是，现在的大部分网站避免采用这种方式的。

比较早期的网站使用 iframe，主要是用于导航栏（navigator）。为什么？
因为一个网站很多页面的导航栏部分是相同的，在避免切换页面的时候重复下载，将导航栏和正文分开在 iframe 中，是一个方便的做法。
同时带来的不利是，默认情况下，使用了 iframe 的网站的 URL 不会随着页面的变化而变化。
这就意味着一旦刷新，网站可能又回到首页。
那么现在的网站是如何解决不同页面使用相同的 navigator 而避免重复编码呢？
不同后台技术都有自己的方法，比如 ASP 有 SSI，PHP 有 require、require_once 或 include 函数，JSP 也有 include 指令。

iframe 一直是浏览器标准规范之一，只有很早期的浏览器不支持 iframe，现在几乎已绝迹。
所以从兼容性上来说，iframe 是没问题的。

那么现在什么时候会用到 iframe 呢？
因为 iframe 的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent 的 CSS 或者全局的 JavaScript 的影响。
典型的，比如所见即所得的网页编辑器（WYSIWYG Online HTML Editor），因为它们需要 reset 自己的 CSS 到自己的标准，而不被 parent CSS 的 override。 

说到上面一点了，顺便说一下，知乎的这个编辑器不是用 iframe，它使用了一种叫 contentEditable 的属性，用来启用页面元素的编辑，在早期版本 IE 下不支持的。

正是因为刚刚提到的 iframe 等于新建了一个全新的，不受 parent 影响的页面上下文，所以在一定程度上，类似于沙箱隔离（sandbox）。
除此之外，如果有可以不用 iframe 来解决的问题，还是避免使用 iframe。
替代方案一般就是动态语言的 include 机制、ajax 动态填充内容，以及以后会普及的 contentEditable。



## 谈一谈 http 缓存

**定义：**http 缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。

常见的 http 缓存只能缓存**get**请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指 GET 请求。http 缓存都是从第二次请求开始的。

**分类：**

1. 根据是否需要重新向服务器发起请求来分类，可分为**强制缓存**和**协商缓存**。

2. 根据是否可以被单个或者多个用户使用来分类，可分为**私有缓存**和**共享缓存**。

   **强制缓存：**强制缓存在缓存数据未失效的情况下（即 Cache-Control 的 max-age 没有过期或者 Expires 的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。

   **协商缓存：**当第一次请求时服务器返回的响应头中没有 Cache-Control 和 Expires **或者** Cache-Control 和 Expires 过期，**还或者**它的属性设置为 no-cache 时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。

   

   **分类注意点：**强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。

**为什么要使用 HTTP 缓存：**

1. 减少了冗余的数据传输，节省了网费。
2. 缓解了服务器的压力， 大大提高了网站的性能。
3. 加快了客户端加载网页的速度。

**总结：**

1、对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行协商缓存策略。
2、对于协商缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。

[博客地址](https://www.jianshu.com/p/227cee9c8d15)



## 谈一谈 浏览器 缓存

**定义：** web 缓存是指一个 web 资源（如 html 页面，图片，js，数据等）存在于 web 服务器和客户端（浏览器）之间的副本。

浏览器缓存方式：

1、http 缓存：是基于 HTTP 协议的浏览器文件级缓存机制。
2、websql：这种方式只有较新的 chrome 浏览器支持，并以一个独立规范形式出现。
3、indexDB：是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。
4、Cookie：一般网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。
5、Localstorage：html 5 的一种新的本地缓存方案，目前用的比较多，一般用来存储 ajax 返回的数据，加快下次页面打开时的渲染速度。
6、Sessionstorage：和 localstorage 类似，但是浏览器关闭则会全部删除，api 和 localstorage 相同，实际项目中使用较少。
7、application cache：是将大部分图片资源、js、css 等静态资源放在 manifest 文件配置中。
8、cacheStorage：是在 ServiceWorker 的规范中定义的，可以保存每个 serverWorker 申明的 cache对象。

**作用：** 

1. 减少网络宽带消耗。
2. 降低服务器压力。
3. 减少网络延迟，加快页面打开速度。

1. http 缓存和浏览器缓存的区别：

   前端缓存主要是分为 HTTP 缓存和浏览器缓存。

   1. HTTP 缓存是在 HTTP 请求传输时用到的缓存，主要在服务器代码上设置。
   2. 而浏览器缓存则主要由前端开发在前端 js 上进行设置。



## h5 适配怎么做？

flexible 是淘宝开源的 h5 适配方案，手机淘宝从14年开始至今一直在使用，比较稳定，并且在开发过程中不要进行复杂的折算，直接使用设计稿中的尺寸，方便好用。该方法是主流的 h5 前端开发方案之一。

**使用方法：**

1. Flexible 的使用方法非常简单，只需要引入 flexible_css.js 和 flexible.js [下载地址](https://github.com/amfe/lib-flexible)

2. 将 px 转成 rem。

   如果按 750px 的设计稿进行开发，为了方便换算，flexible 将屏幕宽度为 750 的`<html>`元素设置 font-size 为 75px，我们将 75px 称之为 rem 基准值，针对这份设计稿，我们可以知道 1rem=75px。

3. 字号不要使用 rem。

   在不同的屏幕下，我们是不希望看到字号也随屏幕缩放，我们希望在小屏上看清文本，在大屏上看到更多的文本，所以字号还是用 px 单位设置，以及现在绝大多数的字体是点阵字体，通常是 16px 和 24px，所以不希望出现 13px、15px 这样的奇葩尺寸。

   根据 flexible 的适配方案，dpr = 2 时`<meta name="viewport">` initial-scale 属性为 0.5，dpr = 3 时`<meta name="viewport">`initial-scale 属性为 0.3333333333

## 什么是 SaaS 平台？

- 什么是 SaaS？

SaaS 是一种软件布局模型，其应用专为[网络](https://baike.baidu.com/item/网络/143243)交付而设计，便于用户通过互联网托管、部署及接入。

* 什么是 SaaS 平台？

[SaaS](https://baike.baidu.com/item/SaaS)平台是运营 saas 软件的平台。SaaS 提供商为企业搭建信息化所需要的所有[网络基础设施](https://baike.baidu.com/item/网络基础设施/5183560)及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无需购买软硬件、建设[机房](https://baike.baidu.com/item/机房/5066792)、招聘IT人员，即可通过[互联网](https://baike.baidu.com/item/互联网/199186)使用信息系统。

**白话解释：**就像打开自来水龙头就能用水一样，企业根据实际需要，从 SaaS 提供商租赁软件服务。



## v-html

v-html：如果插值语法中 HTML 元素会被解析成 HTML 渲染到页面。

```html
<body>
    <div id="app">
        <p v-cloak>{{ msg }}</p>
        <p v-text="msg"></p>
    </div>

    <script type="text/javascript">
        var vm = new Vue({
            el : "#app",
            data : {
                msg : "<h1>这是一个h1元素内容</h1>"
            }
        });
    </script>
</body>
```



## css3 实现无缝滚动防抖

问题：图片加文字的无缝滚动，在手机端的效果总体还行，但是图片在手机某些浏览器会抖得厉害。

解决方法：

里面的某个元素在手机端会抖动的厉害，改用二维的 translate，如：

```js
.donghua.active{
  animation: scoll ease-in-out 1s infinite alternate;
  -webkit-animation: scoll ease-in-out 1s infinite alternate;
}
@keyframes scoll {
  0% {
    transform: translate(0px, 0px);
  }

  100% {
    transform: translate(0px, -353px);
  }
}
@-webkit-keyframes scoll {
  0% {
    transform: translate(0px, 0px);
  }

  100% {
    transform: translate(0px, -353px);
  }
}
```

animation 中的值：

- ease-in-out：慢速开始和慢速结束的过渡效果(相对于匀速，（开始和结束都慢）两头慢)。
- ease：慢速开始，然后变快，然后慢速结束(两头慢，中间块)。
- ease-in：慢速开始，之后一直快。
- ease-out：开始快，之后一直慢。
- linear：匀速开始和结束。

## Vue 递归组件实现多级列表

[Vue 递归组件实现多级列表](https://www.tqwba.com/x_d/jishu/418026.html)

## 快速将字符串转成数值

```js
// 题目：快速将字符串转换为数值
var str = '99';
// 想办法转换成数值型。
// 方法一：
console.log(Number(str)); // 99
// 方法二：
console.log(parseInt(str)); // 99
// 方法三：
console.log(parseFloat(str)); // 99
// 方法四：
console.log(str - 0); // 99 // str 会调用Number()转换为99。
// 方法五：
console.log(+str); // 99
```



## Vue 下拉框 select 的分段加载解决数据过大导致页面卡顿

**原因：**下拉框数据过多，若渲染全部数据，会导致 DOM 数量太多，操作卡顿。

**解决：**比如说这是一个关于活动的下拉框，有 活动名 和 活动列表

1. 定义 filter-method="事件名"，这是 element 提供的自定义事件方法。过滤出自己需要的数组对象数据。
2. 将获取到的 活动名 和 活动列表 分离开，限制渲染数组的长度。
3. 存储符合条件的下拉选项。并且限制数据的长度，比如说取前一百个：`this.activityList = result.slice(0,100)`

[博客地址](https://www.cnblogs.com/huoshengmiao/p/13764176.html)



## localStorage 安全性问题：

现在越来越多的前端人员把性能优化的目标指向了本地存储，利用 localStorage 来进行本地资源缓存，因为其大小上限为 5MB，可以装相当多的东西，甚至在FireFox中你还可以修改这个上限。

虽然说这个 localStorage 非常好用但也存在安全隐患，如果我们将恶意代码植入里面那么这段恶意代码也会一直存在知道用户清空我们的 localStorage 为止

 

我们可以看一段代码: 将原来 localStorage 存储的 name 数据赋值给 id 为 test 的页面元素 我们可以设想万一里面是恶意代码呢？

```html
<body>
<div id="test"></div>
<script>
 localStorage.setItem('name','xiaohua');
 document.getElementById('test').innerHTML = localStorage.name;
</script>
</body>
```

解决方案：

1. 存在前端的东西都没有安全性可言，所以随便存。如果怕别人看到，加个密也行。
2. token 本身就可以认为是个加密的东西，只要用户名等敏感的东西不要暴露出去就行。后端要做好定时失效机制。
3. 前端存token，使用localStorage还是cookie没有什么安全性可言，可以让服务端做个token超时。
4. 可以在前端二次加密，后端返回token后，前端进行二次加密。

## get 和 post 的区别: 

1. get上传的数据, 会出现在浏览器的地址栏中。 post 存放在请求主体中 。

2. get 不安全，post 相对安全。

3. get 一般用于获取数据，post 一般用于获取数据。

4. get 请求的数据量有限制(浏览器地址栏有大小，不同的浏览器的大小限制是不一样的)，post 请求上传的数据理论上没有限制(实际上服务器会对上传的数据，进行限制)。

   

## Vue 中做 权限管理 使用 router.addRoutes() 动态添加路由

Vue 中做 权限管理 使用 router.addRoutes() 动态添加路由以及解决刷新失效，跳转后刷新失效问题：[博客地址](https://blog.csdn.net/qq_31906983/article/details/88942965)

权限管理思路与实现

1. 当用户点击登录的时候，验证成功后，可以获取当前用户的id（token）存储到sessionStorage中。
2. 根据 '后台返回的权限列表（getList）'，去比对 '我们提前定义好的权限列表（powerList）'，然后得出 '应该动态添加的权限列表（list）' ，并存放到vuex中，最后执行addRoutes把比对出来的权限路由列表动态添加到路由中即可。
3. 进入home页面，渲染侧边栏。



## 项目中创建时，都是 cv 的项目配置，一个有问题就需要都改，如何解决？

- 如果 cv 了很多配置出问题了，看控制台报错，按照报错去处理。如果有问题还不报错，把其他的配置注释起来，再一段段的测试出现的位置。

- 一般在 cv 东西的时候，需要注意一下，cv 一段最好看一下控制台有没有报错，就算出错了，我也能够知道就是刚才 cv 的代码出问题了。

## forEach、map、filter、reduce 的区别

相同点：

1. 都会循环遍历数组中的每一项。
2. map()、forEach() 和 filter 方法里没执行匿名函数都支持 3 个参数，参数分别是：当前元素、当前元素的索引、当前元素所属的数组。
3. 匿名函数中的 this 都是指向 window。

不同点：

1. map() 的速度比 forEach() 快。
2. map() 和 filter() 会返回一个新数组，不对原数组产生影响。forEach() 不会产生新数组，返回 undefined，reduce() 函数是把数组缩减为一个值(比如求和、求积)。
3. reduce() 有 4 个参数，第一个参数为初始值。

[博客地址](https://www.cnblogs.com/kaiqinzhang/p/11496151.html)

## 哪些会触发 Vue 的响应式？

1. vue中重写的方法(如：push、pop、shift、unshift、sort、reverse、splice
2. 使用ref、reactive定义的数据发生变化
3. computed 的内容发生变化
4. watch 所监视的内容发生变化
5. 定义的函数被触发



## 项目发布后，用户访问到之前的，怎么解决？

今天遇到一个奇葩问题，web端的后台管理系统发布成功后，用户说功能没有更新，还是之前的版本，我就纳闷了，确实已经更新成功了，后来仔细检查发现竟然是缓存造成的，清除了一下浏览器缓存，再打开就是最新版本了。

[清除浏览器方法](https://blog.csdn.net/m0_46156566/article/details/108519629)

## set 和 map 数据类型，是否用过？

## e-charts 用得多吗？

## 用户权限如何控制？

- 控制的第一步是知道用户拥有哪些权限，所以用户登录后第一件事是获取权限数据。
- 有了权限数据下一步就是分别-实现对路由、视图、请求的控制。
- 路由控制的思路有两种，一种是初始化即挂载全部路由，每次路由跳转前做校验；另一种是只挂载用户拥有的路由，相当于从源头上做了控制。

[博客地址](https://blog.csdn.net/GitChat/article/details/78849246)

## 如果一个用户的 token 被其他用户劫持了，怎样解决这个安全问题？

1. 在存储的时候把 token 进行对称加密存储，用时解开。
2. 将请求 URL、时间戳、token 三者进行合并签名，服务端校验有效性。
3. HTTPS 对 URL 进行判断。

## cookie 和 token 都存放在 header 中，为什么不会劫持 token？

1. 浏览器发送请求的时候不会自动带上 token，而 cookie 在浏览器发送请求的时候会被自动带上。
2. csrf 就是利用这一特性，所以 token 可以防范 csrf，而 cookie 不能。
3. JWT 本身只关心请求的安全性，并不关心 token 本身的安全。

## git commit --amend 的使用

11. 也就是说，我 git commit -m '这里面的内容，我上次提交打错字了，想只改变这个的内容'

    用 git commit --amend 命令进入 vim 编辑器。

    [博客地址](https://www.jb51.net/article/192486.htm)

12. 















