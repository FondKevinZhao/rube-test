## better-scroll 在下拉加载页面后出现滑动卡顿

解决 Vue 项目中使用 better-scroll 在下拉加载页面后出现滑动卡顿的问题。

场景：在 vue 项目中使用 better-scroll 解决原生滑动不够顺滑的问题，但在下拉加载更多数据时，出现无法下拉，滑动卡顿，但是稍微等一会，就又可以正常下拉滑动。

原因分析：

出现该现象的原因是由于 better-scroll 中的一个属性：scrollerHeight。

1. better-scroll 在决定有多少区域可以滚动时，是根据 scrollerHeight 属性决定的。
2. scrollerHeight 属性是根据放在 better-scroll 中子组件的高度决定的。
3. 但在刚下拉加载时，由于图片加载速度较慢，所以 scrollerHeight 计算的结果是少于实际高度的，就会导致拉到一定高度无法下拉的情况。但是等待一会，图片加载完毕，scrollerHeight 变成实际高度，就又可以正常滚动。

解决方案：

解决方法就是监听每一张图片的加载。然后在每张图片加载完成手动刷新 scrollerHeight 的数值。

- vue中使用 @load="方法" 实现对图片监听。
- 再调用 better-scroll 中的 refresh()。

[博客地址](https://blog.csdn.net/weixin_43402358/article/details/119272273)

## 小程序单页面跳转最大的层数,达到后怎么处理的?

最大页面10个，到达10层了只能由 `redirectTo`不保存当前页跳转。

## Vue-router 跳转刷新页面 Params 参数丢失问题

`vue-router`的跳转传参方式分为 query 和 params 俩种。

1. query 传参数，相当于拼接在 url 后面，这种方式不会丢失参数，但是数据量大的话（比如传递对象），url 就会变得太长而且不隐密。
2. params 传参数，不在 url 中显示，但是刷新页面的时候无法避免丢失。

解决：

1. 使用`this.$router.push({name:"模块名称", query:{// 各参数}})`方式传参。

   缺点：参数值都拼接在 url 上，url 会很长，同时都可以被看到。

2. `this.$router.push({name:"模块名称", params:{// 各参数}})`路由文件设置的时候把参数拼接到 url 里。

   ```js
   // url
   http://localhost:8081/#/paramsPassingByRouter/paramsMode/20180101
   ```

   确定：同上。

3. 1 和 2 结合使用：`this.$router.push({name:"模块名称", params:{//各参数},query:{//各参数}})`。

4. 用 localStorage 存储。

   ```js
   url: http://localhost:8081/#/paamsPassingByRouter/paramsMode/z3
   // 可以与 params 和 query 方式配合使用，可以暴露的参数显示在 url 上，同时刷新参数也不会丢失。
   销毁页面的时候把 localStorage 存储的内容请求。
   ```

[博客地址](https://blog.csdn.net/qq_33456552/article/details/105118120)



## 批量处理接口中的部分数据

后端给你的接口，你只需要该接口里数据的一部分，其他数据不要，让你批量性的实现默认处理？

可以将数据进行过滤，也可以使用 computed。

vue 2.0 之后`limitBy`被计算属性代替, 官方的例子：

```js
<p v-for="item in filteredItems">{{ item }}</p>

computed: {
  filteredItems: function () {
    return this.items.slice(0, 10)
  }
}
```



## 为什么 vue-router 使用 next() 跳转到指定路径时会无限循环？

问题：我不太明白为什么会死循环，我在 home 页面也没有写任何钩子函数来跳到 result 页面啊，我也没有写全局的 beforeEach 钩子函数。

死循环代码：

```js
// 下面的写法会死循环
beforeRouteLeave (to, from, next) {
    console.log('离开路路由')
   next('/home')
}
```

可用的代码：

```js
// 我在路由为 /path 的页面这样写
beforeRouteLeave (to, from, next) {
   console.log('离开路由')
   if(to.fullPath==='/home'){
     next();
   }else{
     next('/home')
}
```



## 编程式路由跳转到当前路由(参数不变)，多次执行会抛出 NavigationDuplicated 的警告错误

原因：vue-router 3.1.0 之后，引入了 promise 的语法。如果没有通过参数指定成功的回调或者失败的回调就返回一个 promise，且内部会判断如果要跳转的路径和参数都没有，会抛出一个失败的 promise。

解决：

1. 在跳转时指定成功或失败的回调函数，或者 catch 处理错误。

   这个解决办法不好，因为不能一劳永逸，后期如果用到了 push/replace 还要继续都得写。

2. 修改 Vue 原型上的 push 和 replace 方法。(优秀)

## 闭包使用场景：

1. 删除某一条数据，通过 ID 或 index 去删除的时候，会使用到闭包。
2. 发送 Ajax 请求成功或失败的回调。
3. setTimeout 的延时回调。

## 节流的使用场景：

1. 滚动加载更多。
2. 搜索框搜索的联想功能。
3. 高频点击。
4. 表单重复提交。
5. **鼠标移动到一级菜单会在右侧出现二级菜单**

## 防抖的使用场景：

1. 搜索框搜索输入，并在输入完以后自动搜索。(如：输入关键字“promise”，如果不做防抖那么每输入一个字母就发一次请求)
2. 手机号，邮箱验证输入检测。
3. 窗口大小 resize 变化后，再重新渲染。

## localStorage 的使用场景：

1. 缓存一般信息，如搜索页的出发城市，达到城市，非实时定位的信息。

2. 缓存城市列表数据，这个数据往往比较大。

3. 每条缓存信息需要可跟踪，比如服务器通知城市数据更新，这个时候在最近一次访问的时候要自动设置过期。

4. **localStorage 常用于长期登录+判断用户是否已经登录。**

1. sessionStorage 的使用场景：

   1. 游客/敏感账号一次性登录的。

2. cookie 一般要配合 session一起使用，session 的使用场景：

   1. 商城中的购物车。
   2. 保存用户登录信息。
   3. 将某些数据放入 session 中，供同一用户的不同页面使用。
   4. 方式在用户非法登录。

3. Vue 中如何去掉路由中的 # 号？

   vue-cli 项目中，如果想去掉url地址栏中的“#”我们可以用路由的 history 模式，这种模式充分利用 `history.pushState` API 来完成 URL 跳转而无须重新加载页面。只需要在路由表中，加入一行代码即可。

   [博客地址](https://blog.csdn.net/webEvelement/article/details/82850551)

## 封装组件场景



1. button按钮封装
2. 时间封装(如：显示此评论是多久前发布的) [博客地址](https://blog.csdn.net/m0_53912016/article/details/125639620)
2. 



