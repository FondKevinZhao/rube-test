## better-scroll 在下拉加载页面后出现滑动卡顿

解决 Vue 项目中使用 better-scroll 在下拉加载页面后出现滑动卡顿的问题。

场景：在 vue 项目中使用 better-scroll 解决原生滑动不够顺滑的问题，但在下拉加载更多数据时，出现无法下拉，滑动卡顿，但是稍微等一会，就又可以正常下拉滑动。

原因分析：

出现该现象的原因是由于 better-scroll 中的一个属性：scrollerHeight。

1. better-scroll 在决定有多少区域可以滚动时，是根据 scrollerHeight 属性决定的。
2. scrollerHeight 属性是根据放在 better-scroll 中子组件的高度决定的。
3. 但在刚下拉加载时，由于图片加载速度较慢，所以 scrollerHeight 计算的结果是少于实际高度的，就会导致拉到一定高度无法下拉的情况。但是等待一会，图片加载完毕，scrollerHeight 变成实际高度，就又可以正常滚动。

解决方案：

解决方法就是监听每一张图片的加载。然后在每张图片加载完成手动刷新 scrollerHeight 的数值。

- vue中使用 @load="方法" 实现对图片监听。
- 再调用 better-scroll 中的 refresh()。

[博客地址](https://blog.csdn.net/weixin_43402358/article/details/119272273)

## 小程序单页面跳转最大的层数,达到后怎么处理的?

最大页面10个，到达10层了只能由 `redirectTo`不保存当前页跳转。

## Vue-router 跳转刷新页面 Params 参数丢失问题

`vue-router`的跳转传参方式分为 query 和 params 俩种。

1. query 传参数，相当于拼接在 url 后面，这种方式不会丢失参数，但是数据量大的话（比如传递对象），url 就会变得太长而且不隐密。
2. params 传参数，不在 url 中显示，但是刷新页面的时候无法避免丢失。

解决：

1. 使用`this.$router.push({name:"模块名称", query:{// 各参数}})`方式传参。

   缺点：参数值都拼接在 url 上，url 会很长，同时都可以被看到。

2. `this.$router.push({name:"模块名称", params:{// 各参数}})`路由文件设置的时候把参数拼接到 url 里。

   ```js
   // url
   http://localhost:8081/#/paramsPassingByRouter/paramsMode/20180101
   ```

   确定：同上。

3. 1 和 2 结合使用：`this.$router.push({name:"模块名称", params:{//各参数},query:{//各参数}})`。

4. 用 localStorage 存储。

   ```js
   url: http://localhost:8081/#/paamsPassingByRouter/paramsMode/z3
   // 可以与 params 和 query 方式配合使用，可以暴露的参数显示在 url 上，同时刷新参数也不会丢失。
   销毁页面的时候把 localStorage 存储的内容请求。
   ```

[博客地址](https://blog.csdn.net/qq_33456552/article/details/105118120)



## 批量处理接口中的部分数据

后端给你的接口，你只需要该接口里数据的一部分，其他数据不要，让你批量性的实现默认处理？

可以将数据进行过滤，也可以使用 computed。

vue 2.0 之后`limitBy`被计算属性代替, 官方的例子：

```js
<p v-for="item in filteredItems">{{ item }}</p>

computed: {
  filteredItems: function () {
    return this.items.slice(0, 10)
  }
}
```



## 为什么 vue-router 使用 next() 跳转到指定路径时会无限循环？

问题：我不太明白为什么会死循环，我在 home 页面也没有写任何钩子函数来跳到 result 页面啊，我也没有写全局的 beforeEach 钩子函数。

死循环代码：

```js
// 下面的写法会死循环
beforeRouteLeave (to, from, next) {
    console.log('离开路路由')
   next('/home')
}
```

可用的代码：

```js
// 我在路由为 /path 的页面这样写
beforeRouteLeave (to, from, next) {
   console.log('离开路由')
   if(to.fullPath==='/home'){
     next();
   }else{
     next('/home')
}
```



## 编程式路由跳转到当前路由(参数不变)，多次执行会抛出 NavigationDuplicated 的警告错误

原因：vue-router 3.1.0 之后，引入了 promise 的语法。如果没有通过参数指定成功的回调或者失败的回调就返回一个 promise，且内部会判断如果要跳转的路径和参数都没有，会抛出一个失败的 promise。

解决：

1. 在跳转时指定成功或失败的回调函数，或者 catch 处理错误。

   这个解决办法不好，因为不能一劳永逸，后期如果用到了 push/replace 还要继续都得写。

2. 修改 Vue 原型上的 push 和 replace 方法。(优秀)

## 闭包使用场景：

1. 删除某一条数据，通过 ID 或 index 去删除的时候，会使用到闭包。
2. 发送 Ajax 请求成功或失败的回调。
3. setTimeout 的延时回调。

## 节流的使用场景：

1. 滚动加载更多。
2. 搜索框搜索的联想功能。
3. 高频点击。
4. 表单重复提交。
5. **鼠标移动到一级菜单会在右侧出现二级菜单**

## 防抖的使用场景：

1. 搜索框搜索输入，并在输入完以后自动搜索。(如：输入关键字“promise”，如果不做防抖那么每输入一个字母就发一次请求)
2. 手机号，邮箱验证输入检测。
3. 窗口大小 resize 变化后，再重新渲染。

## localStorage 的使用场景：

1. 缓存一般信息，如搜索页的出发城市，达到城市，非实时定位的信息。

2. 缓存城市列表数据，这个数据往往比较大。

3. 每条缓存信息需要可跟踪，比如服务器通知城市数据更新，这个时候在最近一次访问的时候要自动设置过期。

4. **localStorage 常用于长期登录+判断用户是否已经登录。**

1. sessionStorage 的使用场景：

   1. 游客/敏感账号一次性登录的。

2. cookie 一般要配合 session一起使用，session 的使用场景：

   1. 商城中的购物车。
   2. 保存用户登录信息。
   3. 将某些数据放入 session 中，供同一用户的不同页面使用。
   4. 方式在用户非法登录。

3. Vue 中如何去掉路由中的 # 号？

   vue-cli 项目中，如果想去掉url地址栏中的“#”我们可以用路由的 history 模式，这种模式充分利用 `history.pushState` API 来完成 URL 跳转而无须重新加载页面。只需要在路由表中，加入一行代码即可。

   [博客地址](https://blog.csdn.net/webEvelement/article/details/82850551)

## 封装组件场景



1. button按钮封装

2. 时间封装(如：显示此评论是多久前发布的) [博客地址](https://blog.csdn.net/m0_53912016/article/details/125639620)

3. 面包屑封装

   ```html
   // 原始的写法：
   <el-breadcrumb separator-class="el-icon-arrow-right">
   	<el-breadcrumb-item>首页</el-breadcrumb-item>
     <el-breadcrumb-item>权限管理</el-breadcrumb-item>
     <el-breadcrumb-item>权限列表</el-breadcrumb-item>
   </el-breadcrumb>
   
   // 封装后的效果：
   <my-bread level1="权限管理" level2="权限列表"></my-bread>
   ```

   

   封装的组件：

   ```html
   <template>
   	<el-breadcrumb separator-class="el-icon-arrow-right">
   		<el-breadcrumb-item>首页</el-breadcrumb-item>
     	<el-breadcrumb-item>{{ level1 }}</el-breadcrumb-item>
     	<el-breadcrumb-item>{{ level2 }}</el-breadcrumb-item>
   	</el-breadcrumb>
   </template>
   
   <script>
   export default {
     props: ['level1', 'level2']
   }
   </script>
   ```

   

2. 



## 跳转到搜索页面

1. 输入框回车 -》输入框文字 -》搜索框结果页

   输入框回车在移动端是没有keyup.enter事件的，所以要使用vant中的search组件中的search事件

2. 点击联想菜单 -》点击文字 -》搜索结果页

3. 点击历史记录 -》点击文字 -》 搜索结果页

[视频地址黑马头条82](https://www.bilibili.com/video/BV1D3411L7PP/?p=82&spm_id_from=pageDriver&vd_source=ba9278b625c8ac0175e9312cb9cfed59)



## el-form和el-dialog和数据同显同时用，有bug

小bug：（el-form和el-dialog和数据同显同时用，有bug）

复现：第一次打开网页，先点击修改，再点击新增，发现输入框竞然有值

原因：点击修改后，关闭对话柜的时候，置空失效了

具体分析：主人公resetFields有问题

线索：Dialog的内容是懒染的，即在第一次被打开之前，传入的默认s1ot不会被染到DOM上，第二次后续只是做css隐藏和显示

线索：vue数据改变（先执行同步所有）再去更新DOM（异步代码）

无问题：第一次打开网页，先点击新增按钮->dialog出现->el-form组件第一次挂载（关联的addForm对象的属性的值为空字符串）el-form组件内绑定了初始值，所以后续调resetFields的时候，它可以用到空字符串初始值来重置

有问题：第一次打开网页，先点击修改按钮->虽然dialog变量为true了但是同步代码把addForm对象里赋值了（默认值）- DOM更新异步->dia1og出现->el-form组件第一次挂载（使用addForm内置做回显然后第一次el-form内绑定了初始值（有值））-> 以后做重置，它就用绑定的带值的做重置

解决：让数据回显慢点执行

```js
function add(obj) {
  this.dialogVisible = true
  
  // 数据回显的时候慢一点
  this.$nextTick(() => {
    this.addForm.cate_name = obj.cata_name
  	this.addForm.cate_alias = obj.cate_alias
  })
}
```



[视频地址大事件49](https://www.bilibili.com/video/BV12d4y1q7tg/?p=49&spm_id_from=pageDriver&vd_source=ba9278b625c8ac0175e9312cb9cfed59)





















































































































