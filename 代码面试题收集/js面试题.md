1. [单选题]
   有以下 ES6 代码
   function * gen() {
   yield 1;
   yield 2;
   yield 3;
   }
   下面选项描述正确的是哪个？
   A.gen()执行后返回 2
   B.gen()执行后返回 undefined
   C.gen()执行后返回一个 Generator 对象
   D.gen()执行后返回 1
   \----------------------------------------------------------------------------------------------------------------------------来自： 百度 2016 研发工程师笔试真题（三）
   答案： C
   提示：

| 这是 ES6 的新 feature，function 后面带  返回一个迭代器。 | * 的叫做 generator function。函数运行时， |
| -------------------------------------------------------- | ----------------------------------------- |
|                                                          |                                           |




2. [不定项选择题]
   语句 var arr=[a,b,c,d];执行后，数组 arr 中每项都是一个整数，下面得到其中最大整数语
   句正确的是哪几项？
   A.Math.max(arr)
   B.Math.max(arr[0], arr[1], arr[2], arr[3])
   C.Math.max.call(Math, arr[0], arr[1], arr[2], arr[3])
   D.Math.max.apply(Math,arr)
   \----------------------------------------------------------------------------------------------------------------------------
   来自：百度 2016 研发工程师笔试真题（三）
   答案： B C D
   提示：
   A 选项错误
   因为函数 Math.max(x);的参数是 Number 类型，可以使小数，整数，正数，负数或者是
   0.如果不是上面所述类型就会返回 NaN.  

3. [问答题]
   请写一个表格以及对应的 CSS，使表格奇数行为白色背景，偶数行为灰色背景，鼠标移
   上去时为黄色背景  

   \----------------------------------------------------------------------------------------------------------------------------

   ```js
   参考：
   <table class="table">
   <tr><td>第一行</td></tr>
   <tr><td>第二行</td></tr>
   <tr><td>第三行</td></tr>
   <tr><td>第四行</td></tr>
   </table>
   <style>
   .table tr:nth-child(odd){
   background-color:white;
   }
   .table tr:nth-child(even){
   background-color:gray;
   }
   .table tr:hover{
   background-color:yellow;
   }
   </style>
   ```

4. [填空题]
   删除给定数组中的第二项和第三项，并且在得到的新的数组中第二项后面添加一个新的
   值：
   var arr1 = ['a','b','c','d','e'];
   var arr2 = arr1. 1 ( 2 , 3 ,'newvalue')
   \----------------------------------------------------------------------------------------------------------------------------
   来自： 阿里巴巴 2016 前端开发工程师笔试(二)
   答案： splice 1 2  

5. [填空题]
   在空白处填入适当的代码使输出结果成立：  4

   ```js
   function showMoney( ) {
   1
   };
   var personA = new Object;
   var personB = new Object;
   personA.money= "100";
   personB.money= "150";
   personA.showMoney= showMoney;
   personB.showMoney= showMoney;
   输出结果：
   personA.showMoney( ); //"100"
   personB.showMoney( ); //"150"
   ```


   \----------------------------------------------------------------------------------------------------------------------------
   来自： 阿里巴巴 2016 前端开发工程师笔试(二)
   答案： return this.money;  

6. [填空题]
   使用 for in 循环数组中的元素会枚举原型链上的所有属性，过滤这些属性的方式是使
   用 1 函数
   \----------------------------------------------------------------------------------------------------------------------------
   来自： 阿里巴巴 2016 前端开发工程师笔试(二)
   答案： hasOwnProperty 
   
7. [问答题]
   请实现一个 fibonacci 函数，要求其参数和返回值如下所示：
   /**
   *@desc: fibonacci
   *@param: count {Number}
   *@return: result {Number} 第 count 个 fibonacci 值，计数从 0 开始
   fibonacci 数列为： [1, 1, 2, 3, 5, 8, 13, 21, 34 „]
   则 getNthFibonacci(0)返回值为 1
   则 getNthFibonacci(4)返回值为 5
   */
   function getNthFibonacci(count) {
   }
   \----------------------------------------------------------------------------------------------------------------------------
   来自： 阿里巴巴 2016 前端开发工程师笔试(一)
   参考：
   function getNthFibonacci(count) {
   if (count <= 1) {
   return 1;
   }
   return getNthFibonacci(count - 1) + getNthFibonacci(count - 2);
   }  
   
8. [填空题]
   输出对象中值大于 2 的 key 的数组
   var data = {a: 1, b: 2, c: 3, d: 4};
   Object.keys(data).filter(function(x) { return 1 ;})
   期待输出： [“c” ,” d” ]
   \----------------------------------------------------------------------------------------------------------------------------
   来自： 阿里巴巴 2016 前端开发工程师笔试(一)
   答案： data[x] > 2  
   
9. [填空题]
   填写内容让下面代码支持 a.name = “name1” ; b.name = “name2” ;
   
   ```js
   function obj(name){
   1
   }
   obj. 2 = "name2";
   var a = obj("name1");
   var b = new obj;
   ```
   
   \----------------------------------------------------------------------------------------------------------------------------
   来自： 阿里巴巴 2016 前端开发工程师笔试(一)
   答案： if (name) { this.name = name; } return this; prototype.name  
   
10. [单选题]
    下面有关 html 的描述，不推荐的是？
    A.在页面顶部添加 doctype 声明；
    B.在 </head> „ <body> 中间插入 HTML 代码；
    C.避免使用 <font> 标签；
    D.使用 <table> 元素展现学生成绩表等数据。
    \----------------------------------------------------------------------------------------------------------------------------
    来自： 阿里巴巴 2016 前端开发工程师笔试(一)
    答案： B  
    
11. [单选题]
    下面关于 CSS 布局的描述，不正确的是？
    A.块级元素实际占用的宽度与它的 width 属性有关；
    B.块级元素实际占用的宽度与它的 border 属性有关；
    C.块级元素实际占用的宽度与它的 padding 属性有关；
    D.块级元素实际占用的宽度与它的 background 属性有关。
    \----------------------------------------------------------------------------------------------------------------------------
    来自： 阿里巴巴 2016 前端开发工程师笔试(一)
    答案： D  
    
12. [单选题]
    下列事件哪个不是由鼠标触发的事件（）
    A.click
    B.contextmenu
    C.mouseout
    D.keydown
    \----------------------------------------------------------------------------------------------------------------------------
    来自： 阿里巴巴 2016 前端开发工程师笔试(一)
    答案： D  
    
13. [问答题]
    请说说 cache-control 是怎么回事？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    网页的缓存是由 HTTP 消息头中的“Cache-control”来控制的，常见的取值有 private、
    no-cache、 max-age、 must-revalidate 等，默认为 private。
    Expires 头部字段提供一个日期和时间，响应在该日期和时间后被认为失效。允许客户
    端在这个时间之前不去检查（发请求），等同 max-age 的效果。但是如果同时存在，则被
    Cache-Control 的 max-age 覆盖。
    Expires = "Expires" ":" HTTP-date
    例如：
    Expires: Thu, 01 Dec 1994 16:00:00 GMT （必须是 GMT 格式）
    如果把它设置为-1，则表示立即过期
    Expires 和 max-age 都可以用来指定文档的过期时间，但是二者有一些细微差别
    1.Expires 在 HTTP/1.0 中已经定义， Cache-Control:max-age 在 HTTP/1.1 中才有定义，为
    了向下兼容，仅使用 max-age 不够。
    \2. Expires 指定一个绝对的过期时间(GMT 格式),这么做会导致至少 2 个问题：
    2.1 客户端和服务器时间不同步导致 Expires 的配置出现问题。
    2.2 很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象
    \3. max-age 指定的是从文档被访问后的存活时间，这个时间是个相对值(比如:3600s)，
    相对的是文档第一次被请求时服务器记录的 Request_time(请求时间)
    \4. Expires 指定的时间可以是相对文件的最后访问时间(Atime)或者修改时间(MTime)，而
    max-age 相对对的是文档的请求时间(Atime)
    \5. 如果值为 no-cache,那么每次都会访问服务器。如果值为 max-age，则在过期之前不
    会重复访问服务器。  
    
14. [问答题]
    你了解 HTTP 状态码吗，请随便介绍一下。
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回
    此信息，表示确认，之后发送具体参数信息
    200 OK 正常返回信息
    201 Created 请求成功并且服务器创建了新的资源
    202 Accepted 服务器已接受请求，但尚未处理
    301 Moved Permanently 请求的网页已永久移动到新位置
    302 Found 临时性重定向
    303 See Other 临时性重定向，且总是使用 GET 请求新的 URI
    304 Not Modified 自从上次请求后，请求的网页未修改过
    400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容
    发起请求
    401 Unauthorized 请求未授权
    403 Forbidden 禁止访问
    404 Not Found 找不到如何与 URI 相匹配的资源
    500 Internal Server Error 最常见的服务器端错误
    503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）  
    
15. [问答题]
    如何获取 UA？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    
    ```js
    function whatBrowser() {
    document.Browser.Name.value=navigator.appName;
    document.Browser.Version.value=navigator.appVersion;
    document.Browser.Code.value=navigator.appCodeName;
    document.Browser.Agent.value=navigator.userAgent;
    }  
    ```
    
    
    
16. [问答题]
    说说对网站重构的理解。
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一
    致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的
    UI。
    对于传统的网站来说重构通常是：
    \1. 表格(table)布局改为 DIV + CSS
    \2. 使网站前端兼容于现代浏览器(针对于不合规范的 CSS、如对 IE6 有效的)
    \3. 对于移动平台的优化
    \4. 针对于 SEO 进行优化
    \5. 深层次的网站重构应该考虑的方面
    \6. 减少代码间的耦合
    \7. 让代码保持弹性
    \8. 严格按规范编写代码
    \9. 设计可扩展的 API
    \10. 代替旧有的框架、语言(如 VB)
    \11. 增强用户体验
    \12. 通常来说对于速度的优化也包含在重构中
    \13. 压缩 JS、 CSS、 image 等前端资源(通常是由服务器来解决)
    \14. 程序的性能优化(如数据读写)
    \15. 采用 CDN 来加速资源加载
    \16. 对于 JS DOM 的优化  

    \17. HTTP 服务器的文件缓存  

17. [问答题]
    js 对象的深度克隆代码实现。
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    function clone(Obj) {
    var buf;
    if (Obj instanceof Array) {
    buf = []; // 创建一个空的数组
    var i = Obj.length;
    while (i--) {
    buf[i] = clone(Obj[i]);
    }
    return buf;
    } else if (Obj instanceof Object){
    buf = {}; // 创建一个空对象
    for (var k in Obj) { // 为这个对象添加新的属性
    buf[k] = clone(Obj[k]);
    }
    return buf;
    }else{
    return Obj;
    }
    }  

18. [问答题]
    事件、 IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    \1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就
    会产生一个事件。是可以被 JavaScript 侦测到的行为
    \2. 事件处理机制： IE 是事件冒泡、 firefox 同时支持两种事件模型，也就是：捕获型事
    件和冒泡型事件
    \3. ev.stopPropagation();
    注意旧 ie 的方法： ev.cancelBubble = true;  

19. [问答题]
    WEB 应用从服务器主动推送 Data 到客户端有那些方式？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    \1. html5 websoket
    \2. WebSocket 通过 Flash
    \3. XHR 长时间连接
    \4. XHR Multipart Streaming
    \5. 不可见的 Iframe
    \6. <script>标签的长时间连接(可跨域)  

20. [问答题]
    怎么重构页面？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    \1. 编写 CSS
    \2. 让页面结构更合理化，提升用户体验
    \3. 实现良好的页面效果和提升性能  
    
21. [问答题]
    Node.js 的适用场景
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    \1. 高并发
    \2. 聊天
    \3. 实时消息推送  
    
22. [问答题]
    eval 是做什么的，有什么建议？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    \1. 它的功能是把对应的字符串解析成 JS 代码并运行
    \2. 应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）  

23. [问答题]
    GET 和 POST 的区别，何时使用 POST？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在
    2000 个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制
    GET 方式需要使用 Request.QueryString 来取得变量的值
    POST 方式通过 Request.Form 来获取变量的值
    也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。
    在以下情况中，请使用 POST 请求：
    \1. 无法使用缓存文件（更新服务器上的文件或数据库）
    \2. 向服务器发送大量数据（POST 没有数据量限制）
    \3. 发送包含未知字符的用户输入时， POST 比 GET 更稳定也更可靠  

24. [问答题]
    什么是 "use strict"; ? 使用它的好处和坏处分别是什么？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    ECMAscript 5 添加了第二种运行模式： "严格模式"（strict mode）。顾名思义，这种模式
    使得 Javascript 在更严格的条件下运行。
    设立"严格模式"的目的，主要有以下几个：
    \1. 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;
    \2. 消除代码运行的一些不安全之处，保证代码运行的安全；
    \3. 提高编译器效率，增加运行速度；
    \4. 为未来新版本的 Javascript 做好铺垫。
    注：经过测试 IE6,7,8,9 均不支持严格模式。
    缺点：
    现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来
    是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反
    而在压缩后浪费了字节。  
    
25. [问答题]
    请解释一下 JavaScript 的同源策略。
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    概念：
    同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape
    Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚
    本只能读取来自同一来源的窗口和文档的属性。
    为什么要有同源限制：
    我们举例说明：比如一个黑客程序，他利用 Iframe 把真正的银行登录页面嵌到他的页
    面上，当你使用真实的用户名，密码登录时，他的页面就可以通过 Javascript 读取到你的表
    单中 input 中的内容，这样用户名，密码就轻松到手了。  
    
26. [问答题]
    Flash、 Ajax 各自的优缺点，在使用中如何取舍？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    Flash：
    \1. Flash 适合处理多媒体、矢量图形、访问机器
    \2. 对 CSS、处理文本上不足，不容易被搜索
    Ajax：
    \1. Ajax 对 CSS、文本支持很好，支持搜索
    \2. 多媒体、矢量图形、机器访问不足
    共同点：
    \1. 与服务器的无刷新传递消息
    \2. 可以检测用户离线和在线状态
    \3. 操作 DOM  
    
27. [问答题]
    什么叫优雅降级和渐进增强？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    \1. 优雅降级： Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏
    览器，则代码会检查以确认它们是否能正常工作。由于 IE 独特的盒模型布局问题，针对不
    同版本的 IE 的 hack 实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在
    旧式浏览器上以某种形式降级体验却不至于完全失效。
    \2. 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器
    才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们
    会自动地呈现出来并发挥作用。  

28. [问答题]
    哪些操作会造成内存泄漏？
    \----------------------------------------------------------------------------------------------------------------------------
    来自：前端工程师进阶检测
    参考：
    内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
    垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的
    引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对
    象的内存即可回收。
    \1. setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
    \2. 闭包
    \3. 控制台日志
    \4. 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）  

29. [问答题]
    阅读以下 JavaScript 代码：
    if (window.addEventListener) {
    var addListener = function(el, type, listener, useCapture) {
    el.addEventListener(type, listener, useCapture);
    };
    } else if (document.all) {
    addListener = function(el, type, listener) {
    el.attachEvent("on" + type, function() {
    listener.apply(el);
    });
    };
    }
    请阐述 a) 代码的功能; b) 代码的优点和缺点; c) listener.apply(el) 在此处的作用; d) 如
    果有可改进之处，请给出改进后的代码，并说明理由。
    \----------------------------------------------------------------------------------------------------------------------------
    来自： 阿里巴巴 2011 前端工程师面试题
    参考：
    1、事件绑定的一个简单函数封装；
    2、优点：函数封装可随时引用，没有解决兼容性的问题；缺点：代码冗余
    3、作用是改变 this 指向的问题，不用则指向 window 而不是调动它的事件对象
    function bind(obj, evname, fn){
    if(obj.addEventListener){
    obj.addEventListener(evname, fn, false);
    } else {
    obj.attachEvent('on'+evname, function(){
    fn.apply(obj);
    });
    }
    }  

30. JavaScript 中 document.getElementById 的返回值的类型为？
    A.Array
    B.Object
    C.String
    D.Function
    \----------------------------------------------------------------------------------------------------------------------------
    来自：微博
    答案： B  

31. [问答题]
    如何判断浏览器是 IE 还是火狐，用 ajax 实现。
    \----------------------------------------------------------------------------------------------------------------------------
    来自：阿里巴巴
    参考：
    用 Request Headers 里的 User-Agent 判断  

    
    
32. [问答题]
请使用原生 js 实现一个 div 可拖拽，需要考虑浏览器兼容性。
----------------------------------------------------------------------------------------------------------------------------
来自：阿里巴巴
参考：
var drag1=document.getElementById('drag1');
drag1.onmousedown=function(ev){
var x=ev.clientX-drag1.offsetLeft;
var y=ev.clientY-drag1.offsetTop;
drag1.onmousemove=function(ev){
drag1.style.left=ev.clientX-x+'px';drag1.style.top=ev.clientY-y+'px';
}
drag1.onmouseup=function(ev){
drag1.onmousemove=drag1.onmouseup=null;
}
}

33. [问答题]
请填充代码，使 mySort()能使传入的参数按照从小到大的顺序显示出来。
function mySort() {
var tags = new Array();//使用数组作为参数存储容器
请补充你的代码
return tags;//返回已经排序的数组
}
var result = mySort(50,11,16,32,24,99,57,100);/传入参数个数不确定
console.info(result);//显示结果
----------------------------------------------------------------------------------------------------------------------------
来自： 腾讯 2015 春招 web 前端开发练习卷
参考：
function mySort() {
var tags = new Array();//使用数组作为参数存储容器
tags = Array.prototype.slice.call(arguments)
tags.sort(function(pre,next){
return pre - next;
})
return tags;//返回已经排序的数组
}

34. [单选题]
下面哪些是 NodeJS 官方模块？
A.Querystring
B.Request
C.Async
D.Dns
----------------------------------------------------------------------------------------------------------------------------
来自：阿里巴巴
答案： D

35. [问答题]
使用 Javascript 打印出 1-10000 之间的所有对称数（例如 121 1331 等）。
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
function findSymmetryNum(s,o){
var arr=[];
for(var i=s;i<=o;i++){
var str=''+i,sl=str.length,middle=0,flag=true;
if(sl%2===0){
middle=sl/2;
}else{
middle = (sl-1)/2;
}
for(var m=0;m<middle;m++){
if(str.substr(0+m,1)!==str.substr(-1-m,1)){
flag = false;
} }
flag&&arr.push(i);}
console.log(arr);
return arr;
}
findSymmetryNum(1,1001);

36. [问答题]
使用 javascript 实现，将文档中 className 有“test”的 li 标签背景色设为黄色。
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
<script type="text/javascript">
window.onload=function(){
var list = document.getElementsByTagName("li");
console.log(list.length);
for(var i=0;i<list.length;i++){
if(list[i].className=='test'){
list[i].style.backgroundColor="gold";
}
}
}
</script>

37. [问答题]
用 js 实现如下功能，将给定的数字转化成千分位的格式，如把“10000”转化成“10,000”，
并考虑到性能方面的因素
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
<!DOCTYPE>
<html>
<head>
<script>
var a="150355660";
var re=/(?=(?!\b)(\d{3})+$)/g
alert(a.replace(re,','));
</script></head>
<body>
</body>
</html>

38. 请通过 js 来实现一个函数 once，这个函数在整个应用运行的时候只被访问一次。如果
再次访问就会访问上次的执行结果。
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
var singleton = (function() {
//缓存实例
var instance;
var randomNum = Math.random();
//单例初始化代码
function init() {
return randomNum;
}
//如果没有初始化，则初始化，否则返回已经执行的结果。
if (!instance) {
instance = init();
}
return instance;
})()
console.log(singleton);
console.log(singleton);

39. [问答题]
如何解决跨域通信的问题，简述有哪些方法？
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
（1）、 document.domain+iframe 的设置
（2）、动态创建 script，要就是 jsonp
（3）、利用 iframe 和 location.hash
（4）、 window.name 实现的跨域数据传输
（5）、使用 HTML5 postMessage
（6）、利用 flash

40. [问答题]
画图描述 CSS 盒模型，用 JS 实现获取元素宽和位置，注意兼容性。
----------------------------------------------------------------------------------------------------------------------------
来自：去哪儿
参考：
var element = document.getElementById("div0");
function getWeizhi (element) {
var top = document.documentElement.clientTop;
var left = document.documentElement.clientLeft;
var ele = element.getBoundingClientRect();
return{
top:ele.top - top,
right:ele.right - left,
bottom:ele.bottom - top,
left:ele.left - left,
width:ele.right - ele.left,
height:ele.bottom - ele.top
}
}

41. [问答题]
用 Javascript 实现乱序函数 randomSort(array)函数，输出排序后的函数。如[1,2,3,4,5]，
输出[3,2,4,5,1]。要求 N 次以内不重复。
----------------------------------------------------------------------------------------------------------------------------
来自：去哪儿参考：
function randomSort(array){
var x=array.sort(function(a,b){
return Math.random()>0.5?1:-1;
});
return x;
} 或
function randomSort(array) {
var n = array.length, t, i;
while (n) {
i = Math.random() * n-- | 0;
t = array[n];
array[n] = array[i];
array[i] = t;
}
return array;
}

42. [问答题]
写一个命令行字符的解析函数。
例： -name lily -age 25 -school "chengdu university" 返回的是[-name lily,-age 25, -school
"chengdu university"]
----------------------------------------------------------------------------------------------------------------------------
来自：去哪儿
参考：
<script>
function getdata(str)
{
var json={};
var gets =str.split('"')[0];
gets =gets.split(' ');
for(var i=0;i<gets.length-1;i++)
{
if(i%2==0)
{
json[gets[i]]=gets[i+1];
}
}
json[gets[gets.length-1]]=str.split('"')[1];
return json;
}
</script>

43. [问答题]
写一个函数 padstare(string str1,min_length,string str2)。
例： padstare（‘5’， 3，‘0’）返回的是‘005’； padstare（‘798’， 5，‘0’）返回的是
‘798’；
----------------------------------------------------------------------------------------------------------------------------
来自：去哪儿
参考：
<script>
function padstare(str,min,str_char)
{
var ret=[];
if(str.length>=min)
{
return str;
}
else
{
for(var i=0;i<min-str.length;i++)
{
ret.push(str_char);
}
return ret.join('')+str;
}
}
</script>

44. [问答题]
请实现 javascript 中的 indexOf 功能，判断一个字符串 a 中是否包含另一个字符串 b。
a）如果包含，需要返回匹配字符串 b 的位置
b）如果不包含，需要返回-1
例如 indexOf("hello","el") returns 1;
----------------------------------------------------------------------------------------------------------------------------
来自：去哪儿
参考：
function indexOf (a,b){
var result = a.match(b);
return result? result.index:-1;}
console.log(indexOf("hello", "el"));//1
或
function indexOf(strA, strB) {
var lenA = strA.length,
lenB = strB.length;
if (lenA < lenB) {
return -1;
} else if (lenA == lenB) {
return 0;
} else {
for (var j = 0; j < lenA; j++) {
if (strA.charAt(j) == strB[0] && strA.substr(j, lenB) == strB) {
return j;
}
}
return -1;
}
}
console.log(indexOf("hello", "el")); //1

45. [问答题]
angularjs 里面的双向数据绑定和依赖注入的原理?
----------------------------------------------------------------------------------------------------------------------------
来自：阿里巴巴
参考：
双向数组绑定主要是通过 angular 的 digest 流程, 依赖注入主要是 function.toString 分析
参见： https://github.com/xufei/blog/issues/10

46. [不定项选择题]
按照 CommonJS 规范，在任何模块代码的作用域下内置了以下哪些变量？
A.module
B.context
C.require
D.exports
----------------------------------------------------------------------------------------------------------------------------
来自：阿里巴巴
答案： ACD

47. [问答题]
写出至少 5 个前端优化的方法，并写明理由。
----------------------------------------------------------------------------------------------------------------------------
来自： 百度
参考：
1.将 CSS 放再顶部 --- 能加快页面内容显示,并且能避免页面产生白屏。
2.将JS放在底部 --- ①JS会阻塞对其后面内容的呈现；②JS会阻塞对其后面内容的下载。
3.将 JS,CSS 放在外部文件中（代码和样式的分离） --- 便于优化和管理。
4.重置 CSS 文件 --- 清除 HTML 标签默认的属性，让页面按编写者的意愿变化。5.HTML 尽量使用标准规范的写法 --- 提高渲染引擎的执行效率。
6.对 JS 和 CSS 进行压缩，去重，合并等处理 --- ①减小了文件的体积； ②减小了网
络传输量和带宽占用； ③减小了服务器的处理的压力； ④提高了页面的渲染显示的速
度 。
7.减少页面的图片数目 --- 浏览器拉取页面图片的开销是比较大的，而实际上，我们
的页面为了提升用户体验使用了大量图片，这里我们常采用 cdn 存放，图片合并(几个图片
合成一个，然后使用 css 进行截取片断显示)，永久 cache（存在图片变更的维护成本,工具的
建设等），甚至有些效果是可以用 css 来实现的代替图片 。

48. 我们在进行组件开发的时候，经常会需要用到大量颜色。有两种方法。方法 1：预先定
义好大量的颜色；方法 2：自定义函数，采用随机生成颜色的方式。请采用方法 2 实现随机
颜色汲取。
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
function renderColour() {
return "#"+(~~(Math.random()*(1<<24))).toString(16);
}

49. [问答题]
请 问 在 JavaScript 中如何 调 用 以下 几 个 CSS 属 性 ： font-size ， border-top-width,
-moz-user-select?
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
考察 CSS 在 JS 中的驼峰写法
fontSize

50. [单选题]
以下哪一条 Javascript 语句会产生运行错误？
A.var obj=( );
B.var obj=[ ];
C.var obj={ };
D.var obj=/ /;
----------------------------------------------------------------------------------------------------------------------------
来自：网易
答案： A
A 是语法错误
B 是创建一个数组对象
C 是创建一个对象
D 是一个创建正则对象；若为 var obj=/ /； 即赋值被注释掉，及运行被结束；

51. [单选题]从四个选项选出不同的一个。
A.JQuery
B.Node.js
C.Prototype
D.CommonJS
----------------------------------------------------------------------------------------------------------------------------
来自： 搜狐研发工程师模拟笔试题
答案： d
Jquery 是继 prototype 之后又一个优秀的 Javascrīpt 框架。它是轻量级的 js 库(压缩后只
有 21k) ，它兼容 CSS3，还兼容各种浏览器。
Node.js 是一套用来编写高性能网络服务器的 JavaScript 工具包。
在 JavaScript 中， prototype 对象是实现面向对象的一个重要机制。每个函数就是一个
对象（Function），函数对象都有一个子对象 prototype 对象，类是以函数的形式来定义的。
prototype 表示该函数的原型，也表示一个类的成员的集合。 prototype.js 是由 Sam
Stephenson 写的一个 javascript 类库。
CommonJS API 定义很多普通应用程序（主要指非浏览器的应用）使用的 API，从而填补
了这个空白。

52. [问答题]
当你打开浏览在地址栏中输“ http://www.baidu.com/”后在百度的搜索框中输入
“HTML5”，然后点击百度一下按钮，在所有的信息在一一被列举出来的过程中，计算机和
网络都发生了什么变化？你有什建议？
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
输入框挂载 onchange 事件，获取客户端输入， ajax 传回后台，查数据库，查出若干匹
配项，装进 list，返回给 jsp 输出， ajax 回调方法接收 jsp 的输出，将输出转为一段段字符串，
装进输入框下方的 table 或 div 里

53. [问答题]
浏览器的缓存和本地存储相关内容有哪些？这些在什么环境下都各自能起到什么作
用？
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
html 页面、图片等.
在联网时已访问的内容可以直接从缓存调出来，提高访问速度离线时，可以本地存储做
离线访问（google gears）
以后我们每次访问网站时， IE 会首先搜索这个目录，如果其中已经有访问过的内容，那
IE 就不必从网上下载，而直接从缓存中调出来，从而提高了访 问网站的速度。

54. [问答题]
怎样优化网页性能
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
1.尽量减少 HTTP 请求次数
2. 减少 DNS 查找次数
3.资源合并与压缩
4.CSS Sprites
5.Inline Images
6.将外部脚本置底
7.缓存

55. [问答题]
ajax 原理、如何实现刷新数据及优点？
----------------------------------------------------------------------------------------------------------------------------
来自： 迅雷
参考：
Ajax 的工作原理相当于在用户和服务器之间加了—个中间层,使用户操作与服务器响应
异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给 Ajax
引擎自己来做,只有确定需要从服务器读取新数据时再由 Ajax 引擎代为向服务器提交请求.
优点： 1.减轻服务器负担 2.无刷新更新页面 3 更好的用户体验

56. [问答题]
说出 3 条以上 ff 和 ie 的脚本兼容问题。
----------------------------------------------------------------------------------------------------------------------------
来自：百度参考：
IE 有children， FF没有； IE有parentElement， FF没有； IE有innerText,outerText,outerHTML，
FF 没 有 ； FF 有 HTMLElement,HTMLDivElement,XMLDocument,DocumentFragment,Node,
Event,Element 等等， IE 没有； IE 有数据岛， FF 没有； IE 跟 FF 创建 HttpRequest 实例的方法
不一样

57. prototype.js 实现的基本原理。
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
将功能封装
比如 Ajax.Request，还是有判断浏览器的代码； Position 这样的实现页面元素位置的计算

58. [问答题]
使用 JavaScript 深度克隆一个对象？
----------------------------------------------------------------------------------------------------------------------------
来自：百度
参考：
function Object.prototype.cloneObj()
{
function NEWOBJECT(){};
NEWOBJECT. prototype = this;
var anObj = new NEWOBJECT();
for ( var ele in anObj )
{
if ( typeof anObj[ele] == “object” ) return anObj[ele]. cloneObj();
}
return anObj;
}

59. [问答题]
判断字符串是否是这样组成的，第一个必须是字母，后面可以是字母、数字、下划线，
总长度为 5-20。
----------------------------------------------------------------------------------------------------------------------------
来自：前端工程师练习卷
参考：
var reg = /^[a-zA-Z][a-zA-Z_0-9]{4,19}$/;
reg.test("a1a__a1a__a1a__a1a__");

60. [问答题]
判断一个字符串中出现次数最多的字符，统计这个次数。
----------------------------------------------------------------------------------------------------------------------------
来自：前端工程师练习卷
参考：
//将字符串的字符保存在一个 hash table 中， key 是字符， value 是这个字符出现的次数
var str = "abcdefgaddda";
var obj = {};
for (var i = 0, l = str.length; i < l; i++) {
var key = str[i];
if (!obj[key]) {
obj[key] = 1;
} else {
obj[key]++;
}
}
/*遍历这个 hash table，获取 value 最大的 key 和 value*/
var max = -1;
var max_key = "";
var key;
for (key in obj) {
if (max < obj[key]) {
max = obj[key];
max_key = key;
}
}
alert("max:"+max+" max_key:"+max_key);

