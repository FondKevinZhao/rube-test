### 课堂笔记

1. 面向对象三大特征：封装、继承、多态

2. 子元素设置`top`和`height`的百分比，必须要求父元素有高度才行。

3. css reset, css sprite, css hack 面试会问到的css三个点。

4. 在URL地址里只能出现一个问号（？）。

5. JS继承：你想要子类继承父类，你需要自己写。

6. 最通用的继承方式是：`构造函数+原型` 的组合继承。

7. 线程是进程里面的一个独立单元。一个进程里面可能有一个或多个线程。通常认为一个进程就是打开一个软件。

8. JS 就是典型的单线程语言（缺点就是效率低。）。虽然js是单线程，但是它有一个好队友，Google浏览器是多线程的（现在浏览器基本都是多线程的）。

   所有的代码都要在JS上执行，但是浏览器可以帮忙处理一些事情。

9. `worker.js`是操作不了DOM的，因为它没有DOM，它只是一个js文件。

10. src属性是可以跨域的。

11. 加油加油！2021年2月24日15:33:11

12. 节流：在一段时间内只触发第一次。

13. 防抖：在一段时间内只触发最后一次。

14. 对象的简写和非简写可以同时共用。

15. 全等就是地址值的比较。

16. map 和对象的区别：1. map 有顺序。2. map 的key可以是任意类型。

17. entries 是 key 和 value 的组合。

18. for ... of 遍历：除了对象以外，它都能遍历。

    使用`Symbol.iterator`方法进行遍历。

19. promise 不是异步，而是用来解决异步的。

20. js声明语句：

    1. var 
    2. let
    3. const
    4. function
    5. label(内外for循环，outer，inner)
    6. class

21. constructor 实例化的时候就有了。

22. css重绘重排，js内存泄露。

23. 但凡碰到img，就要设置宽和高。

24. JS 闪烁，可能是定时器没有清除好。

25. 函数封装不会提高运行效率，但是会提高**代码开发的效率**和**可维护的效率**。

26. `forEach();`本身就是一个局部作用域。

27. 能用 DOM0 解决就用 DOM0，DOM0 解决不了的再用DOM2。

28. 一个页面中有两个 window.onload，只有后面那个生效。



### 课堂笔记（2021.2.2nd）

1. 栈、堆都在运行内存中。

2. 对象的Boolean都是true。

3. null的Boolean为false。

4. 点击事件的完成条件，鼠标在当前元素上按下，当前元素上抬起。

5. 键盘上的按键都会有一个键码，获取键码是通过event事件对象的keyCode属性。

6. 绑定键盘事件只能绑定给document。`document.onkeydown = function () {};`

7. 判断全等的话，switch比if要方便得多。

8. 只要`事件委托`就一定会有target。

9. 两种保存数值方式，一种是数组，一种是对象。有顺序用数组，没有顺序用对象。

10. **-nodeName**用的时候要注意，元素节点的nodeName要与标签名相同，而且要**大写**。
    **-nodeName**用的时候要注意，属性节点的nodeName要与属性名相同，而且要**小写**。

    （来源：CSDN）



### 课堂笔记（2021.2.3rd）

1. 面试中的 2+2+1

   2：两道题答得很好

   2：两道题中规中矩

   1：一道题会就答，不会就不会，不受影响。

2. [10, 80)：10~80

   中括号表示`包含`，小括号表示`不包含`。

3. p标签内不可以套p标签。如果你嵌套了，浏览器也会分开渲染解析，并且最后会多出来一对p标签。

   本身是父子，浏览器直接解析为兄弟元素了。

4. 定位会把元素提升一个层级，translate 也会把元素提升一个层级。





### 课堂笔记（2021.2.19th）

1. 字符编码：按照某种规则翻译成机器可读的文字。

2. 父子一般用padding（给父级设置padding），兄弟一般用margin。

3. 牵涉到左右布局，浮动时要设置宽度。

4. `flexbox froggy` 练习flex布局的经典游戏。

5. 过渡动画的触发条件：只要是能过渡的样式改变就能触发。如：hover，onclick，点击改变类名。

6. 判断null类型和undefined类型：全等。

7. 最大进制（36进制），`26个字母` + `0~9`。

8. 0进制的3为3，0进制转换时默认为10。

9. 科学计数法：

   12E23: 12x10的23次方。

10. 三元运算符：？：；

   三元运算符是有返回值的。

   ```js
    var b = 0;
   
    b =  a === 1?2:3;
   
    b = 2;
   ```

11. 缓存利用：

    1. 服务器的内容是否被修改，客户端需要向服务区核查。
    2. 每一个文件都有一个唯一的标识ID去判断是否一致，并且客户端和服务器文件的修改时间是否一致。

12. continue在while循环里会直接退出，continue在for里会停止当次循环，继续执行下面的代码。

13. 迭代：遍历。

    迭代语句：遍历语句。

14. try catch 语句。

15. 对象和数组的本质：存数据。

16. 清空数组：

    1. 等于一个空数组。（改变原数组）
    2. 设置length的长度为0。（不改变原数组）

17. 数组遍历方法：forEach、map、some、every

18. ```js
     var obj = {};
     obj.toString(); // "[object Object]"
     // "[object Object]" object 指这是一个对象，Object指这是一个对象类型。
    ```



### 课堂笔记（2021.2.22nd）

1. call、apply、bind是function原型对象上的方法。

   只要是函数都会有这个三个方法。
   
2. call 的返回值就是被调用函数的返回值。

3. bind返回一个函数。

4. 每个函数都有一个prototype属性，他默认指向一个Object空对象（即称为：原型对象）。

   只有函数才拥有prototype属性。

5. 显式原型：我们可以直接访问、操作、修改。

6. `processon` 画图工具。

7. 所有的函数都是function对象实例化出来的。

8. `function Function() {}` 这个function构造函数是被它自己实例化出来的。（function构造函数就是它自己的构造函数）。

9. 弹幕是用构造函数来写的。弹幕从右边生成，左边删除。

10. 函数既有隐式原型也有显式原型。

11. ```js
     Function.__proto__ === Function.prototype // true
    ```

12. ```js
     Function.__proto__.constructor == Function // ture
    ```

13. ```js
     Function.prototype.constructor === Function // true
    ```

14. ```js
     Object.__proto__.constructor === Function // true
    ```

    ```js
    console.log(Object.prototype.constructor === Object);
    console.log(Object.__proto__ === Function.__proto__);
    console.log(Object.__proto__.constructor === Function.constructor);
    console.log(Object.__proto__.__proto__=== Object.prototype);
    console.log(Object.__proto__.__proto__.__proto__=== null);
    console.log(Function.__proto__  === Function.prototype);
    ```

    当你在查询的时候，写的第一个代码永远都是构造函数。

15. 构造函数没有原型链，只有对象才有原型链。

16. 用新对象替换prototype属性，不会更改以前的实例。

17. `__proto__`属性，它是对象所独有的。`prototype` 是函数所独有的。

18. 实例：使用new操作符 创建一个实实在在的对象。

    实例化：使用new创建一个对象函数的过程。

19. 回调函数，匿名函数，构造函数，函数自定义。




### 课堂笔记（2021.2.20th）

1. 变量分为两种：

   1. 变量保存的是值。（基本类型的变量）
   2. 变量保存的是地址。（引用类型的变量）

2. 数据分为两种：

   1. 基本类型
   2. 对象类型

3. 释放内存：局部（自动释放）、全局（手动释放）。

4. 对象：

   1. 储存数据的一种数据结构`{}`。
   2. 显示事物在编程中的一个抽象。

5. 小括号的作用：

   1. 提升优先级
   2. 函数调用

6. 每一个函数都一个`call()` 和 `apply() `方法。

7. 只要是默认调用，this肯定指向window。

   计时器的this指向window。

8. 函数不调用，会隐式丢失。

9. 函数的返回值 return：

   返回要用return，return后面的值是返回值，这个值将会返回到函数的调用处。

   函数从哪里调用返回的结果就会返回到哪里去。

   什么时候使用return，什么时候不用return完全看你的函数的功能：

   1. 函数只是实现某功能，最终结果需要返回给**函数的调用者 函数名()**，通过return实现。
   2. 只要函数遇到return就会把后面的结果返回给函数的调用者，**函数名() = return 后面的结果**。

10. setTimeout 只执行一次，setInterval如果你不停止就会一直执行

11. 设置计时器是同步的，调用计时器是异步的。

12. 事件绑定后，只要不取消就会一直存在。

13. 计时器的this指向的是window。

14. 函数有两个身份：1. 函数(函数都有显示原型) 2. 对象(对象都有隐式原型)

15. 原型链是按照隐式原型一级一级来走的。

16. 只有构造函数才能真正使用prototype原型对象。只有函数被实例化以后prototype才会有用，不然prototype没有意义。

17. 设置对象的时候不会走原型链，获取对象的时候会根据原型链的规则查找。

18. 



